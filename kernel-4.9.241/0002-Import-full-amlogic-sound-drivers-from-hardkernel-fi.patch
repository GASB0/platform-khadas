From e2dcf97bdaf679c9c998fe2161467b2d4be7e0ec Mon Sep 17 00:00:00 2001
From: paolo <paolo.sabatino@gmail.com>
Date: Sun, 16 Apr 2023 16:53:28 +0000
Subject: [PATCH 2/2] Import full amlogic sound drivers from hardkernel, fix
 device tree to use correct earc bindings

---
 .gitignore                                    |    1 +
 arch/arm64/boot/dts/amlogic/kvim3l_linux.dts  |   32 +-
 arch/arm64/boot/dts/amlogic/mesonsm1.dtsi     |   48 +-
 drivers/amlogic/drm/am_meson_hdmi.c           |   39 +-
 include/linux/amlogic/media/sound/hdmi_earc.h |   25 +
 include/linux/amlogic/media/sound/iomapres.h  |   34 +
 include/linux/amlogic/media/sound/misc.h      |    3 +
 include/linux/amlogic/media/sound/mixer.h     |   43 +
 .../linux/amlogic/media/sound/spdif_info.h    |    2 +
 .../linux/amlogic/media/sound/usb_karaoke.h   |   27 +
 include/linux/extcon.h                        |    4 +
 include/sound/pcm.h                           |    8 +
 sound/soc/amlogic/auge/Kconfig                |    1 +
 sound/soc/amlogic/auge/Makefile               |    1 -
 sound/soc/amlogic/auge/audio_clks.c           |   15 +-
 sound/soc/amlogic/auge/audio_clks.h           |    1 +
 sound/soc/amlogic/auge/audio_controller.c     |   15 +-
 sound/soc/amlogic/auge/audio_utils.c          |   12 +-
 sound/soc/amlogic/auge/audio_utils.h          |    5 +-
 sound/soc/amlogic/auge/axg,clocks.c           |    2 -
 sound/soc/amlogic/auge/card.c                 |  144 +-
 sound/soc/amlogic/auge/ddr_mngr.c             |  306 +--
 sound/soc/amlogic/auge/ddr_mngr.h             |   17 +-
 sound/soc/amlogic/auge/earc.c                 | 1063 ++++++--
 sound/soc/amlogic/auge/earc_hw.c              |  915 ++++++-
 sound/soc/amlogic/auge/earc_hw.h              |  155 +-
 sound/soc/amlogic/auge/effects_hw_v2_coeff.h  |  104 +-
 sound/soc/amlogic/auge/effects_v2.c           |    4 +
 sound/soc/amlogic/auge/extn.c                 |  219 +-
 sound/soc/amlogic/auge/frhdmirx_hw.c          |   98 +-
 sound/soc/amlogic/auge/frhdmirx_hw.h          |   15 +-
 sound/soc/amlogic/auge/g12a,clocks.c          |    2 -
 sound/soc/amlogic/auge/iomap.c                |  118 +-
 sound/soc/amlogic/auge/iomap.h                |   74 +-
 sound/soc/amlogic/auge/locker.c               |   10 +-
 sound/soc/amlogic/auge/loopback.c             |   72 +-
 sound/soc/amlogic/auge/loopback_hw.c          |   16 +-
 sound/soc/amlogic/auge/loopback_hw.h          |    5 +
 sound/soc/amlogic/auge/pdm.c                  |    2 +
 sound/soc/amlogic/auge/pdm_hw.c               |    2 +-
 .../auge/{pdm_hw_coeff.c => pdm_hw_coeff.h}   |    7 +-
 sound/soc/amlogic/auge/regs.h                 |   33 +
 sound/soc/amlogic/auge/resample.c             |  300 ++-
 sound/soc/amlogic/auge/resample.h             |   13 +-
 sound/soc/amlogic/auge/resample_hw.c          |  244 +-
 sound/soc/amlogic/auge/resample_hw.h          |   35 +-
 sound/soc/amlogic/auge/resample_hw_coeff.h    | 2127 +++++++++++++++++
 sound/soc/amlogic/auge/sm1,clocks.c           |    2 -
 sound/soc/amlogic/auge/spdif.c                |   89 +-
 sound/soc/amlogic/auge/spdif_hw.c             |   17 +-
 sound/soc/amlogic/auge/tdm.c                  |   40 +-
 sound/soc/amlogic/auge/tdm_hw.c               |   15 +-
 sound/soc/amlogic/auge/tl1,clocks.c           |    2 -
 sound/soc/amlogic/auge/tm2,clocks.c           |    2 -
 sound/soc/amlogic/auge/vad.c                  |   24 +-
 sound/soc/amlogic/auge/vad.h                  |    2 +
 sound/soc/amlogic/auge/vad_hw.c               |    6 +
 sound/soc/amlogic/auge/vad_hw.h               |    3 +
 .../auge/{vad_hw_coeff.c => vad_hw_coeff.h}   |    6 +-
 sound/soc/amlogic/common/Makefile             |    3 +-
 sound/soc/amlogic/common/iomapres.c           |   75 +
 sound/soc/amlogic/common/misc.c               |   14 +-
 sound/soc/amlogic/common/spdif_info.c         |   13 +-
 sound/soc/amlogic/meson/audio_hw.c            |   22 +-
 sound/soc/amlogic/meson/audio_hw.h            |    3 +
 sound/soc/amlogic/meson/i2s_dai.c             |   32 +-
 sound/soc/amlogic/meson/i2s_dai.h             |    1 +
 sound/soc/amlogic/meson/pcm.c                 |    2 +
 sound/soc/amlogic/meson/pcm_dai.c             |    9 +-
 69 files changed, 5833 insertions(+), 967 deletions(-)
 create mode 100644 include/linux/amlogic/media/sound/hdmi_earc.h
 create mode 100644 include/linux/amlogic/media/sound/iomapres.h
 create mode 100644 include/linux/amlogic/media/sound/mixer.h
 create mode 100644 include/linux/amlogic/media/sound/usb_karaoke.h
 rename sound/soc/amlogic/auge/{pdm_hw_coeff.c => pdm_hw_coeff.h} (99%)
 create mode 100644 sound/soc/amlogic/auge/resample_hw_coeff.h
 rename sound/soc/amlogic/auge/{vad_hw_coeff.c => vad_hw_coeff.h} (96%)
 create mode 100644 sound/soc/amlogic/common/iomapres.c

diff --git a/.gitignore b/.gitignore
index 4105cfbd6f26..9d6d70fe2abc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -118,3 +118,4 @@ all.config
 
 # fetched Android config fragments
 kernel/configs/android-*.cfg
+drivers/gpu/arm/utgard/__malidrv_build_info.c
diff --git a/arch/arm64/boot/dts/amlogic/kvim3l_linux.dts b/arch/arm64/boot/dts/amlogic/kvim3l_linux.dts
index 5608663397ce..284ddfaac160 100644
--- a/arch/arm64/boot/dts/amlogic/kvim3l_linux.dts
+++ b/arch/arm64/boot/dts/amlogic/kvim3l_linux.dts
@@ -51,7 +51,7 @@
 //		device_type = "memory";
 //		linux,usable-memory = <0x0 0x000000 0x0 0x80000000>;
 //	};
-
+	
 	reserved-memory {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -1177,6 +1177,7 @@
 };
 
 &audiobus {
+	
 	tdma: tdm@0 {
 		compatible = "amlogic, sm1-snd-tdma";
 		#sound-dai-cells = <0>;
@@ -1332,31 +1333,6 @@
 		status = "okay";
 	};
 
-	earc:earc {
-		compatible = "amlogic, sm1-snd-earc";
-		#sound-dai-cells = <0>;
-
-		clocks = <&clkaudio CLKID_AUDIO_GATE_EARCRX
-			&clkaudio CLKID_EARCRX_CMDC
-			&clkaudio CLKID_EARCRX_DMAC
-			&clkc CLKID_FCLK_DIV5
-			&clkc CLKID_FCLK_DIV3
-			>;
-		clock-names = "rx_gate",
-			"rx_cmdc",
-			"rx_dmac",
-			"rx_cmdc_srcpll",
-			"rx_dmac_srcpll";
-
-		interrupts = <
-			GIC_SPI 88 IRQ_TYPE_EDGE_RISING
-			GIC_SPI 87 IRQ_TYPE_EDGE_RISING
-		>;
-		interrupt-names = "rx_cmdc", "rx_dmac";
-
-		status = "okay";
-	};
-
 	asrca: resample@0 {
 		compatible = "amlogic, sm1-resample";
 		clocks = <&clkc CLKID_MPLL3
@@ -1687,6 +1663,10 @@
 	};
 };  /* end of pinctrl_aobus */
 
+&earc {
+	status = "okay";
+};
+
 &audio_data {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/amlogic/mesonsm1.dtsi b/arch/arm64/boot/dts/amlogic/mesonsm1.dtsi
index 92974cb25e4b..4d5723a103d1 100644
--- a/arch/arm64/boot/dts/amlogic/mesonsm1.dtsi
+++ b/arch/arm64/boot/dts/amlogic/mesonsm1.dtsi
@@ -784,10 +784,10 @@
 
 		audiobus: audiobus@0xFF660000 {
 			compatible = "amlogic, audio-controller", "simple-bus";
-			reg = <0x0 0xFF660000 0x0 0x4000>;
+			reg = <0x0 0xFF660000 0x0 0x3000>;
 			#address-cells = <2>;
 			#size-cells = <2>;
-			ranges = <0x0 0x0 0x0 0xFF660000 0x0 0x4000>;
+			ranges = <0x0 0x0 0x0 0xFF660000 0x0 0x3000>;
 			clkaudio: audio_clocks {
 				compatible = "amlogic, sm1-audio-clocks";
 				#clock-cells = <1>;
@@ -812,6 +812,50 @@
 					"frddr_d";
 			};
 		};/* end of audiobus*/
+		
+		/* eARC */
+		audio_earc: bus@ff663000 {
+			compatible = "simple-bus";
+			reg = <0x0 0xff663000 0x0 0x1000>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges = <0x0 0x0 0x0 0xff663000 0x0 0x1000>;
+
+			earc: earc@0 {
+				compatible = "amlogic, sm1-snd-earc";
+				#sound-dai-cells = <0>;
+
+				status = "disabled";
+
+				reg =
+					<0x0 0x800 0x0 0x400>,
+					<0x0 0xc00 0x0 0x200>,
+					<0x0 0xe00 0x0 0x200>;
+				reg-names =
+					"rx_cmdc",
+					"rx_dmac",
+					"rx_top";
+
+				clocks = < &clkaudio CLKID_EARCRX_CMDC
+					&clkaudio CLKID_EARCRX_DMAC
+					&clkc CLKID_FCLK_DIV4
+					&clkc CLKID_FCLK_DIV4
+					&clkaudio CLKID_EARCTX_CMDC
+					&clkaudio CLKID_EARCTX_DMAC
+					&clkc CLKID_FCLK_DIV4
+					&clkc CLKID_MPLL1
+					>;
+				clock-names =
+					"rx_cmdc",
+					"rx_dmac",
+					"rx_cmdc_srcpll",
+					"rx_dmac_srcpll";
+
+				interrupts = <
+					GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "earc_rx";
+			};
+		};
 
 	}; /* end of soc*/
 
diff --git a/drivers/amlogic/drm/am_meson_hdmi.c b/drivers/amlogic/drm/am_meson_hdmi.c
index a2efd9c41972..b9a23047be60 100644
--- a/drivers/amlogic/drm/am_meson_hdmi.c
+++ b/drivers/amlogic/drm/am_meson_hdmi.c
@@ -35,9 +35,22 @@
 #include "am_meson_hdmi.h"
 #include "am_meson_hdcp.h"
 
+#include <linux/amlogic/media/sound/hdmi_earc.h>
+
 #define DEVICE_NAME "amhdmitx"
 struct am_hdmi_tx am_hdmi_info;
 
+#define HHI_REG_IDX		4
+#define BASE_REG_OFFSET		24
+
+#define HHI_REG_ADDR(reg) \
+	((HHI_REG_IDX << BASE_REG_OFFSET) + ((reg) << 2))
+
+#define TM2_HHI_HDMI_PHY_CNTL0 0x05
+#define P_TM2_HHI_HDMI_PHY_CNTL0 HHI_REG_ADDR(TM2_HHI_HDMI_PHY_CNTL0)
+#define HHI_HDMI_PHY_CNTL0 0xe8
+#define P_HHI_HDMI_PHY_CNTL0 HHI_REG_ADDR(HHI_HDMI_PHY_CNTL0)
+
 struct am_vout_mode {
 	char name[DRM_DISPLAY_MODE_LEN];
 	enum vmode_e mode;
@@ -72,6 +85,21 @@ static struct am_vout_mode am_vout_modes[] = {
 	{ "480p60hz", VMODE_HDMI, 720, 480, 60, 0},
 };
 
+static void hdmitx_phy_bandgap_en(struct hdmitx_dev *hdev)
+{
+	unsigned int val = 0;
+
+	switch (hdev->chip_type) {
+	case MESON_CPU_ID_SM1:
+		val = hd_read_reg(P_HHI_HDMI_PHY_CNTL0);
+		if (val == 0)
+			hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x0b4242);
+		break;
+	default:
+		break;
+	}
+}
+
 char *am_meson_hdmi_get_voutmode(struct drm_display_mode *mode)
 {
 	int i;
@@ -516,8 +544,10 @@ static irqreturn_t am_hdmi_hardirq(int irq, void *dev_id)
 {
 	unsigned int data32 = 0;
 	irqreturn_t ret = IRQ_NONE;
+	struct hdmitx_dev *hdmitx_dev;
 
 	data32 = hdmitx_rd_reg(HDMITX_TOP_INTR_STAT);
+	hdmitx_dev = get_hdmitx_device();
 
 	/* check HPD status */
 	if ((data32 & (1 << 1)) && (data32 & (1 << 2))) {
@@ -531,10 +561,15 @@ static irqreturn_t am_hdmi_hardirq(int irq, void *dev_id)
 		ret = IRQ_WAKE_THREAD;
 		DRM_INFO("hotplug irq: %x\n", data32);
 		am_hdmi_info.hpd_flag = 0;
-		if (data32 & (1 << 1))
+		if (data32 & (1 << 1)) {
 			am_hdmi_info.hpd_flag = 1;/* HPD rising */
-		if (data32 & (1 << 2))
+			hdmitx_phy_bandgap_en(hdmitx_dev);
+			earc_hdmitx_hpdst(1);
+		}
+		if (data32 & (1 << 2)) {
 			am_hdmi_info.hpd_flag = 2;/* HPD falling */
+			earc_hdmitx_hpdst(0);
+		}
 		/* ack INTERNAL_INTR or else*/
 		hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, data32 | 0x7);
 	}
diff --git a/include/linux/amlogic/media/sound/hdmi_earc.h b/include/linux/amlogic/media/sound/hdmi_earc.h
new file mode 100644
index 000000000000..36a8c5f9658e
--- /dev/null
+++ b/include/linux/amlogic/media/sound/hdmi_earc.h
@@ -0,0 +1,25 @@
+/*
+ * include/linux/amlogic/media/sound/hdmi_earc.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __HDMI_EARC_H__
+#define __HDMI_EARC_H__
+
+extern void earc_hdmirx_hpdst(int port, bool st);
+
+extern void earc_hdmitx_hpdst(bool st);
+
+#endif
diff --git a/include/linux/amlogic/media/sound/iomapres.h b/include/linux/amlogic/media/sound/iomapres.h
new file mode 100644
index 000000000000..b3b2fbd230a9
--- /dev/null
+++ b/include/linux/amlogic/media/sound/iomapres.h
@@ -0,0 +1,34 @@
+/*
+ * include/linux/amlogic/media/sound/iomapres.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __IOMAPRES_H__
+#define __IOMAPRES_H__
+
+#include <linux/regmap.h>
+
+struct regmap *regmap_resource(struct device *dev, char *name);
+
+unsigned int mmio_read(struct regmap *map, unsigned int reg_ofs);
+
+int mmio_write(struct regmap *map, unsigned int reg_ofs, unsigned int value);
+
+int mmio_update_bits(struct regmap *map,
+		     unsigned int reg_ofs,
+		     unsigned int mask,
+		     unsigned int value);
+
+#endif
diff --git a/include/linux/amlogic/media/sound/misc.h b/include/linux/amlogic/media/sound/misc.h
index c9e9fbda9613..866644e70b09 100644
--- a/include/linux/amlogic/media/sound/misc.h
+++ b/include/linux/amlogic/media/sound/misc.h
@@ -75,6 +75,9 @@ extern int aml_get_hdmiin_audio_packet(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
 
+extern int get_hdmiin_audio_stable(void);
+extern int get_hdmi_sample_rate_index(void);
+
 #endif
 
 #endif
diff --git a/include/linux/amlogic/media/sound/mixer.h b/include/linux/amlogic/media/sound/mixer.h
new file mode 100644
index 000000000000..980c02f25e88
--- /dev/null
+++ b/include/linux/amlogic/media/sound/mixer.h
@@ -0,0 +1,43 @@
+/*
+ * include/linux/amlogic/media/sound/mixer.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __MIXER_H__
+#define __MIXER_H__
+
+#include <sound/control.h>
+
+static int snd_int_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xffffffff;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+#define SND_INT(xname, xhandler_get, xhandler_put)     \
+{                                      \
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+	.name  = xname,               \
+	.info  = snd_int_info,        \
+	.get   = xhandler_get,        \
+	.put   = xhandler_put,        \
+}
+
+#endif
diff --git a/include/linux/amlogic/media/sound/spdif_info.h b/include/linux/amlogic/media/sound/spdif_info.h
index 36df67a80f96..9f40149a3d9c 100644
--- a/include/linux/amlogic/media/sound/spdif_info.h
+++ b/include/linux/amlogic/media/sound/spdif_info.h
@@ -29,6 +29,8 @@ struct iec958_chsts {
 	unsigned short chstat1_r;
 };
 
+bool spdifout_is_raw(void);
+
 extern bool spdif_is_4x_clk(void);
 
 extern void spdif_get_channel_status_info(struct iec958_chsts *chsts,
diff --git a/include/linux/amlogic/media/sound/usb_karaoke.h b/include/linux/amlogic/media/sound/usb_karaoke.h
new file mode 100644
index 000000000000..305c1658009c
--- /dev/null
+++ b/include/linux/amlogic/media/sound/usb_karaoke.h
@@ -0,0 +1,27 @@
+/*
+ * include/linux/amlogic/media/sound/usb_karaoke.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __USB_KARAOKE_H
+#define __USB_KARAOKE_H
+
+int i2s_out_mix_init(void);
+int i2s_out_mix_deinit(void);
+void aml_i2s_set_ch_r_info(
+	unsigned int channels,
+	unsigned int samplerate);
+
+#endif
diff --git a/include/linux/extcon.h b/include/linux/extcon.h
index 190a878ba6f7..6ac7d0a0d398 100644
--- a/include/linux/extcon.h
+++ b/include/linux/extcon.h
@@ -67,6 +67,10 @@
 #ifdef CONFIG_AMLOGIC_SND_SOC_AUGE
 #define EXTCON_SPDIFIN_SAMPLERATE 28	/* spdif in sample rate changed */
 #define EXTCON_SPDIFIN_AUDIOTYPE  29	/* spdif in PcPd detect */
+#define EXTCON_EARCRX_ATNDTYP_ARC  30   /* attended type, RX ARC */
+#define EXTCON_EARCRX_ATNDTYP_EARC 31   /* attended type, RX eARC */
+#define EXTCON_EARCTX_ATNDTYP_ARC  32   /* attended type, TX ARC */
+#define EXTCON_EARCTX_ATNDTYP_EARC 33   /* attended type, TX eARC */
 #endif
 /* Display external connector */
 #define EXTCON_DISP_HDMI	40	/* High-Definition Multimedia Interface */
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b1d3cce26ce2..51e353c7de16 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -129,6 +129,9 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
 #define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
 #define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+#define SNDRV_PCM_RATE_216000		(1<<13)		/* 216000Hz */
+#define SNDRV_PCM_RATE_352800		(1<<14)		/* 352800Hz */
+#define SNDRV_PCM_RATE_384000		(1<<15)		/* 384000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
@@ -141,6 +144,11 @@ struct snd_pcm_ops {
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_RATE_8000_384000	(SNDRV_PCM_RATE_8000_192000|\
+					SNDRV_PCM_RATE_216000|\
+					SNDRV_PCM_RATE_352800|\
+					SNDRV_PCM_RATE_384000)
+
 #define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
 #define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
 #define SNDRV_PCM_FMTBIT_U8		_SNDRV_PCM_FMTBIT(U8)
diff --git a/sound/soc/amlogic/auge/Kconfig b/sound/soc/amlogic/auge/Kconfig
index eafeb0d45de5..99a320c1a537 100644
--- a/sound/soc/amlogic/auge/Kconfig
+++ b/sound/soc/amlogic/auge/Kconfig
@@ -1,5 +1,6 @@
 menuconfig AMLOGIC_SND_SOC_AUGE
 	bool "Amlogic Auge ASoC"
+	select SND_SOC_PCM5102A
 	default n
 	help
 		Say Y or M if you want to add support for codecs attached to
diff --git a/sound/soc/amlogic/auge/Makefile b/sound/soc/amlogic/auge/Makefile
index f5d514c34454..b619542bbfdc 100644
--- a/sound/soc/amlogic/auge/Makefile
+++ b/sound/soc/amlogic/auge/Makefile
@@ -13,7 +13,6 @@ obj-$(CONFIG_AMLOGIC_SND_SOC_AUGE)	+= audio_controller.o \
 						spdif_hw.o \
 						pdm.o \
 						pdm_hw.o \
-						pdm_hw_coeff.o \
 						iomap.o \
 						ddr_mngr.o \
 						loopback.o \
diff --git a/sound/soc/amlogic/auge/audio_clks.c b/sound/soc/amlogic/auge/audio_clks.c
index 4aa82c362867..387edd115abe 100644
--- a/sound/soc/amlogic/auge/audio_clks.c
+++ b/sound/soc/amlogic/auge/audio_clks.c
@@ -23,6 +23,8 @@
 
 #define DRV_NAME "audio-clocks"
 
+DEFINE_SPINLOCK(aclk_lock);
+
 static const struct of_device_id audio_clocks_of_match[] = {
 	{
 		.compatible = "amlogic, axg-audio-clocks",
@@ -99,6 +101,8 @@ static int audio_clocks_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	pr_info("%s done\n", __func__);
+
 	return 0;
 }
 
@@ -109,7 +113,16 @@ static struct platform_driver audio_clocks_driver = {
 	},
 	.probe  = audio_clocks_probe,
 };
-module_platform_driver(audio_clocks_driver);
+
+int __init audio_clocks_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&audio_clocks_driver);
+
+	return ret;
+}
+core_initcall(audio_clocks_init);
 
 MODULE_AUTHOR("Amlogic, Inc.");
 MODULE_DESCRIPTION("Amlogic audio clocks ASoc driver");
diff --git a/sound/soc/amlogic/auge/audio_clks.h b/sound/soc/amlogic/auge/audio_clks.h
index a97cfc2fcbfb..cafc7c36bfc7 100644
--- a/sound/soc/amlogic/auge/audio_clks.h
+++ b/sound/soc/amlogic/auge/audio_clks.h
@@ -104,6 +104,7 @@ extern struct audio_clk_init g12a_audio_clks_init;
 extern struct audio_clk_init tl1_audio_clks_init;
 extern struct audio_clk_init sm1_audio_clks_init;
 extern struct audio_clk_init tm2_audio_clks_init;
+extern spinlock_t aclk_lock;
 
 struct clk_chipinfo {
 	/* force clock source as oscin(24M) */
diff --git a/sound/soc/amlogic/auge/audio_controller.c b/sound/soc/amlogic/auge/audio_controller.c
index 9a175aa55273..edf64742b377 100644
--- a/sound/soc/amlogic/auge/audio_controller.c
+++ b/sound/soc/amlogic/auge/audio_controller.c
@@ -29,6 +29,8 @@
 #include <linux/regmap.h>
 #include <linux/clk-provider.h>
 
+#include <linux/amlogic/media/sound/iomapres.h>
+
 #include "audio_io.h"
 #include "regs.h"
 #include "audio_aed_reg_list.h"
@@ -40,33 +42,34 @@ static unsigned int aml_audio_mmio_read(struct aml_audio_controller *actrlr,
 			unsigned int reg)
 {
 	struct regmap *regmap = actrlr->regmap;
-	unsigned int val;
-
-	regmap_read(regmap, (reg << 2), &val);
 
-	return val;
+	return mmio_read(regmap, reg);
 }
 
 static int aml_audio_mmio_write(struct aml_audio_controller *actrlr,
 			unsigned int reg, unsigned int value)
 {
 	struct regmap *regmap = actrlr->regmap;
+
 	pr_debug("audio top reg:[%s] addr: [%#x] val: [%#x]\n",
 			top_register_table[reg].name,
 			top_register_table[reg].addr,
 			value);
-	return regmap_write(regmap, (reg << 2), value);
+
+	return mmio_write(regmap, reg, value);
 }
 
 static int aml_audio_mmio_update_bits(struct aml_audio_controller *actrlr,
 			unsigned int reg, unsigned int mask, unsigned int value)
 {
 	struct regmap *regmap = actrlr->regmap;
+
 	pr_debug("audio top reg:[%s] addr: [%#x] mask: [%#x] val: [%#x]\n",
 			top_register_table[reg].name,
 			top_register_table[reg].addr,
 			mask, value);
-	return regmap_update_bits(regmap, (reg << 2), mask, value);
+
+	return mmio_update_bits(regmap, reg, mask, value);
 }
 
 struct aml_audio_ctrl_ops aml_actrl_mmio_ops = {
diff --git a/sound/soc/amlogic/auge/audio_utils.c b/sound/soc/amlogic/auge/audio_utils.c
index f5205a11de21..bc618e00ebf0 100644
--- a/sound/soc/amlogic/auge/audio_utils.c
+++ b/sound/soc/amlogic/auge/audio_utils.c
@@ -961,14 +961,20 @@ void fratv_enable(bool enable)
  * 0: select from ATV;
  * 1: select from ADEC;
  */
-void fratv_src_select(int src)
+void fratv_src_select(bool src)
 {
-	audiobus_update_bits(EE_AUDIO_FRATV_CTRL0, 0x1 << 20, (bool)src << 20);
+	audiobus_update_bits(EE_AUDIO_FRATV_CTRL0, 0x1 << 20, src << 20);
+}
+
+void fratv_LR_swap(bool swap)
+{
+	audiobus_update_bits(EE_AUDIO_FRATV_CTRL0, 0x1 << 19, swap << 19);
 }
 
 void cec_arc_enable(int src, bool enable)
 {
+	/* bits[1:0], 0x2: common; 0x1: single; 0x0: disabled */
 	aml_hiubus_update_bits(HHI_HDMIRX_ARC_CNTL,
 		0x1f << 0,
-		src << 2 | enable << 1 | 0x0 << 0);
+		src << 2 | (enable ? 0x1 : 0) << 0);
 }
diff --git a/sound/soc/amlogic/auge/audio_utils.h b/sound/soc/amlogic/auge/audio_utils.h
index 26981818541c..a665e4929df6 100644
--- a/sound/soc/amlogic/auge/audio_utils.h
+++ b/sound/soc/amlogic/auge/audio_utils.h
@@ -27,7 +27,10 @@ extern void audio_locker_set(int enable);
 extern int audio_locker_get(void);
 
 extern void fratv_enable(bool enable);
-extern void fratv_src_select(int src);
+
+extern void fratv_src_select(bool src);
+
+extern void fratv_LR_swap(bool swap);
 
 extern void cec_arc_enable(int src, bool enable);
 #endif
diff --git a/sound/soc/amlogic/auge/axg,clocks.c b/sound/soc/amlogic/auge/axg,clocks.c
index e337ac3c89bf..9b60ca96b4d0 100644
--- a/sound/soc/amlogic/auge/axg,clocks.c
+++ b/sound/soc/amlogic/auge/axg,clocks.c
@@ -22,8 +22,6 @@
 #include "audio_clks.h"
 #include "regs.h"
 
-static spinlock_t aclk_lock;
-
 static const char *const mclk_parent_names[] = {"mpll0", "mpll1",
 	"mpll2", "mpll3", "hifi_pll", "fclk_div3", "fclk_div4", "gp0_pll"};
 
diff --git a/sound/soc/amlogic/auge/card.c b/sound/soc/amlogic/auge/card.c
index cad5c5bf6b8e..1dc7247c6d03 100644
--- a/sound/soc/amlogic/auge/card.c
+++ b/sound/soc/amlogic/auge/card.c
@@ -84,7 +84,7 @@ struct aml_card_data {
 	int micphone_gpio_det;
 	int mic_detect_flag;
 	bool mic_det_enable;
-
+	bool av_mute_enable;
 	struct aml_chipset_info *chipinfo;
 };
 
@@ -440,6 +440,9 @@ static int aml_card_hw_params(struct snd_pcm_substream *substream,
 	else if (dai_props->mclk_fs)
 		mclk_fs = dai_props->mclk_fs;
 
+	if (params_rate(params) > 192000)
+		mclk_fs = 128;
+
 	if (mclk_fs) {
 		mclk = params_rate(params) * mclk_fs;
 
@@ -496,6 +499,20 @@ static int aml_card_dai_init(struct snd_soc_pcm_runtime *rtd)
 	bool idle_clk = false;
 	int ret, i;
 
+#if defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	struct snd_soc_card *card = rtd->card;
+	struct device *dev = aml_priv_to_dev(priv);
+
+	/* Hifi-shield2 : Digital volume is limited to 0dB */
+	ret = snd_soc_limit_volume(card, "Digital Playback Volume", 207);
+	if (ret < 0)
+		dev_dbg(dev, "Not found mixer : 'Digital Playback Volume'\n");
+
+	/* line-out : Digital volume is limited to 0dB */
+	ret = snd_soc_limit_volume(card, "DAC Digital Playback Volume", 254);
+	if (ret < 0)
+		dev_dbg(dev, "Not found mixer : 'DAC Digital Playback Volume'\n");
+#endif
 	/* enable dai-link mclk when CONTINUOUS clk setted */
 	idle_clk = !!(rtd->dai_link->dai_fmt & SND_SOC_DAIFMT_CONT);
 
@@ -556,29 +573,48 @@ static int aml_card_dai_link_of(struct device_node *node,
 		goto dai_link_of_err;
 	}
 
+	dai_link->cpu_of_node = of_parse_phandle(cpu, DAI, 0);
+	if (!dai_link->cpu_of_node) {
+		dev_err(dev, "error getting cpu phandle\n");
+		return -EINVAL;
+	}
+
 	ret = aml_card_parse_daifmt(dev, node, codec,
 					    prefix, &dai_link->dai_fmt);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(dev, "%s, dai fmt not found\n",
+			__func__);
 		goto dai_link_of_err;
-
+	}
 	of_property_read_u32(node, "mclk-fs", &dai_props->mclk_fs);
 
 	ret = aml_card_parse_cpu(cpu, dai_link,
 					 DAI, CELL, &single_cpu);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(dev, "%s, dai-link idx:%d, error getting cpu dai name:%s\n",
+			__func__,
+			idx,
+			dai_link->cpu_dai_name);
 		goto dai_link_of_err;
+	}
 
-#if 0
-	ret = aml_card_parse_codec(codec, dai_link, DAI, CELL);
-#else
 	ret = snd_soc_of_get_dai_link_codecs(dev, codec, dai_link);
-#endif
-	if (ret < 0)
+
+	if (ret < 0) {
+		dev_err(dev, "%s, dai-link idx:%d, error getting codec dai name:%s\n",
+			__func__,
+			idx,
+			dai_link->codec_dai_name);
 		goto dai_link_of_err;
+	}
 
 	ret = aml_card_parse_platform(plat, dai_link, DAI, CELL);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(dev, "%s, platform not found\n",
+			__func__);
+
 		goto dai_link_of_err;
+	}
 
 	ret = snd_soc_of_parse_tdm_slot(cpu,	&cpu_dai->tx_slot_mask,
 						&cpu_dai->rx_slot_mask,
@@ -602,12 +638,6 @@ static int aml_card_dai_link_of(struct device_node *node,
 	if (ret < 0)
 		goto dai_link_of_err;
 
-#if 0
-	ret = aml_card_parse_clk_codec(codec, dai_link, codec_dai);
-	if (ret < 0)
-		goto dai_link_of_err;
-#endif
-
 	ret = aml_card_canonicalize_dailink(dai_link);
 	if (ret < 0)
 		goto dai_link_of_err;
@@ -718,7 +748,7 @@ static int spk_mute_get(struct snd_kcontrol *kcontrol,
 }
 
 static const struct snd_kcontrol_new card_controls[] = {
-	SOC_SINGLE_BOOL_EXT("SPK mute", 0,
+	SOC_SINGLE_BOOL_EXT("LINE_OUT mute", 0,
 			    spk_mute_get,
 			    spk_mute_set),
 };
@@ -733,7 +763,7 @@ static int aml_card_parse_gpios(struct device_node *node,
 	bool active_low;
 	int ret;
 
-	gpio = of_get_named_gpio_flags(node, "spk_mute", 0, &flags);
+	gpio = of_get_named_gpio_flags(node, "mute_gpio", 0, &flags);
 	priv->spk_mute_gpio = gpio;
 
 	if (gpio_is_valid(gpio)) {
@@ -741,24 +771,34 @@ static int aml_card_parse_gpios(struct device_node *node,
 		flags = active_low ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
 		priv->spk_mute_active_low = active_low;
 
-		ret = devm_gpio_request_one(dev, gpio, flags, "spk_mute");
+		ret = devm_gpio_request_one(dev, gpio, flags, "line_mute");
 		if (ret >= 0) {
 			snd_soc_add_card_controls(soc_card, card_controls,
 					ARRAY_SIZE(card_controls));
 		}
 	}
-
-	priv->avout_mute_desc = gpiod_get(dev,
-				"avout_mute", GPIOF_OUT_INIT_LOW);
+#if !defined(CONFIG_ARCH_MESON64_ODROID_COMMON)
+	if (IS_ERR_OR_NULL(priv->avout_mute_desc)) {
+		priv->avout_mute_desc = gpiod_get(dev,
+					"avout_mute", GPIOF_OUT_INIT_LOW);
+	}
 	if (!IS_ERR(priv->avout_mute_desc)) {
-		msleep(500);
-		gpiod_direction_output(priv->avout_mute_desc,
-			GPIOF_OUT_INIT_HIGH);
-		pr_info("av out status: %s\n",
-			gpiod_get_value(priv->avout_mute_desc) ?
-			"high" : "low");
-
+		if (!priv->av_mute_enable) {
+			msleep(500);
+			gpiod_direction_output(priv->avout_mute_desc,
+				GPIOF_OUT_INIT_HIGH);
+			pr_info("av out status: %s\n",
+				gpiod_get_value(priv->avout_mute_desc) ?
+				"high" : "low");
+		} else {
+			gpiod_direction_output(priv->avout_mute_desc,
+				GPIOF_OUT_INIT_LOW);
+			pr_info("av out status: %s\n",
+				gpiod_get_value(priv->avout_mute_desc) ?
+				"high" : "low");
+		}
 	}
+#endif
 
 	return 0;
 }
@@ -773,7 +813,6 @@ static void aml_init_work(struct work_struct *init_work)
 			struct aml_card_data, init_work);
 	dev = aml_priv_to_dev(priv);
 	np = dev->of_node;
-
 	aml_card_parse_gpios(np, priv);
 }
 
@@ -872,6 +911,29 @@ static const struct of_device_id auge_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, auge_of_match);
 
+static int card_suspend_pre(struct snd_soc_card *card)
+{
+	struct aml_card_data *priv = snd_soc_card_get_drvdata(card);
+
+	priv->av_mute_enable = 1;
+	INIT_WORK(&priv->init_work, aml_init_work);
+	schedule_work(&priv->init_work);
+	pr_info("it is card_pre_suspend\n");
+	return 0;
+}
+
+static int card_resume_post(struct snd_soc_card *card)
+{
+	struct aml_card_data *priv = snd_soc_card_get_drvdata(card);
+
+	priv->av_mute_enable = 0;
+	INIT_WORK(&priv->init_work, aml_init_work);
+	schedule_work(&priv->init_work);
+	pr_info("it is card_post_resume\n");
+	return 0;
+
+}
+
 static int aml_card_probe(struct platform_device *pdev)
 {
 	struct aml_card_data *priv;
@@ -912,13 +974,17 @@ static int aml_card_probe(struct platform_device *pdev)
 	priv->snd_card.dev		= dev;
 	priv->snd_card.dai_link		= priv->dai_link;
 	priv->snd_card.num_links	= num;
+	priv->snd_card.suspend_pre	= card_suspend_pre;
+	priv->snd_card.resume_post	= card_resume_post;
 
 	if (np && of_device_is_available(np)) {
 
 		ret = aml_card_parse_of(np, priv);
 		if (ret < 0) {
-			dev_err(dev, "%s, parse error %d\n",
-			    __func__, ret);
+			dev_err(dev, "%s, aml_card_parse_of error %d %s\n",
+				__func__,
+				ret,
+				(ret == -EPROBE_DEFER) ? "PROBE RETRY" : "");
 			goto err;
 		}
 
@@ -956,6 +1022,7 @@ static int aml_card_probe(struct platform_device *pdev)
 					sizeof(priv->dai_props->codec_dai));
 	}
 
+	platform_set_drvdata(pdev, priv);
 	snd_soc_card_set_drvdata(&priv->snd_card, priv);
 
 	ret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
@@ -982,7 +1049,7 @@ static int aml_card_probe(struct platform_device *pdev)
 		audio_jack_detect(priv);
 		audio_extcon_register(priv, dev);
 	}
-
+	priv->av_mute_enable = 0;
 	INIT_WORK(&priv->init_work, aml_init_work);
 	schedule_work(&priv->init_work);
 
@@ -1005,6 +1072,16 @@ static int aml_card_remove(struct platform_device *pdev)
 	return aml_card_clean_reference(card);
 }
 
+static void aml_card_platform_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct aml_card_data *priv = snd_soc_card_get_drvdata(card);
+
+	priv->av_mute_enable = 1;
+	INIT_WORK(&priv->init_work, aml_init_work);
+	schedule_work(&priv->init_work);
+}
+
 static struct platform_driver aml_card = {
 	.driver = {
 		.name = "asoc-aml-card",
@@ -1013,6 +1090,7 @@ static struct platform_driver aml_card = {
 	},
 	.probe = aml_card_probe,
 	.remove = aml_card_remove,
+	.shutdown = aml_card_platform_shutdown,
 };
 
 module_platform_driver(aml_card);
diff --git a/sound/soc/amlogic/auge/ddr_mngr.c b/sound/soc/amlogic/auge/ddr_mngr.c
index 67c6cec21b0b..60dc133194c7 100644
--- a/sound/soc/amlogic/auge/ddr_mngr.c
+++ b/sound/soc/amlogic/auge/ddr_mngr.c
@@ -104,7 +104,6 @@ static struct toddr *register_toddr_l(struct device *dev,
 	/*		(1 << 31)|(1 << mask_bit));*/
 
 	to->dev = dev;
-	to->actrl = actrl;
 	to->in_use = true;
 	pr_debug("toddrs[%d] registered by device %s\n", i, dev_name(dev));
 	return to;
@@ -145,7 +144,6 @@ static int unregister_toddr_l(struct device *dev, void *data)
 
 	free_irq(to->irq, data);
 	to->dev = NULL;
-	to->actrl = NULL;
 	to->in_use = false;
 	pr_debug("toddrs[%d] released by device %s\n", i, dev_name(dev));
 
@@ -203,6 +201,19 @@ int aml_audio_unregister_toddr(struct device *dev, void *data)
 	return ret;
 }
 
+void audio_toddr_irq_enable(struct toddr *to, bool en)
+{
+	if (!to || !to->in_use || to->irq < 0)
+		return;
+
+	mutex_lock(&ddr_mutex);
+	if (en)
+		enable_irq(to->irq);
+	else
+		disable_irq_nosync(to->irq);
+	mutex_unlock(&ddr_mutex);
+}
+
 static inline unsigned int
 	calc_toddr_address(unsigned int reg, unsigned int base)
 {
@@ -430,8 +441,8 @@ void aml_toddr_set_format(struct toddr *to, struct toddr_fmt *fmt)
 
 	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
 	aml_audiobus_update_bits(actrl, reg,
-		0x7 << 24 | 0x1fff << 3,
-		fmt->endian << 24 | fmt->type << 13 |
+		0x1 << 27 | 0x7 << 24 | 0x1fff << 3,
+		0x1 << 27 | fmt->endian << 24 | fmt->type << 13 |
 		fmt->msb << 8 | fmt->lsb << 3);
 }
 
@@ -446,6 +457,11 @@ unsigned int aml_toddr_get_status(struct toddr *to)
 	return aml_audiobus_read(actrl, reg);
 }
 
+unsigned int aml_toddr_get_fifo_cnt(struct toddr *to)
+{
+	return (aml_toddr_get_status(to) & TODDR_FIFO_CNT) >> 8;
+}
+
 void aml_toddr_ack_irq(struct toddr *to, int status)
 {
 	struct aml_audio_controller *actrl = to->actrl;
@@ -529,6 +545,31 @@ bool aml_toddr_burst_finished(struct toddr *to)
 	struct aml_audio_controller *actrl = to->actrl;
 	unsigned int reg_base = to->reg_base;
 	unsigned int reg;
+	bool fifo_stop = false;
+
+	/* This is a SW workaround.
+	 * If not wait until the fifo stops,
+	 * DDR will stuck and could not recover unless reboot.
+	 */
+	for (i = 0; i < 10; i++) {
+		unsigned int cnt0, cnt1, cnt2;
+
+		cnt0 = aml_toddr_get_fifo_cnt(to);
+		udelay(10);
+		cnt1 = aml_toddr_get_fifo_cnt(to);
+		udelay(10);
+		cnt2 = aml_toddr_get_fifo_cnt(to);
+		pr_debug("i: %d, fifo cnt:[%d] cnt1:[%d] cnt2:[%d]\n",
+			i, cnt0, cnt1, cnt2);
+
+		/* fifo stopped */
+		if ((cnt0 == cnt1) && (cnt0 == cnt2) && (cnt0 < (0x40 - 2))) {
+			pr_debug("%s(), i (%d) cnt(%d) break out\n",
+				__func__, i, cnt2);
+			fifo_stop = true;
+			break;
+		}
+	}
 
 	/* max 200us delay */
 	for (i = 0; i < 200; i++) {
@@ -540,12 +581,15 @@ bool aml_toddr_burst_finished(struct toddr *to)
 		aml_audiobus_update_bits(actrl,	reg, 0xf << 8, 0x2 << 8);
 		addr_reply = aml_toddr_get_position(to);
 
-		if (addr_request == addr_reply)
+		if (addr_request == addr_reply) {
+			pr_debug("%s(), fifo_stop %d\n", __func__, fifo_stop);
 			return true;
+		}
 
 		udelay(1);
-		pr_debug("delay:[%dus]; FRDDR_STATUS2: [0x%x] [0x%x]\n",
-			i, addr_request, addr_reply);
+		if ((i % 20) == 0)
+			pr_info("delay:[%dus]; FRDDR_STATUS2: [0x%x] [0x%x]\n",
+				i, addr_request, addr_reply);
 	}
 	pr_err("Error: 200us time out, TODDR_STATUS2: [0x%x] [0x%x]\n",
 				addr_request, addr_reply);
@@ -562,6 +606,7 @@ static void aml_toddr_set_resample(struct toddr *to, bool enable)
 	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
 	aml_audiobus_update_bits(actrl,	reg, 1<<30, !!enable<<30);
 }
+
 /* tl1 after */
 static void aml_toddr_set_resample_ab(struct toddr *to,
 		enum resample_idx index, bool enable)
@@ -573,8 +618,7 @@ static void aml_toddr_set_resample_ab(struct toddr *to,
 	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
 	if (index == RESAMPLE_A)
 		aml_audiobus_update_bits(actrl,	reg, 1 << 27, !!enable << 27);
-	else if (index == RESAMPLE_B)
-		aml_audiobus_update_bits(actrl,	reg, 1 << 26, !!enable << 26);
+
 }
 
 static void aml_resample_enable(
@@ -587,24 +631,6 @@ static void aml_resample_enable(
 		return;
 	}
 
-	if (to->chipinfo
-			&& to->chipinfo->asrc_src_sel_ctrl) {
-		/* fix asrc_src_sel */
-		switch (p_attach_resample->attach_module) {
-		case LOOPBACK_A:
-			to->asrc_src_sel = ASRC_LOOPBACK_A;
-			break;
-		case LOOPBACK_B:
-			to->asrc_src_sel = ASRC_LOOPBACK_B;
-			break;
-		default:
-			to->asrc_src_sel = to->fifo_id;
-			break;
-		}
-
-		/*to->asrc_src_sel = p_attach_resample->attach_module;*/
-	}
-
 	pr_info("toddr %d selects data to %s resample_%c for module:%s\n",
 		to->fifo_id,
 		enable ? "enable" : "disable",
@@ -639,27 +665,37 @@ static void aml_resample_enable(
 				endian << 24 | toddr_type << 13);
 		}
 
-		resample_format_set(p_attach_resample->id,
-			to->channels, bitwidth);
-
-		/* toddr index for resample */
-		if (to->chipinfo
-			&& to->chipinfo->asrc_src_sel_ctrl)
-			resample_src_select_ab(p_attach_resample->id,
-				to->asrc_src_sel);
-		else
-			resample_src_select(to->fifo_id);
+		if (p_attach_resample->resample_version == 1) {
+			new_resample_set_format(p_attach_resample->id,
+						to->channels, bitwidth);
+			new_resample_src_select(p_attach_resample->id,
+						to->fifo_id);
+		} else if (p_attach_resample->resample_version == 0) {
+			/* toddr index for resample */
+			if (to->chipinfo &&
+			    to->chipinfo->asrc_src_sel_ctrl) {
+				resample_src_select_ab(p_attach_resample->id,
+						       to->fifo_id);
+			} else {
+				resample_src_select(to->fifo_id);
+			}
+			resample_format_set(p_attach_resample->id,
+					    to->channels, bitwidth);
+		}
 	}
 
-	/* resample enable or not */
-	resample_enable(p_attach_resample->id, enable);
-
 	/* select reample data */
 	if (to->chipinfo
 			&& to->chipinfo->asrc_src_sel_ctrl)
 		aml_toddr_set_resample_ab(to, p_attach_resample->id, enable);
 	else
 		aml_toddr_set_resample(to, enable);
+
+	/* resample enable or disable */
+	if (p_attach_resample->resample_version == 1)
+		new_resample_enable(p_attach_resample->id, enable);
+	else if (p_attach_resample->resample_version == 0)
+		resample_enable(p_attach_resample->id, enable);
 }
 
 void aml_set_resample(enum resample_idx id,
@@ -667,7 +703,6 @@ void aml_set_resample(enum resample_idx id,
 {
 	struct toddr_attach *p_attach_resample;
 	struct toddr *to;
-	bool update_running = false;
 
 	if (id == RESAMPLE_A)
 		p_attach_resample = &attach_resample_a;
@@ -677,6 +712,7 @@ void aml_set_resample(enum resample_idx id,
 	p_attach_resample->enable        = enable;
 	p_attach_resample->id            = id;
 	p_attach_resample->attach_module = resample_module;
+	p_attach_resample->resample_version = get_resample_version_id(id);
 
 	mutex_lock(&ddr_mutex);
 	to = fetch_toddr_by_src(
@@ -686,26 +722,7 @@ void aml_set_resample(enum resample_idx id,
 		goto exit;
 	}
 
-	if (enable) {
-		if ((p_attach_resample->status == DISABLED)
-			|| (p_attach_resample->status == READY)) {
-
-			if (!to) {
-				p_attach_resample->status = READY;
-			} else {
-				p_attach_resample->status = RUNNING;
-				update_running = true;
-				pr_info("Capture with resample\n");
-			}
-		}
-	} else {
-		if (p_attach_resample->status == RUNNING)
-			update_running = true;
-
-		p_attach_resample->status = DISABLED;
-	}
-
-	if (update_running && to)
+	if (p_attach_resample->status == RUNNING)
 		aml_resample_enable(to, p_attach_resample, enable);
 
 exit:
@@ -719,32 +736,24 @@ void aml_set_resample(enum resample_idx id,
 static void aml_check_resample(struct toddr *to, bool enable)
 {
 	struct toddr_attach *p_attach_resample;
-	bool is_module_resample;
-	bool resample_b_check = false;
+	int i;
 
 	p_attach_resample = &attach_resample_a;
 
-start_check:
-	is_module_resample = false;
-	if (p_attach_resample->enable
-		&& (to->src == p_attach_resample->attach_module))
-		is_module_resample = true;
-
-	/* resample in enable */
-	if (is_module_resample) {
-		if (enable)
-			p_attach_resample->status = RUNNING;
-		else
-			p_attach_resample->status = DISABLED;
-
-		aml_resample_enable(to, p_attach_resample, enable);
-	}
+	for (i = 0; i < get_resample_module_num(); i++) {
+		if (to->src == p_attach_resample->attach_module) {
+			/* save toddr status */
+			if (enable)
+				p_attach_resample->status = RUNNING;
+			else
+				p_attach_resample->status = DISABLED;
 
-	if ((!resample_b_check)
-		&& (get_resample_module_num() == 2)) {
+			/*if disable toddr, disable attached resampler*/
+			if (p_attach_resample->enable)
+				aml_resample_enable(to, p_attach_resample,
+						    enable);
+		}
 		p_attach_resample = &attach_resample_b;
-		resample_b_check = true;
-		goto start_check;
 	}
 }
 
@@ -937,7 +946,6 @@ static struct frddr *register_frddr_l(struct device *dev,
 		return NULL;
 	}
 	from->dev = dev;
-	from->actrl = actrl;
 	from->in_use = true;
 	pr_debug("frddrs[%d] registered by device %s\n", i, dev_name(dev));
 	return from;
@@ -978,7 +986,6 @@ static int unregister_frddr_l(struct device *dev, void *data)
 
 	free_irq(from->irq, data);
 	from->dev = NULL;
-	from->actrl = NULL;
 	from->in_use = false;
 	pr_debug("frddrs[%d] released by device %s\n", i, dev_name(dev));
 	return 0;
@@ -1560,7 +1567,8 @@ static int toddr_src_enum_set(struct snd_kcontrol *kcontrol,
 static int frddr_src_idx = -1;
 
 static const char *const frddr_src_sel_texts[] = {
-	"TDMOUT_A", "TDMOUT_B", "TDMOUT_C", "SPDIFOUT_A", "SPDIFOUT_B"
+	"TDMOUT_A", "TDMOUT_B", "TDMOUT_C",
+	"SPDIFOUT_A", "SPDIFOUT_B", "EARCTX_DMAC"
 };
 
 static const struct soc_enum frddr_output_source_enum =
@@ -1574,7 +1582,7 @@ int frddr_src_get(void)
 
 const char *frddr_src_get_str(int idx)
 {
-	if (idx < 0 || idx > 4)
+	if (idx < 0 || idx >= FRDDR_MAX)
 		return NULL;
 
 	return frddr_src_sel_texts[idx];
@@ -1708,77 +1716,93 @@ static struct notifier_block ddr_pm_notifier_block = {
 	.notifier_call = ddr_pm_event,
 };
 
+/* table Must in order */
+static struct ddr_info ddr_info[] = {
+	{EE_AUDIO_TODDR_A_CTRL0, EE_AUDIO_FRDDR_A_CTRL0, "toddr_a", "frddr_a"},
+	{EE_AUDIO_TODDR_B_CTRL0, EE_AUDIO_FRDDR_B_CTRL0, "toddr_b", "frddr_b"},
+	{EE_AUDIO_TODDR_C_CTRL0, EE_AUDIO_FRDDR_C_CTRL0, "toddr_c", "frddr_c"},
+	{EE_AUDIO_TODDR_D_CTRL0, EE_AUDIO_FRDDR_D_CTRL0, "toddr_d", "frddr_d"},
+};
+
+static int ddr_get_toddr_base_addr_by_idx(int idx)
+{
+	return ddr_info[idx].toddr_addr;
+}
+
+static int ddr_get_frddr_base_addr_by_idx(int idx)
+{
+	return ddr_info[idx].frddr_addr;
+}
+
+static char *ddr_get_toddr_name_by_idx(int idx)
+{
+	return ddr_info[idx].toddr_name;
+}
+
+static char *ddr_get_frddr_name_by_idx(int idx)
+{
+	return ddr_info[idx].frddr_name;
+}
+
 static int aml_ddr_mngr_platform_probe(struct platform_device *pdev)
 {
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node_prt = NULL;
+	struct platform_device *pdev_parent;
+	struct aml_audio_controller *actrl = NULL;
 	struct ddr_chipinfo *p_ddr_chipinfo;
 	int ddr_num = 3; /* early chipset support max 3 ddr num */
 	int i, ret;
 
+	/* get audio controller */
+	node_prt = of_get_parent(node);
+	if (!node_prt)
+		return -ENXIO;
+
+	pdev_parent = of_find_device_by_node(node_prt);
+	of_node_put(node_prt);
+	actrl = (struct aml_audio_controller *)
+				platform_get_drvdata(pdev_parent);
+
 	p_ddr_chipinfo = (struct ddr_chipinfo *)
 		of_device_get_match_data(&pdev->dev);
-	if (!p_ddr_chipinfo)
-		dev_warn_once(&pdev->dev,
-			"check whether to update ddr_mngr chipinfo\n");
-
-	/* irqs */
-	toddrs[DDR_A].irq = platform_get_irq_byname(pdev, "toddr_a");
-	toddrs[DDR_B].irq = platform_get_irq_byname(pdev, "toddr_b");
-	toddrs[DDR_C].irq = platform_get_irq_byname(pdev, "toddr_c");
-
-	frddrs[DDR_A].irq = platform_get_irq_byname(pdev, "frddr_a");
-	frddrs[DDR_B].irq = platform_get_irq_byname(pdev, "frddr_b");
-	frddrs[DDR_C].irq = platform_get_irq_byname(pdev, "frddr_c");
-
-	if (p_ddr_chipinfo
-		&& (p_ddr_chipinfo->fifo_num == 4)) {
-		toddrs[DDR_D].irq = platform_get_irq_byname(pdev, "toddr_d");
-		frddrs[DDR_D].irq = platform_get_irq_byname(pdev, "frddr_d");
-		if (toddrs[DDR_D].irq < 0 || frddrs[DDR_D].irq < 0)
-			dev_err(&pdev->dev, "check irq for DDR_D\n");
-		ddr_num = p_ddr_chipinfo->fifo_num;
+	if (!p_ddr_chipinfo) {
+		dev_err(&pdev->dev,
+			"check to update ddr_mngr chipinfo\n");
+		return -EINVAL;
 	}
 
+	if (p_ddr_chipinfo->fifo_num == 2)
+		ddr_num = p_ddr_chipinfo->fifo_num;
+	else if (p_ddr_chipinfo->fifo_num == 4)
+		ddr_num = p_ddr_chipinfo->fifo_num;
+
 	for (i = 0; i < ddr_num; i++) {
-		pr_info("%d, irqs toddr %d, frddr %d\n",
-			i, toddrs[i].irq, frddrs[i].irq);
+		toddrs[i].irq =
+			platform_get_irq_byname(pdev,
+						ddr_get_toddr_name_by_idx(i));
+		toddrs[i].reg_base = ddr_get_toddr_base_addr_by_idx(i);
+		toddrs[i].fifo_id  = i;
+		toddrs[i].chipinfo = p_ddr_chipinfo;
+		toddrs[i].actrl    = actrl;
+
+		frddrs[i].irq =
+			platform_get_irq_byname(pdev,
+						ddr_get_frddr_name_by_idx(i));
+		frddrs[i].reg_base = ddr_get_frddr_base_addr_by_idx(i);
+		frddrs[i].fifo_id  = i;
+		frddrs[i].chipinfo = p_ddr_chipinfo;
+		frddrs[i].actrl    = actrl;
+
+		dev_info(&pdev->dev, "%d, irqs toddr %d, frddr %d\n",
+			 i, toddrs[i].irq, frddrs[i].irq);
+
 		if (toddrs[i].irq <= 0 || frddrs[i].irq <= 0) {
-			dev_err(&pdev->dev, "platform_get_irq_byname failed\n");
+			dev_err(&pdev->dev, "%s, get irq failed\n", __func__);
 			return -ENXIO;
 		}
 	}
 
-	/* inits */
-	toddrs[DDR_A].reg_base = EE_AUDIO_TODDR_A_CTRL0;
-	toddrs[DDR_B].reg_base = EE_AUDIO_TODDR_B_CTRL0;
-	toddrs[DDR_C].reg_base = EE_AUDIO_TODDR_C_CTRL0;
-	toddrs[DDR_A].fifo_id  = DDR_A;
-	toddrs[DDR_B].fifo_id  = DDR_B;
-	toddrs[DDR_C].fifo_id  = DDR_C;
-
-	frddrs[DDR_A].reg_base = EE_AUDIO_FRDDR_A_CTRL0;
-	frddrs[DDR_B].reg_base = EE_AUDIO_FRDDR_B_CTRL0;
-	frddrs[DDR_C].reg_base = EE_AUDIO_FRDDR_C_CTRL0;
-	frddrs[DDR_A].fifo_id  = DDR_A;
-	frddrs[DDR_B].fifo_id  = DDR_B;
-	frddrs[DDR_C].fifo_id  = DDR_C;
-
-	if (p_ddr_chipinfo) {
-		toddrs[DDR_A].chipinfo = p_ddr_chipinfo;
-		toddrs[DDR_B].chipinfo = p_ddr_chipinfo;
-		toddrs[DDR_C].chipinfo = p_ddr_chipinfo;
-		frddrs[DDR_A].chipinfo = p_ddr_chipinfo;
-		frddrs[DDR_B].chipinfo = p_ddr_chipinfo;
-		frddrs[DDR_C].chipinfo = p_ddr_chipinfo;
-
-		if (p_ddr_chipinfo->fifo_num == 4) {
-			toddrs[DDR_D].reg_base = EE_AUDIO_TODDR_D_CTRL0;
-			toddrs[DDR_D].fifo_id  = DDR_D;
-
-			frddrs[DDR_D].reg_base = EE_AUDIO_FRDDR_D_CTRL0;
-			frddrs[DDR_D].fifo_id  = DDR_D;
-		}
-	}
-
 	ret = register_pm_notifier(&ddr_pm_notifier_block);
 	if (ret)
 		pr_warn("[%s] failed to register PM notifier %d\n",
diff --git a/sound/soc/amlogic/auge/ddr_mngr.h b/sound/soc/amlogic/auge/ddr_mngr.h
index c3e9c7b263e1..a70c716195db 100644
--- a/sound/soc/amlogic/auge/ddr_mngr.h
+++ b/sound/soc/amlogic/auge/ddr_mngr.h
@@ -31,6 +31,9 @@
 #define MEMIF_INT_FIFO_DEPTH        BIT(5)
 #define MEMIF_INT_MASK              GENMASK(7, 0)
 
+#define TODDR_FIFO_CNT                    GENMASK(19, 8)
+#define FRDDR_FIFO_CNT                    GENMASK(17, 8)
+
 enum ddr_num {
 	DDR_A,
 	DDR_B,
@@ -90,6 +93,8 @@ enum frddr_dest {
 	TDMOUT_C,
 	SPDIFOUT_A,
 	SPDIFOUT_B,
+	EARCTX_DMAC,
+	FRDDR_MAX
 };
 
 enum status_sel {
@@ -173,8 +178,6 @@ struct toddr {
 	enum toddr_src src;
 	unsigned int fifo_id;
 
-	enum resample_src asrc_src_sel;
-
 	int is_lb; /* check whether for loopback */
 	int irq;
 	bool in_use: 1;
@@ -196,6 +199,7 @@ struct toddr_attach {
 	 * check which toddr in use should be attached
 	 */
 	enum toddr_src attach_module;
+	int resample_version;
 };
 
 struct frddr_attach {
@@ -230,12 +234,20 @@ struct frddr {
 	bool reserved;
 };
 
+struct ddr_info {
+	unsigned int toddr_addr;
+	unsigned int frddr_addr;
+	char *toddr_name;
+	char *frddr_name;
+};
+
 /* to ddrs */
 struct toddr *fetch_toddr_by_src(int toddr_src);
 struct toddr *aml_audio_register_toddr(struct device *dev,
 		struct aml_audio_controller *actrl,
 		irq_handler_t handler, void *data);
 int aml_audio_unregister_toddr(struct device *dev, void *data);
+void audio_toddr_irq_enable(struct toddr *to, bool en);
 int aml_toddr_set_buf(struct toddr *to, unsigned int start,
 			unsigned int end);
 int aml_toddr_set_buf_startaddr(struct toddr *to, unsigned int start);
@@ -252,6 +264,7 @@ void aml_toddr_force_finish(struct toddr *to);
 void aml_toddr_set_format(struct toddr *to, struct toddr_fmt *fmt);
 
 unsigned int aml_toddr_get_status(struct toddr *to);
+unsigned int aml_toddr_get_fifo_cnt(struct toddr *to);
 void aml_toddr_ack_irq(struct toddr *to, int status);
 
 void aml_toddr_insert_chanum(struct toddr *to);
diff --git a/sound/soc/amlogic/auge/earc.c b/sound/soc/amlogic/auge/earc.c
index c284417c2c65..979211a07b20 100644
--- a/sound/soc/amlogic/auge/earc.c
+++ b/sound/soc/amlogic/auge/earc.c
@@ -16,6 +16,7 @@
  * Audio External Input/Out drirver
  * such as fratv, frhdmirx
  */
+#define DEBUG
 
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -27,6 +28,7 @@
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
 #include <linux/clk.h>
+#include <linux/extcon.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/initval.h>
@@ -34,6 +36,8 @@
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 
+#include <linux/amlogic/media/sound/hdmi_earc.h>
+#include <linux/amlogic/media/sound/mixer.h>
 #include "ddr_mngr.h"
 #include "earc_hw.h"
 
@@ -54,17 +58,29 @@ struct earc {
 	struct clk *clk_tx_cmdc_srcpll;
 	struct clk *clk_tx_dmac_srcpll;
 
+	struct regmap *tx_cmdc_map;
+	struct regmap *tx_dmac_map;
+	struct regmap *tx_top_map;
+	struct regmap *rx_cmdc_map;
+	struct regmap *rx_dmac_map;
+	struct regmap *rx_top_map;
+
 	struct toddr *tddr;
 	struct frddr *fddr;
 
-	int irq_rx_cmdc;
-	int irq_rx_dmac;
-	int irq_tx_cmdc;
-	int irq_tx_dmac;
+	int irq_earc_rx;
+	int irq_earc_tx;
+
+	/* external connect */
+	struct extcon_dev *rx_edev;
+	struct extcon_dev *tx_edev;
 
-	int sysclk_freq;
+	bool rx_dmac_clk_on;
+	bool tx_dmac_clk_on;
 };
 
+static struct earc *s_earc;
+
 #define PREALLOC_BUFFER_MAX	(256 * 1024)
 
 #define EARC_RATES      (SNDRV_PCM_RATE_8000_192000)
@@ -94,10 +110,10 @@ static const struct snd_pcm_hardware earc_hardware = {
 	.channels_max = 32,
 };
 
-static irqreturn_t earc_ddr_isr(int irq, void *devid)
+static irqreturn_t earc_ddr_isr(int irq, void *data)
 {
 	struct snd_pcm_substream *substream =
-		(struct snd_pcm_substream *)devid;
+		(struct snd_pcm_substream *)data;
 
 	if (!snd_pcm_running(substream))
 		return IRQ_HANDLED;
@@ -107,23 +123,196 @@ static irqreturn_t earc_ddr_isr(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t earc_rx_cmdc_isr(int irq, void *devid)
+static void earcrx_update_attend_event(struct earc *p_earc,
+				       bool is_earc, bool state)
 {
-	return IRQ_HANDLED;
+	if (state) {
+		if (is_earc) {
+			extcon_set_state_sync(p_earc->rx_edev,
+				EXTCON_EARCRX_ATNDTYP_ARC, false);
+			extcon_set_state_sync(p_earc->rx_edev,
+				EXTCON_EARCRX_ATNDTYP_EARC, state);
+		} else {
+			extcon_set_state_sync(p_earc->rx_edev,
+				EXTCON_EARCRX_ATNDTYP_ARC, state);
+			extcon_set_state_sync(p_earc->rx_edev,
+				EXTCON_EARCRX_ATNDTYP_EARC, false);
+		}
+	} else {
+		extcon_set_state_sync(p_earc->rx_edev,
+			EXTCON_EARCRX_ATNDTYP_ARC, state);
+		extcon_set_state_sync(p_earc->rx_edev,
+			EXTCON_EARCRX_ATNDTYP_EARC, state);
+	}
 }
 
-static irqreturn_t earc_rx_dmac_isr(int irq, void *devid)
+static irqreturn_t earc_rx_isr(int irq, void *data)
 {
+	struct earc *p_earc = (struct earc *)data;
+	unsigned int status0 = earcrx_cdmc_get_irqs(p_earc->rx_top_map);
+
+	if (status0)
+		earcrx_cdmc_clr_irqs(p_earc->rx_top_map, status0);
+
+	if (status0 & INT_EARCRX_CMDC_TIMEOUT) {
+		earcrx_update_attend_event(p_earc,
+					   false, false);
+
+		pr_debug("%s EARCRX_CMDC_TIMEOUT\n", __func__);
+	}
+
+	if (status0 & INT_EARCRX_CMDC_IDLE2) {
+		earcrx_update_attend_event(p_earc,
+					   false, true);
+
+		pr_info("%s EARCRX_CMDC_IDLE2\n", __func__);
+	}
+	if (status0 & INT_EARCRX_CMDC_IDLE1) {
+		earcrx_update_attend_event(p_earc,
+					   false, false);
+
+		pr_info("%s EARCRX_CMDC_IDLE1\n", __func__);
+	}
+	if (status0 & INT_EARCRX_CMDC_DISC2)
+		pr_debug("%s EARCRX_CMDC_DISC2\n", __func__);
+	if (status0 & INT_EARCRX_CMDC_DISC1)
+		pr_debug("%s EARCRX_CMDC_DISC1\n", __func__);
+	if (status0 & INT_EARCRX_CMDC_EARC) {
+		earcrx_update_attend_event(p_earc,
+					   true, true);
+
+		pr_info("%s EARCRX_CMDC_EARC\n", __func__);
+	}
+	/*
+	 * if (status0 & INT_EARCRX_CMDC_HB_STATUS)
+	 *	pr_debug("%s EARCRX_CMDC_HB_STATUS\n", __func__);
+	 */
+	if (status0 & INT_EARCRX_CMDC_LOSTHB)
+		pr_debug("%s EARCRX_CMDC_LOSTHB\n", __func__);
+
+	if (p_earc->rx_dmac_clk_on) {
+		unsigned int status1 = earcrx_dmac_get_irqs(p_earc->rx_top_map);
+
+		if (status1)
+			earcrx_dmac_clr_irqs(p_earc->rx_top_map, status1);
+
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_C_FIND_PAPB)
+			pr_debug("%s ARCRX_C_FIND_PAPB\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_C_VALID_CHANGE)
+			pr_debug("%s ARCRX_C_VALID_CHANGE\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_C_FIND_NONPCM2PCM)
+			pr_debug("%s ARCRX_C_FIND_NONPCM2PCM\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_C_PCPD_CHANGE)
+			pr_debug("%s ARCRX_C_PCPD_CHANGE\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_C_CH_STATUS_CHANGE)
+			pr_debug("%s ARCRX_C_CH_STATUS_CHANGE\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_I_SAMPLE_MODE_CHANGE)
+			pr_debug("%s ARCRX_I_SAMPLE_MODE_CHANGE\n", __func__);
+		if (status1 & INT_ARCRX_BIPHASE_DECODE_R_PARITY_ERR)
+			pr_debug("%s ARCRX_R_PARITY_ERR\n", __func__);
+	}
+
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t earc_tx_cmdc_isr(int irq, void *devid)
+static void earctx_update_attend_event(struct earc *p_earc,
+				       bool is_earc, bool state)
 {
-	return IRQ_HANDLED;
+	if (state) {
+		if (is_earc) {
+			extcon_set_state_sync(p_earc->tx_edev,
+					      EXTCON_EARCTX_ATNDTYP_ARC,
+					      false);
+			extcon_set_state_sync(p_earc->tx_edev,
+					      EXTCON_EARCTX_ATNDTYP_EARC,
+					      state);
+		} else {
+			extcon_set_state_sync(p_earc->tx_edev,
+					      EXTCON_EARCTX_ATNDTYP_ARC,
+					      state);
+			extcon_set_state_sync(p_earc->tx_edev,
+					      EXTCON_EARCTX_ATNDTYP_EARC,
+					      false);
+		}
+	} else {
+		extcon_set_state_sync(p_earc->tx_edev,
+				      EXTCON_EARCTX_ATNDTYP_ARC,
+				      state);
+		extcon_set_state_sync(p_earc->tx_edev,
+				      EXTCON_EARCTX_ATNDTYP_EARC,
+				      state);
+	}
 }
 
-static irqreturn_t earc_tx_dmac_isr(int irq, void *devid)
+static irqreturn_t earc_tx_isr(int irq, void *data)
 {
+	struct earc *p_earc = (struct earc *)data;
+	unsigned int status0 = earctx_cdmc_get_irqs(p_earc->tx_top_map);
+
+	if (status0)
+		earctx_cdmc_clr_irqs(p_earc->tx_top_map, status0);
+
+	if (status0 & INT_EARCTX_CMDC_IDLE2) {
+		earctx_update_attend_event(p_earc,
+					   false, true);
+
+		pr_debug("%s EARCTX_CMDC_IDLE2\n", __func__);
+	}
+	if (status0 & INT_EARCTX_CMDC_IDLE1) {
+		earctx_update_attend_event(p_earc,
+					   false, false);
+
+		pr_debug("%s EARCTX_CMDC_IDLE1\n", __func__);
+	}
+	if (status0 & INT_EARCTX_CMDC_DISC2)
+		pr_debug("%s EARCTX_CMDC_DISC2\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_DISC1)
+		pr_debug("%s EARCTX_CMDC_DISC1\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_EARC) {
+		earctx_update_attend_event(p_earc,
+					   true, true);
+
+		pr_info("%s EARCTX_CMDC_EARC\n", __func__);
+	}
+	if (status0 & INT_EARCTX_CMDC_HB_STATUS)
+		pr_debug("%s EARCTX_CMDC_HB_STATUS\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_LOSTHB)
+		pr_debug("%s EARCTX_CMDC_LOSTHB\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_TIMEOUT) {
+		earctx_update_attend_event(p_earc,
+					   false, false);
+
+		pr_debug("%s EARCTX_CMDC_TIMEOUT\n", __func__);
+	}
+	if (status0 & INT_EARCTX_CMDC_STATUS_CH)
+		pr_debug("%s EARCTX_CMDC_STATUS_CH\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_RECV_NACK)
+		pr_debug("%s EARCTX_CMDC_RECV_NACK\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_RECV_NORSP)
+		pr_debug("%s EARCTX_CMDC_RECV_NORSP\n", __func__);
+	if (status0 & INT_EARCTX_CMDC_RECV_UNEXP)
+		pr_debug("%s EARCTX_CMDC_RECV_UNEXP\n", __func__);
+
+	if (p_earc->tx_dmac_clk_on) {
+		unsigned int status1 = earctx_dmac_get_irqs(p_earc->tx_top_map);
+
+		if (status1)
+			earctx_dmac_clr_irqs(p_earc->tx_top_map, status1);
+
+		if (status1 & INT_EARCTX_FEM_C_HOLD_CLR)
+			pr_debug("%s EARCTX_FEM_C_HOLD_CLR\n", __func__);
+		if (status1 & INT_EARCTX_FEM_C_HOLD_START)
+			pr_debug("%s EARCTX_FEM_C_HOLD_START\n", __func__);
+		if (status1 & INT_EARCTX_ERRCORR_C_FIFO_THD_LESS_PASS)
+			pr_debug("%s EARCTX_ERRCORR_C_FIFO_THD_LESS_PASS\n",
+				 __func__);
+		if (status1 & INT_EARCTX_ERRCORR_C_FIFO_OVERFLOW)
+			pr_debug("%s EARCTX_ERRCORR_C_FIFO_OVERFLOW\n",
+				 __func__);
+		if (status1 & INT_EARCTX_ERRCORR_C_FIFO_EMPTY)
+			pr_debug("%s EARCTX_ERRCORR_C_FIFO_EMPTY\n", __func__);
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -133,9 +322,8 @@ static int earc_open(struct snd_pcm_substream *substream)
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct device *dev = rtd->platform->dev;
 	struct earc *p_earc;
-	int ret = 0;
 
-	pr_info("asoc debug: %s-%d\n", __func__, __LINE__);
+	pr_info("asoc debug: %s\n", __func__);
 
 	p_earc = (struct earc *)dev_get_drvdata(dev);
 
@@ -149,26 +337,6 @@ static int earc_open(struct snd_pcm_substream *substream)
 			dev_err(dev, "failed to claim from ddr\n");
 			return -ENXIO;
 		}
-		if (p_earc->irq_tx_cmdc > 0) {
-			ret = request_irq(p_earc->irq_tx_cmdc,
-					earc_tx_cmdc_isr, 0, "tx_cmdc",
-					p_earc);
-			if (ret) {
-				dev_err(p_earc->dev, "failed to claim irq_tx_cmdc %u\n",
-							p_earc->irq_tx_cmdc);
-				return ret;
-			}
-		}
-		if (p_earc->irq_tx_dmac > 0) {
-			ret = request_irq(p_earc->irq_tx_dmac,
-					earc_tx_dmac_isr, 0, "tx_dmac",
-					p_earc);
-			if (ret) {
-				dev_err(p_earc->dev, "failed to claim irq_tx_dmac %u\n",
-							p_earc->irq_tx_dmac);
-				return ret;
-			}
-		}
 	} else {
 		p_earc->tddr = aml_audio_register_toddr(dev,
 			p_earc->actrl,
@@ -177,23 +345,6 @@ static int earc_open(struct snd_pcm_substream *substream)
 			dev_err(dev, "failed to claim to ddr\n");
 			return -ENXIO;
 		}
-
-		ret = request_irq(p_earc->irq_rx_cmdc,
-				earc_rx_cmdc_isr, 0, "rx_cmdc",
-				p_earc);
-		if (ret) {
-			dev_err(p_earc->dev, "failed to claim irq_rx_cmdc %u\n",
-						p_earc->irq_rx_cmdc);
-			return ret;
-		}
-		ret = request_irq(p_earc->irq_rx_dmac,
-				earc_rx_dmac_isr, 0, "rx_dmac",
-				p_earc);
-		if (ret) {
-			dev_err(p_earc->dev, "failed to claim rx_dmac %u\n",
-						p_earc->irq_rx_dmac);
-			return ret;
-		}
 	}
 
 	runtime->private_data = p_earc;
@@ -206,21 +357,13 @@ static int earc_close(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct earc *p_earc = runtime->private_data;
 
-	pr_info("asoc debug: %s-%d\n", __func__, __LINE__);
+	pr_info("asoc debug: %s\n", __func__);
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		aml_audio_unregister_frddr(p_earc->dev, substream);
-
-		if (p_earc->irq_tx_cmdc > 0)
-			free_irq(p_earc->irq_tx_cmdc, p_earc);
-
-		if (p_earc->irq_tx_dmac > 0)
-			free_irq(p_earc->irq_tx_dmac, p_earc);
-	} else {
+	else
 		aml_audio_unregister_toddr(p_earc->dev, substream);
-		free_irq(p_earc->irq_rx_cmdc, p_earc);
-		free_irq(p_earc->irq_rx_dmac, p_earc);
-	}
+
 	runtime->private_data = NULL;
 
 	return 0;
@@ -339,7 +482,7 @@ struct snd_soc_platform_driver earc_platform = {
 
 static int earc_dai_probe(struct snd_soc_dai *cpu_dai)
 {
-	pr_info("asoc debug: %s-%d\n", __func__, __LINE__);
+	pr_info("asoc debug: %s\n", __func__);
 
 	return 0;
 }
@@ -359,19 +502,66 @@ static int earc_dai_prepare(
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		struct frddr *fr = p_earc->fddr;
-		enum frddr_dest dst = frddr_src_get();
+		enum frddr_dest dst = EARCTX_DMAC;
+		unsigned int fifo_id, frddr_type = 0;
+		struct iec958_chsts chsts;
 
 		pr_info("%s Expected frddr dst:%s\n",
 			__func__,
 			frddr_src_get_str(dst));
 
+		switch (bit_depth) {
+		case 8:
+			frddr_type = 0;
+			break;
+		case 16:
+			frddr_type = 1;
+			break;
+		case 24:
+			frddr_type = 4;
+			break;
+		case 32:
+			frddr_type = 3;
+			break;
+		default:
+			pr_err("runtime format invalid bitwidth: %d\n",
+			       bit_depth);
+			break;
+		}
+		fifo_id = aml_frddr_get_fifo_id(fr);
+
+		pr_info("%s, frddr_index:%d, bit_depth:%d, frddr_type:%d\n",
+			__func__,
+			fr->fifo_id, bit_depth, frddr_type);
+
+		aml_frddr_set_format(fr,
+				     runtime->channels,
+				     bit_depth - 1,
+				     frddr_type);
 		aml_frddr_select_dst(fr, dst);
 		aml_frddr_set_fifos(fr, 0x40, 0x20);
+
+		earctx_dmac_init(p_earc->tx_top_map, p_earc->tx_dmac_map);
+		earctx_dmac_set_format(p_earc->tx_dmac_map,
+				       fr->fifo_id,
+				       bit_depth - 1,
+				       frddr_type);
+
+		/* check and set channel status info */
+		spdif_get_channel_status_info(&chsts, runtime->rate);
+		earctx_set_channel_status_info(p_earc->tx_dmac_map, &chsts);
 	} else {
 		struct toddr *to = p_earc->tddr;
 		unsigned int msb = 0, lsb = 0, toddr_type = 0;
 		unsigned int src = EARCRX_DMAC;
 		struct toddr_fmt fmt;
+		enum attend_type type =
+			earcrx_cmdc_get_attended_type(p_earc->rx_cmdc_map);
+
+		if (type == ATNDTYP_DISCNCT) {
+			dev_err(p_earc->dev, "Neither eARC or ARC is attended!\n");
+			return -ENOTCONN;
+		}
 
 		if (bit_depth == 32)
 			toddr_type = 3;
@@ -380,18 +570,15 @@ static int earc_dai_prepare(
 		else
 			toddr_type = 0;
 
-		pr_info("%s Expected toddr src:%s\n",
-			__func__,
-			toddr_src_get_str(src));
-
 		msb = 28 - 1;
 		if (bit_depth == 16)
 			lsb = 28 - bit_depth;
 		else
 			lsb = 4;
 
-		pr_info("%s m:%d, n:%d, toddr type:%d\n",
-			__func__, msb, lsb, toddr_type);
+		pr_debug("%s Expected toddr src:%s, m:%d, n:%d, toddr type:%d\n",
+			__func__, toddr_src_get_str(src),
+			msb, lsb, toddr_type);
 
 		fmt.type      = toddr_type;
 		fmt.msb       = msb;
@@ -405,10 +592,8 @@ static int earc_dai_prepare(
 		aml_toddr_set_format(to, &fmt);
 		aml_toddr_set_fifos(to, 0x40);
 
-		earcrx_cmdc_init();
-		earcrx_dmac_init();
-		earc_arc_init();
-
+		earcrx_dmac_init(p_earc->rx_top_map, p_earc->rx_dmac_map);
+		earcrx_arc_init(p_earc->rx_dmac_map);
 	}
 
 	return 0;
@@ -427,12 +612,17 @@ static int earc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 			dev_info(substream->pcm->card->dev, "eARC/ARC TX enable\n");
 
 			aml_frddr_enable(p_earc->fddr, true);
+			earctx_enable(p_earc->tx_top_map,
+				      p_earc->tx_cmdc_map,
+				      p_earc->tx_dmac_map,
+				      true);
 		} else {
 			dev_info(substream->pcm->card->dev, "eARC/ARC RX enable\n");
 
 			aml_toddr_enable(p_earc->tddr, true);
-
-			earc_rx_enable(true);
+			earcrx_enable(p_earc->rx_cmdc_map,
+				      p_earc->rx_dmac_map,
+				      true);
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -441,12 +631,17 @@ static int earc_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 			dev_info(substream->pcm->card->dev, "eARC/ARC TX disable\n");
 
+			earctx_enable(p_earc->tx_top_map,
+				      p_earc->tx_cmdc_map,
+				      p_earc->tx_dmac_map,
+				      false);
 			aml_frddr_enable(p_earc->fddr, false);
 		} else {
 			dev_info(substream->pcm->card->dev, "eARC/ARC RX disable\n");
 
-			earc_rx_enable(false);
-
+			earcrx_enable(p_earc->rx_cmdc_map,
+				      p_earc->rx_dmac_map,
+				      false);
 			aml_toddr_enable(p_earc->tddr, false);
 		}
 		break;
@@ -466,10 +661,24 @@ static int earc_dai_hw_params(
 	unsigned int rate = params_rate(params);
 	int ret = 0;
 
-	pr_info("%s:rate:%d, sysclk:%d\n",
-		__func__,
-		rate,
-		p_earc->sysclk_freq);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		int freq = rate * 128 * 5;
+
+		if (spdif_is_4x_clk()) {
+			pr_debug("set 4x audio clk for 958\n");
+			freq *= 4;
+		} else {
+			pr_debug("set normal 512 fs /4 fs\n");
+		}
+
+		clk_set_rate(p_earc->clk_tx_dmac_srcpll, freq * 4);
+		clk_set_rate(p_earc->clk_tx_dmac, freq);
+
+		pr_info("%s, tx dmac clk, set freq: %d, get freq:%lu\n",
+			__func__,
+			freq,
+			clk_get_rate(p_earc->clk_tx_dmac));
+	}
 
 	return ret;
 }
@@ -488,16 +697,16 @@ static int earc_dai_set_sysclk(struct snd_soc_dai *cpu_dai,
 {
 	struct earc *p_earc = snd_soc_dai_get_drvdata(cpu_dai);
 
-	p_earc->sysclk_freq = freq;
-	pr_info("earc_dai_set_sysclk, %d, %d, %d\n",
-			clk_id, freq, dir);
+	pr_info("%s, %d, %d, %d\n",
+		__func__, clk_id, freq, dir);
 
-	clk_set_rate(p_earc->clk_rx_cmdc, 10000000);
-	clk_set_rate(p_earc->clk_rx_dmac, 250000000);
+	if (clk_id == 1) {
+		clk_set_rate(p_earc->clk_rx_dmac, 500000000);
 
-	pr_info("earc rx cmdc clk:%lu rx dmac clk:%lu\n",
-		clk_get_rate(p_earc->clk_rx_cmdc),
-		clk_get_rate(p_earc->clk_rx_dmac));
+		pr_info("earc rx cmdc clk:%lu rx dmac clk:%lu\n",
+			clk_get_rate(p_earc->clk_rx_cmdc),
+			clk_get_rate(p_earc->clk_rx_dmac));
+	}
 
 	return 0;
 }
@@ -509,45 +718,53 @@ static int earc_dai_startup(
 	struct earc *p_earc = snd_soc_dai_get_drvdata(cpu_dai);
 	int ret;
 
-	/* enable clock gate */
-	if (!IS_ERR(p_earc->clk_rx_gate)) {
-		ret = clk_prepare_enable(p_earc->clk_rx_gate);
-		if (ret) {
-			pr_err("Can't enable earc rx_gate: %d\n", ret);
-			goto err;
-		}
-	}
-
-	audiobus_update_bits(EE_AUDIO_CLK_GATE_EN1, 0x1 << 6, 0x1 << 6);
+	pr_info("%s\n", __func__);
 
-	/* enable clock */
-	if (!IS_ERR(p_earc->clk_rx_cmdc)) {
-		ret = clk_prepare_enable(p_earc->clk_rx_cmdc);
-		if (ret) {
-			pr_err("Can't enable earc clk_rx_cmdc: %d\n", ret);
-			goto err;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* tx dmac clk */
+		if (!IS_ERR(p_earc->clk_tx_dmac)) {
+			ret = clk_prepare_enable(p_earc->clk_tx_dmac);
+			if (ret) {
+				dev_err(p_earc->dev,
+					"Can't enable earc clk_tx_dmac: %d\n",
+					ret);
+				goto err;
+			}
+			p_earc->tx_dmac_clk_on = true;
 		}
-	}
-	if (!IS_ERR(p_earc->clk_rx_dmac)) {
-		ret = clk_prepare_enable(p_earc->clk_rx_dmac);
-		if (ret) {
-			pr_err("Can't enable earc clk_rx_dmac: %d\n", ret);
-			goto err;
+		if (!IS_ERR(p_earc->clk_tx_dmac_srcpll)) {
+			ret = clk_prepare_enable(p_earc->clk_tx_dmac_srcpll);
+			if (ret) {
+				dev_err(p_earc->dev,
+					"Can't enable earc clk_tx_dmac_srcpll:%d\n",
+					ret);
+				goto err;
+			}
 		}
-	}
-	if (!IS_ERR(p_earc->clk_tx_cmdc)) {
-		ret = clk_prepare_enable(p_earc->clk_tx_cmdc);
-		if (ret) {
-			pr_err("Can't enable earc clk_tx_cmdc: %d\n", ret);
-			goto err;
+	} else {
+		/* rx dmac clk */
+		if (!IS_ERR(p_earc->clk_rx_dmac)) {
+			ret = clk_prepare_enable(p_earc->clk_rx_dmac);
+			if (ret) {
+				dev_err(p_earc->dev,
+					"Can't enable earc clk_rx_dmac: %d\n",
+					ret);
+				goto err;
+			}
+			p_earc->rx_dmac_clk_on = true;
 		}
-	}
-	if (!IS_ERR(p_earc->clk_tx_dmac)) {
-		ret = clk_prepare_enable(p_earc->clk_tx_dmac);
-		if (ret) {
-			pr_err("Can't enable earc clk_tx_dmac: %d\n", ret);
-			goto err;
+
+		if (!IS_ERR(p_earc->clk_rx_dmac_srcpll)) {
+			ret = clk_prepare_enable(p_earc->clk_rx_dmac_srcpll);
+			if (ret) {
+				dev_err(p_earc->dev,
+					"Can't enable earc clk_rx_dmac_srcpll: %d\n",
+					ret);
+				goto err;
+			}
 		}
+
+		earcrx_pll_refresh(p_earc->rx_top_map);
 	}
 
 	return 0;
@@ -563,19 +780,23 @@ static void earc_dai_shutdown(
 {
 	struct earc *p_earc = snd_soc_dai_get_drvdata(cpu_dai);
 
-	/* disable clock and gate */
-	if (!IS_ERR(p_earc->clk_rx_cmdc))
-		clk_disable_unprepare(p_earc->clk_rx_cmdc);
-	if (!IS_ERR(p_earc->clk_rx_dmac))
-		clk_disable_unprepare(p_earc->clk_rx_dmac);
-	if (!IS_ERR(p_earc->clk_tx_cmdc))
-		clk_disable_unprepare(p_earc->clk_tx_cmdc);
-	if (!IS_ERR(p_earc->clk_tx_dmac))
-		clk_disable_unprepare(p_earc->clk_tx_dmac);
-	if (!IS_ERR(p_earc->clk_rx_gate))
-		clk_disable_unprepare(p_earc->clk_rx_gate);
+	pr_info("%s\n", __func__);
 
-	audiobus_update_bits(EE_AUDIO_CLK_GATE_EN1, 0x1 << 6, 0x0 << 6);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (!IS_ERR(p_earc->clk_tx_dmac)) {
+			clk_disable_unprepare(p_earc->clk_tx_dmac);
+			p_earc->tx_dmac_clk_on = false;
+		}
+		if (!IS_ERR(p_earc->clk_tx_dmac_srcpll))
+			clk_disable_unprepare(p_earc->clk_tx_dmac_srcpll);
+	} else {
+		if (!IS_ERR(p_earc->clk_rx_dmac)) {
+			clk_disable_unprepare(p_earc->clk_rx_dmac);
+			p_earc->rx_dmac_clk_on = false;
+		}
+		if (!IS_ERR(p_earc->clk_rx_dmac_srcpll))
+			clk_disable_unprepare(p_earc->clk_rx_dmac_srcpll);
+	}
 }
 
 static struct snd_soc_dai_ops earc_dai_ops = {
@@ -610,9 +831,312 @@ static struct snd_soc_dai_driver earc_dai[] = {
 	},
 };
 
-static const struct snd_kcontrol_new earc_controls[] = {
 
+static const char *const attended_type[] = {
+	"DISCONNECT",
+	"ARC",
+	"eARC"
+};
+
+const struct soc_enum attended_type_enum =
+	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(attended_type),
+			attended_type);
+
+int earcrx_get_attend_type(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum attend_type type =
+		earcrx_cmdc_get_attended_type(p_earc->rx_cmdc_map);
+
+	ucontrol->value.integer.value[0] = type;
+
+	return 0;
+}
+
+int earcrx_set_attend_type(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum cmdc_st state = earcrx_cmdc_get_state(p_earc->rx_cmdc_map);
+
+	if (state != CMDC_ST_IDLE2)
+		return 0;
+
+	/* only support set cmdc from idle to ARC */
+
+	return 0;
+}
+
+static int earcrx_arc_get_enable(
+				 struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum attend_type type =
+		earcrx_cmdc_get_attended_type(p_earc->rx_cmdc_map);
+
+	ucontrol->value.integer.value[0] = (bool)(type == ATNDTYP_ARC);
+
+	return 0;
+}
+
+static int earcrx_arc_set_enable(
+				 struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+
+	if (!p_earc)
+		return 0;
+
+	earcrx_cmdc_arc_connect(
+		p_earc->rx_cmdc_map,
+		(bool)ucontrol->value.integer.value[0]);
+
+	return 0;
+}
+
+int earctx_get_attend_type(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum attend_type type;
+
+	if (!p_earc || IS_ERR(p_earc->tx_top_map))
+		return 0;
+
+	type = earctx_cmdc_get_attended_type(p_earc->tx_cmdc_map);
+
+	ucontrol->value.integer.value[0] = type;
+
+	return 0;
+}
+
+int earctx_set_attend_type(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum cmdc_st state;
+
+	if (!p_earc || IS_ERR(p_earc->tx_top_map))
+		return 0;
+
+	state = earctx_cmdc_get_state(p_earc->tx_cmdc_map);
+
+	if (state != CMDC_ST_IDLE2)
+		return 0;
+
+	/* only support set cmdc from idle to ARC */
+
+	return 0;
+}
+
+int earcrx_get_latency(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum cmdc_st state;
+	u8  val = 0;
+
+	if (!p_earc || IS_ERR(p_earc->rx_top_map))
+		return 0;
+
+	state = earcrx_cmdc_get_state(p_earc->rx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earcrx_cmdc_get_latency(p_earc->rx_cmdc_map, &val);
+
+	ucontrol->value.integer.value[0] = val;
 
+	return 0;
+}
+
+int earcrx_set_latency(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	u8 latency = ucontrol->value.integer.value[0];
+	enum cmdc_st state;
+
+	if (!p_earc || IS_ERR(p_earc->rx_top_map))
+		return 0;
+
+	state = earcrx_cmdc_get_state(p_earc->rx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earcrx_cmdc_set_latency(p_earc->rx_cmdc_map, &latency);
+
+	return 0;
+}
+
+int earcrx_get_cds(struct snd_kcontrol *kcontrol,
+		   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	struct soc_bytes_ext *bytes_ext =
+		(struct soc_bytes_ext *)kcontrol->private_value;
+	u8 *value = (u8 *)ucontrol->value.bytes.data;
+	enum cmdc_st state;
+	int i;
+	u8 data[256];
+
+	if (!p_earc || IS_ERR(p_earc->rx_top_map))
+		return 0;
+
+	state = earcrx_cmdc_get_state(p_earc->rx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earcrx_cmdc_get_cds(p_earc->rx_cmdc_map, data);
+
+	for (i = 0; i < bytes_ext->max; i++)
+		*value++ = data[i];
+
+	return 0;
+}
+
+int earcrx_set_cds(struct snd_kcontrol *kcontrol,
+		   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+	u8 *data;
+	enum cmdc_st state;
+
+	if (!p_earc || IS_ERR(p_earc->rx_top_map))
+		return 0;
+
+	state = earcrx_cmdc_get_state(p_earc->rx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	data = kmemdup(ucontrol->value.bytes.data,
+		       params->max, GFP_KERNEL | GFP_DMA);
+	if (!data)
+		return -ENOMEM;
+
+	earcrx_cmdc_set_cds(p_earc->rx_cmdc_map, data);
+
+	kfree(data);
+
+	return 0;
+}
+
+int earctx_get_latency(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	enum cmdc_st state;
+	u8 val = 0;
+
+	if (!p_earc || IS_ERR(p_earc->tx_top_map))
+		return 0;
+
+	state = earctx_cmdc_get_state(p_earc->tx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earctx_cmdc_get_latency(p_earc->tx_cmdc_map, &val);
+
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+
+int earctx_set_latency(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	u8 latency = ucontrol->value.integer.value[0];
+	enum cmdc_st state;
+
+	if (!p_earc || IS_ERR(p_earc->tx_top_map))
+		return 0;
+
+	state = earctx_cmdc_get_state(p_earc->tx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earctx_cmdc_set_latency(p_earc->tx_cmdc_map, &latency);
+
+	return 0;
+}
+
+int earctx_get_cds(struct snd_kcontrol *kcontrol,
+		   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct earc *p_earc = dev_get_drvdata(component->dev);
+	struct soc_bytes_ext *bytes_ext =
+		(struct soc_bytes_ext *)kcontrol->private_value;
+	u8 *value = (u8 *)ucontrol->value.bytes.data;
+	enum cmdc_st state;
+	u8 data[256];
+	int i;
+
+	if (!p_earc || IS_ERR(p_earc->tx_top_map))
+		return 0;
+
+	state = earctx_cmdc_get_state(p_earc->tx_cmdc_map);
+	if (state != CMDC_ST_EARC)
+		return 0;
+
+	earctx_cmdc_get_cds(p_earc->tx_cmdc_map, data);
+
+	for (i = 0; i < bytes_ext->max; i++)
+		*value++ = data[i];
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new earc_controls[] = {
+	SOC_SINGLE_BOOL_EXT("HDMI ARC Switch",
+			    0,
+			    earcrx_arc_get_enable,
+			    earcrx_arc_set_enable),
+
+	SOC_ENUM_EXT("eARC_RX attended type",
+		     attended_type_enum,
+		     earcrx_get_attend_type,
+		     earcrx_set_attend_type),
+
+	SOC_ENUM_EXT("eARC_TX attended type",
+		     attended_type_enum,
+		     earctx_get_attend_type,
+		     earctx_set_attend_type),
+
+	SND_INT("eARC_RX Latency",
+		earcrx_get_latency,
+		earcrx_set_latency),
+
+	SND_INT("eARC_TX Latency",
+		earctx_get_latency,
+		earctx_set_latency),
+
+	SND_SOC_BYTES_EXT("eARC_RX CDS",
+			  CDS_MAX_BYTES,
+			  earcrx_get_cds,
+			  earcrx_set_cds),
+
+	SND_SOC_BYTES_EXT("eARC_TX CDS",
+			  CDS_MAX_BYTES,
+			  earctx_get_cds,
+			  NULL),
 };
 
 static const struct snd_soc_component_driver earc_component = {
@@ -633,6 +1157,180 @@ static const struct of_device_id earc_device_id[] = {
 
 MODULE_DEVICE_TABLE(of, earc_device_id);
 
+static const unsigned int earcrx_extcon[] = {
+	EXTCON_EARCRX_ATNDTYP_ARC,
+	EXTCON_EARCRX_ATNDTYP_EARC,
+	EXTCON_NONE,
+};
+
+static int earcrx_extcon_register(struct earc *p_earc)
+{
+	int ret = 0;
+
+	/* earc or arc connect */
+	p_earc->rx_edev = devm_extcon_dev_allocate(p_earc->dev, earcrx_extcon);
+	if (IS_ERR(p_earc->rx_edev)) {
+		pr_err("failed to allocate earc extcon!!!\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+	p_earc->rx_edev->dev.parent  = p_earc->dev;
+	p_earc->rx_edev->name = "earcrx";
+
+	dev_set_name(&p_earc->rx_edev->dev, "earcrx");
+	ret = extcon_dev_register(p_earc->rx_edev);
+	if (ret < 0) {
+		pr_err("earc extcon failed to register!!\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+void earc_hdmitx_hpdst(bool st)
+{
+	struct earc *p_earc = s_earc;
+
+	if (!p_earc)
+		return;
+
+	pr_info("%s, %s\n",
+		__func__,
+		st ? "plugin" : "plugout");
+
+	/* ensure clock gate */
+	audiobus_update_bits(EE_AUDIO_CLK_GATE_EN1, 0x1 << 6, 0x1 << 6);
+
+	earcrx_cmdc_arc_connect(p_earc->rx_cmdc_map, st);
+
+	earcrx_cmdc_hpd_detect(p_earc->rx_cmdc_map, st);
+}
+
+static int earcrx_cmdc_setup(struct earc *p_earc)
+{
+	int ret = 0;
+
+	/* set cmdc clk */
+	audiobus_update_bits(EE_AUDIO_CLK_GATE_EN1, 0x1 << 6, 0x1 << 6);
+	if (!IS_ERR(p_earc->clk_rx_cmdc)) {
+		clk_set_rate(p_earc->clk_rx_cmdc, 10000000);
+
+		ret = clk_prepare_enable(p_earc->clk_rx_cmdc);
+		if (ret) {
+			pr_err("Can't enable earc clk_rx_cmdc: %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* rx cmdc init */
+	earcrx_cmdc_init(p_earc->rx_top_map);
+	/* Default: arc arc_initiated */
+	earcrx_cmdc_arc_connect(p_earc->rx_cmdc_map, true);
+
+	ret = devm_request_threaded_irq(p_earc->dev,
+					p_earc->irq_earc_rx,
+					NULL,
+					earc_rx_isr,
+					IRQF_TRIGGER_HIGH |
+					IRQF_ONESHOT,
+					"earc_rx",
+					p_earc);
+	if (ret) {
+		dev_err(p_earc->dev, "failed to claim earc_rx %u\n",
+			p_earc->irq_earc_rx);
+		return ret;
+	}
+
+	return ret;
+}
+
+static const unsigned int earctx_extcon[] = {
+	EXTCON_EARCTX_ATNDTYP_ARC,
+	EXTCON_EARCTX_ATNDTYP_EARC,
+	EXTCON_NONE,
+};
+
+static int earctx_extcon_register(struct earc *p_earc)
+{
+	int ret = 0;
+
+	/* earc or arc connect */
+	p_earc->tx_edev = devm_extcon_dev_allocate(p_earc->dev, earctx_extcon);
+	if (IS_ERR(p_earc->tx_edev)) {
+		pr_err("failed to allocate earc extcon!!!\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+	p_earc->tx_edev->dev.parent  = p_earc->dev;
+	p_earc->tx_edev->name = "earctx";
+
+	dev_set_name(&p_earc->tx_edev->dev, "earctx");
+	ret = extcon_dev_register(p_earc->tx_edev);
+	if (ret < 0) {
+		pr_err("earc extcon failed to register!!\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+void earc_hdmirx_hpdst(int earc_port, bool st)
+{
+	struct earc *p_earc = s_earc;
+
+	if (!p_earc)
+		return;
+
+	pr_info("%s, earc_port:%d  %s\n",
+		__func__,
+		earc_port,
+		st ? "plugin" : "plugout");
+
+	earctx_cmdc_int_mask(p_earc->tx_top_map);
+	earctx_cmdc_arc_connect(p_earc->tx_cmdc_map, st);
+	earctx_cmdc_hpd_detect(p_earc->tx_top_map,
+			       p_earc->tx_cmdc_map,
+			       earc_port, st);
+}
+
+static int earctx_cmdc_setup(struct earc *p_earc)
+{
+	int ret = 0;
+
+	/* set cmdc clk */
+	audiobus_update_bits(EE_AUDIO_CLK_GATE_EN1, 0x1 << 5, 0x1 << 5);
+	if (!IS_ERR(p_earc->clk_tx_cmdc)) {
+		clk_set_rate(p_earc->clk_tx_cmdc, 10000000);
+
+		ret = clk_prepare_enable(p_earc->clk_tx_cmdc);
+		if (ret) {
+			pr_err("Can't enable earc clk_tx_cmdc: %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = devm_request_threaded_irq(p_earc->dev,
+					p_earc->irq_earc_tx,
+					NULL,
+					earc_tx_isr,
+					IRQF_TRIGGER_HIGH |
+					IRQF_ONESHOT,
+					"earc_tx",
+					p_earc);
+	if (ret) {
+		dev_err(p_earc->dev, "failed to claim earc_tx %u\n",
+			p_earc->irq_earc_tx);
+		return ret;
+	}
+
+	/* tx cmdc init */
+	earctx_cmdc_init(p_earc->tx_top_map);
+	/* Default: arc arc_initiated */
+	earctx_cmdc_arc_connect(p_earc->tx_cmdc_map, true);
+
+	return ret;
+}
+
 static int earc_platform_probe(struct platform_device *pdev)
 {
 	struct device_node *node = pdev->dev.of_node;
@@ -643,6 +1341,7 @@ static int earc_platform_probe(struct platform_device *pdev)
 	struct earc *p_earc = NULL;
 	int ret = 0;
 
+	pr_info("%s\n", __func__);
 
 	p_earc = devm_kzalloc(dev, sizeof(struct earc), GFP_KERNEL);
 	if (!p_earc)
@@ -662,6 +1361,38 @@ static int earc_platform_probe(struct platform_device *pdev)
 			platform_get_drvdata(pdev_parent);
 	p_earc->actrl = actrl;
 
+	p_earc->tx_cmdc_map = regmap_resource(dev, "tx_cmdc");
+	if (!p_earc->tx_cmdc_map) {
+		dev_err(dev,
+			"Can't get earctx_cmdc regmap!!\n");
+	}
+	p_earc->tx_dmac_map = regmap_resource(dev, "tx_dmac");
+	if (!p_earc->tx_dmac_map) {
+		dev_err(dev,
+			"Can't get earctx_dmac regmap!!\n");
+	}
+	p_earc->tx_top_map = regmap_resource(dev, "tx_top");
+	if (!p_earc->tx_top_map) {
+		dev_err(dev,
+			"Can't get earctx_top regmap!!\n");
+	}
+
+	p_earc->rx_cmdc_map = regmap_resource(dev, "rx_cmdc");
+	if (!p_earc->rx_cmdc_map) {
+		dev_err(dev,
+			"Can't get earcrx_cdmc regmap!!\n");
+	}
+	p_earc->rx_dmac_map = regmap_resource(dev, "rx_dmac");
+	if (!p_earc->rx_dmac_map) {
+		dev_err(dev,
+			"Can't get earcrx_dmac regmap!!\n");
+	}
+	p_earc->rx_top_map = regmap_resource(dev, "rx_top");
+	if (!p_earc->rx_top_map) {
+		dev_err(dev,
+			"Can't get earcrx_top regmap!!\n");
+	}
+
 	/* clock gate */
 	p_earc->clk_rx_gate = devm_clk_get(&pdev->dev, "rx_gate");
 	if (IS_ERR(p_earc->clk_rx_gate)) {
@@ -754,26 +1485,19 @@ static int earc_platform_probe(struct platform_device *pdev)
 	}
 
 	/* irqs */
-	p_earc->irq_rx_cmdc =
-		platform_get_irq_byname(pdev, "rx_cmdc");
-	if (p_earc->irq_rx_cmdc < 0) {
-		dev_err(dev, "platform get irq rx_cmdc failed\n");
-		return p_earc->irq_rx_cmdc;
-	}
-	p_earc->irq_rx_dmac =
-		platform_get_irq_byname(pdev, "rx_dmac");
-	if (p_earc->irq_rx_dmac < 0) {
-		dev_err(dev, "platform get irq rx_dmac failed\n");
-		return p_earc->irq_rx_dmac;
-	}
-	p_earc->irq_tx_cmdc =
-		platform_get_irq_byname(pdev, "tx_cmdc");
-	if (p_earc->irq_tx_cmdc < 0)
-		dev_err(dev, "platform get irq tx_cmdc failed, Check whether support eARC TX\n");
-	p_earc->irq_tx_dmac =
-		platform_get_irq_byname(pdev, "tx_dmac");
-	if (p_earc->irq_tx_dmac < 0)
-		dev_err(dev, "platform get irq tx_dmac failed, Check whether support eARC TX\n");
+	p_earc->irq_earc_rx =
+		platform_get_irq_byname(pdev, "earc_rx");
+	if (p_earc->irq_earc_rx < 0) {
+		dev_err(dev, "platform get irq earc_rx failed, err: %d\n", p_earc->irq_earc_rx);
+		return p_earc->irq_earc_rx;
+	}
+	p_earc->irq_earc_tx =
+		platform_get_irq_byname(pdev, "earc_tx");
+	if (p_earc->irq_earc_tx < 0)
+		dev_err(dev, "platform get irq earc_tx failed, Check whether support eARC TX\n");
+
+	pr_info("%s, irq_earc_rx:%d, irq_earc_tx:%d\n",
+		__func__, p_earc->irq_earc_rx, p_earc->irq_earc_tx);
 
 	ret = snd_soc_register_component(&pdev->dev,
 				&earc_component,
@@ -785,6 +1509,20 @@ static int earc_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	s_earc = p_earc;
+
+	/* RX */
+	if (p_earc->irq_earc_rx > 0) {
+		earcrx_extcon_register(p_earc);
+		earcrx_cmdc_setup(p_earc);
+	}
+
+	/* TX */
+	if (p_earc->irq_earc_tx > 0) {
+		earctx_extcon_register(p_earc);
+		earctx_cmdc_setup(p_earc);
+	}
+
 	pr_info("%s, register soc platform\n", __func__);
 
 	return devm_snd_soc_register_platform(dev, &earc_platform);
@@ -797,7 +1535,12 @@ struct platform_driver earc_driver = {
 	},
 	.probe = earc_platform_probe,
 };
-module_platform_driver(earc_driver);
+
+static int __init earc_init(void)
+{
+	return platform_driver_register(&earc_driver);
+}
+arch_initcall_sync(earc_init);
 
 MODULE_AUTHOR("Amlogic, Inc.");
 MODULE_DESCRIPTION("Amlogic eARC/ARC TX/RX ASoc driver");
diff --git a/sound/soc/amlogic/auge/earc_hw.c b/sound/soc/amlogic/auge/earc_hw.c
index 0b217bb2cad0..14694c1452b0 100644
--- a/sound/soc/amlogic/auge/earc_hw.c
+++ b/sound/soc/amlogic/auge/earc_hw.c
@@ -15,112 +15,847 @@
  *
  */
 #include <linux/types.h>
+#include <linux/kernel.h>
 
+#include <linux/amlogic/media/sound/spdif_info.h>
 #include "earc_hw.h"
 
+void earcrx_pll_refresh(struct regmap *top_map)
+{
+	/* pll tdc mode */
+	mmio_update_bits(top_map, EARCRX_PLL_CTRL3,
+			 0x1 << 15, 0x1 << 15);
+
+	/* pll self reset */
+	mmio_update_bits(top_map, EARCRX_PLL_CTRL0,
+			 0x1 << 29, 0x1 << 29);
+	mmio_update_bits(top_map, EARCRX_PLL_CTRL0,
+			 0x1 << 29, 0x0 << 29);
 
-void earcrx_cmdc_init(void)
+	mmio_update_bits(top_map, EARCRX_PLL_CTRL3,
+			 0x1 << 15, 0x0 << 15);
+}
+void earcrx_cmdc_init(struct regmap *top_map)
 {
 	/* set irq mask */
-	earcrx_top_write(EARCRX_CMDC_INT_MASK,
-		(0 << 15) |  /* idle2_int */
-		(0 << 14) |  /* idle1_int */
-		(0 << 13) |  /* disc2_int */
-		(0 << 12) |  /* disc1_int */
-		(0 << 11) |  /* earc_int */
-		(1 << 10) |  /* hb_status_int */
-		(0 <<  9) |  /* losthb_int */
-		(0 <<  8) |  /* timeout_int */
-		(0 <<  7) |  /* status_ch_int */
-		(0 <<  6) |  /* int_rec_invalid_id */
-		(0 <<  5) |  /* int_rec_invalid_offset */
-		(0 <<  4) |  /* int_rec_unexp */
-		(0 <<  3) |  /* int_rec_ecc_err */
-		(0 <<  2) |  /* int_rec_parity_err */
-		(0 <<  1) |  /* int_recv_packet */
-		(0 <<  0)	  /* int_rec_time_out */
-		);
-
-	earcrx_top_write(EARCRX_ANA_CTRL0, 0x90884814);
-	earcrx_top_write(EARCRX_PLL_CTRL3, 0x242000);
-	earcrx_top_write(EARCRX_PLL_CTRL0, 0x10800400);
-}
-
-void earcrx_dmac_init(void)
-{
-	earcrx_dmac_write(EARCRX_DMAC_SYNC_CTRL0,
-		(1 << 16)	|	 /* reg_ana_buf_data_sel_en */
-		(3 << 12)	|	 /* reg_ana_buf_data_sel */
-		(7 << 8)	|	 /* reg_ana_clr_cnt */
-		(7 << 4)		 /* reg_ana_set_cnt */
-		);
-	earcrx_dmac_write(EARCRX_DMAC_UBIT_CTRL0,
-		(47 << 16) | /* reg_fifo_thd */
-		(1 << 12)  | /* reg_user_lr */
-		(29 << 0)	/* reg_data_bit */
-		);
-	earcrx_dmac_write(EARCRX_ANA_RST_CTRL0, 1 << 31);
-}
-
-void earc_arc_init(void)
-{
-	earcrx_dmac_write(EARCRX_SPDIFIN_CTRL0,
-		(1 << 31) | /* reg_work_en */
-		(1 << 30) | /* reg_chnum_sel */
-		(1 << 25) | /* reg_findpapb_en */
-		(0xFFF<<12) /* reg_nonpcm2pcm_th */
-		);
-	earcrx_dmac_write(EARCRX_SPDIFIN_CTRL2,
-		(1 << 14) | /* reg_earc_auto */
-		(1 << 13)  /* reg_earcin_papb_lr */
-		);
-	earcrx_dmac_write(EARCRX_SPDIFIN_CTRL3,
-		(0xEC37<<16) | /* reg_earc_pa_value */
-		(0x5A5A<<0)    /* reg_earc_pb_value */
-		);
-}
-
-void earc_rx_enable(bool enable)
+	mmio_write(top_map, EARCRX_CMDC_INT_MASK,
+		   (1 << 15) |  /* idle2_int */
+		   (1 << 14) |  /* idle1_int */
+		   (1 << 13) |  /* disc2_int */
+		   (1 << 12) |  /* disc1_int */
+		   (1 << 11) |  /* earc_int */
+		   (1 << 10) |  /* hb_status_int */
+		   (1 <<  9) |  /* losthb_int */
+		   (1 <<  8) |  /* timeout_int */
+		   (0 <<  7) |  /* status_ch_int */
+		   (0 <<  6) |  /* int_rec_invalid_id */
+		   (0 <<  5) |  /* int_rec_invalid_offset */
+		   (0 <<  4) |  /* int_rec_unexp */
+		   (0 <<  3) |  /* int_rec_ecc_err */
+		   (0 <<  2) |  /* int_rec_parity_err */
+		   (0 <<  1) |  /* int_recv_packet */
+		   (0 <<  0)	 /* int_rec_time_out */
+		  );
+
+	mmio_write(top_map, EARCRX_ANA_CTRL0,
+		   0x1  << 31 | /* earcrx_en_d2a */
+		   0x10 << 24 | /* earcrx_cmdcrx_reftrim */
+		   0x8  << 20 | /* earcrx_idr_trim */
+		   0x10 << 15 | /* earcrx_rterm_trim */
+		   0x4  << 12 | /* earcrx_cmdctx_ack_hystrim */
+		   0x10 << 7  | /* earcrx_cmdctx_ack_reftrim */
+		   0x1  << 4  | /* earcrx_cmdcrx_rcfilter_sel */
+		   0x4  << 0    /* earcrx_cmdcrx_hystrim */
+		  );
+
+	mmio_write(top_map, EARCRX_PLL_CTRL3,
+		   0x2 << 20 | /* earcrx_pll_bias_adj */
+		   0x4 << 16 | /* earcrx_pll_rou */
+		   0x1 << 13   /* earcrx_pll_dco_sdm_e */
+		  );
+
+	mmio_write(top_map, EARCRX_PLL_CTRL0,
+		   0x1 << 28 | /* earcrx_pll_en */
+		   0x1 << 23 | /* earcrx_pll_dmacrx_sqout_rstn_sel */
+		   0x1 << 10   /* earcrx_pll_n */
+		  );
+}
+
+void earcrx_cmdc_arc_connect(struct regmap *cmdc_map, bool init)
+{
+	if (init)
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_VSM_CTRL0,
+				 0x7 << 25,
+				 0x1 << 27 | /* arc_initiated */
+				 0x0 << 26 | /* arc_terminated */
+				 0x1 << 25   /* arc_enable */
+				);
+	else
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_VSM_CTRL0,
+				 0x7 << 25,
+				 0x0 << 27 | /* arc_initiated */
+				 0x1 << 26 | /* arc_terminated */
+				 0x0 << 25   /* arc_enable */
+				);
+}
+
+void earcrx_cmdc_hpd_detect(struct regmap *cmdc_map, bool st)
+{
+	if (st) {
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_VSM_CTRL0,
+				 0x1 << 19,
+				 0x1 << 19	/* comma_cnt_rst */
+				);
+
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_VSM_CTRL0,
+				 0x1 << 19 | 0xff << 0,
+				 0x0 << 19 | /* comma_cnt_rst */
+				 0xa << 0
+				);
+	} else {
+		/* soft reset */
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_TOP_CTRL1,
+				 0xf << 0,
+				 0xf << 0);
+		mmio_update_bits(cmdc_map,
+				 EARC_RX_CMDC_TOP_CTRL1,
+				 0xf << 0,
+				 0x0 << 0);
+	}
+}
+
+void earcrx_dmac_init(struct regmap *top_map, struct regmap *dmac_map)
+{
+	mmio_write(top_map, EARCRX_DMAC_INT_MASK,
+		   (0x0 << 17) | /* earcrx_ana_rst c_new_format_set */
+		   (0x0 << 16) | /* earcrx_ana_rst c_earcrx_div2_hold_set */
+		   (0x0 << 15) | /* earcrx_err_correct c_bcherr_int_set */
+		   (0x0 << 14) | /* earcrx_err_correct r_afifo_overflow_set */
+		   (0x0 << 13) | /* earcrx_err_correct r_fifo_overflow_set */
+		   (0x0 << 12) | /* earcrx_user_bit_check r_fifo_overflow */
+		   (0x0 << 11) | /* earcrx_user_bit_check c_fifo_thd_pass */
+		   (0x0 << 10) | /* earcrx_user_bit_check c_u_pk_lost_int_set */
+		   (0x0 << 9)	| /* arcrx_user_bit_check c_iu_pk_end */
+		   (0x0 << 8)	| /* arcrx_biphase_decode c_chst_mute_clr */
+		   (0x1 << 7)	| /* arcrx_biphase_decode c_find_papb */
+		   (0x1 << 6)	| /* arcrx_biphase_decode c_valid_change */
+		   (0x1 << 5)	| /* arcrx_biphase_decode c_find_nonpcm2pcm */
+		   (0x1 << 4)	| /* arcrx_biphase_decode c_pcpd_change */
+		   (0x1 << 3)	| /* arcrx_biphase_decode c_ch_status_change */
+		   (0x1 << 2)	| /* arcrx_biphase_decode sample_mod_change */
+		   (0x1 << 1)	| /* arcrx_biphase_decode r_parity_err */
+		   (0x0 << 0)	  /* arcrx_dmac_sync afifo_overflow */
+		  );
+
+	mmio_write(dmac_map, EARCRX_DMAC_SYNC_CTRL0,
+		   (1 << 16)	|	 /* reg_ana_buf_data_sel_en */
+		   (3 << 12)	|	 /* reg_ana_buf_data_sel */
+		   (7 << 8)	|	 /* reg_ana_clr_cnt */
+		   (7 << 4)		 /* reg_ana_set_cnt */
+		  );
+	mmio_write(dmac_map, EARCRX_DMAC_UBIT_CTRL0,
+		   (47 << 16) | /* reg_fifo_thd */
+		   (1 << 12)  | /* reg_user_lr */
+		   (29 << 0)	/* reg_data_bit */
+		  );
+	mmio_write(dmac_map, EARCRX_ANA_RST_CTRL0, 1 << 31);
+}
+
+void earcrx_arc_init(struct regmap *dmac_map)
+{
+	unsigned int spdifin_clk = 500000000;
+
+	/* sysclk/rate/32(bit)/2(ch)/2(bmc) */
+	unsigned int counter_32k  = (spdifin_clk / (32000  * 64));
+	unsigned int counter_44k  = (spdifin_clk / (44100  * 64));
+	unsigned int counter_48k  = (spdifin_clk / (48000  * 64));
+	unsigned int counter_88k  = (spdifin_clk / (88200  * 64));
+	unsigned int counter_96k  = (spdifin_clk / (96000  * 64));
+	unsigned int counter_176k = (spdifin_clk / (176400 * 64));
+	unsigned int counter_192k = (spdifin_clk / (192000 * 64));
+	unsigned int mode0_th = 3 * (counter_32k + counter_44k) >> 1;
+	unsigned int mode1_th = 3 * (counter_44k + counter_48k) >> 1;
+	unsigned int mode2_th = 3 * (counter_48k + counter_88k) >> 1;
+	unsigned int mode3_th = 3 * (counter_88k + counter_96k) >> 1;
+	unsigned int mode4_th = 3 * (counter_96k + counter_176k) >> 1;
+	unsigned int mode5_th = 3 * (counter_176k + counter_192k) >> 1;
+	unsigned int mode0_timer = counter_32k >> 1;
+	unsigned int mode1_timer = counter_44k >> 1;
+	unsigned int mode2_timer = counter_48k >> 1;
+	unsigned int mode3_timer = counter_88k >> 1;
+	unsigned int mode4_timer = counter_96k >> 1;
+	unsigned int mode5_timer = (counter_176k >> 1);
+	unsigned int mode6_timer = (counter_192k >> 1);
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_SAMPLE_CTRL0,
+		   0x0 << 28 |                /* detect by max_width */
+		   (spdifin_clk / 10000) << 0 /* base timer */
+		  );
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_SAMPLE_CTRL1,
+		   mode0_th << 20 |
+		   mode1_th << 10 |
+		   mode2_th << 0);
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_SAMPLE_CTRL2,
+		   mode3_th << 20 |
+		   mode4_th << 10 |
+		   mode5_th << 0);
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_SAMPLE_CTRL3,
+		   (mode0_timer << 24) |
+		   (mode1_timer << 16) |
+		   (mode2_timer << 8)	|
+		   (mode3_timer << 0)
+		  );
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_SAMPLE_CTRL4,
+		   (mode4_timer << 24) |
+		   (mode5_timer << 16) |
+		   (mode6_timer << 8)
+		  );
+
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_CTRL0,
+		   0x1 << 31 | /* reg_work_en */
+		   0x1 << 30 | /* reg_chnum_sel */
+		   0x1 << 25 | /* reg_findpapb_en */
+		   0x1 << 24 | /* nonpcm2pcm_th enable */
+		   0xFFF << 12 |  /* reg_nonpcm2pcm_th */
+		   0x1 << 2    /* reg_check_parity */
+		  );
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_CTRL2,
+		   (1 << 14) | /* reg_earc_auto */
+		   (1 << 13)  /* reg_earcin_papb_lr */
+		  );
+	mmio_write(dmac_map,
+		   EARCRX_SPDIFIN_CTRL3,
+		   (0xEC37 << 16) | /* reg_earc_pa_value */
+		   (0x5A5A << 0)    /* reg_earc_pb_value */
+		  );
+}
+
+enum cmdc_st earcrx_cmdc_get_state(struct regmap *cmdc_map)
+{
+	int val = mmio_read(cmdc_map, EARC_RX_CMDC_STATUS0);
+	enum cmdc_st state = (enum cmdc_st)(val & 0x7);
+
+	return state;
+}
+
+enum attend_type earcrx_cmdc_get_attended_type(struct regmap *cmdc_map)
+{
+	int val = mmio_read(cmdc_map, EARC_RX_CMDC_STATUS0);
+	enum cmdc_st state = (enum cmdc_st)(val & 0x7);
+	enum attend_type type = ATNDTYP_DISCNCT;
+
+	if ((val & (1 << 0x3)) && (state == CMDC_ST_ARC))
+		type = ATNDTYP_ARC;
+	else if ((val & (1 << 0x4)) && (state == CMDC_ST_EARC))
+		type = ATNDTYP_EARC;
+
+	return type;
+}
+
+void earcrx_cdmc_clr_irqs(struct regmap *top_map, int clr)
+{
+	mmio_write(top_map, EARCRX_CMDC_INT_PENDING, clr);
+}
+
+int earcrx_cdmc_get_irqs(struct regmap *top_map)
+{
+	return mmio_read(top_map, EARCRX_CMDC_INT_PENDING);
+}
+
+void earcrx_dmac_clr_irqs(struct regmap *top_map, int clr)
+{
+	mmio_write(top_map, EARCRX_DMAC_INT_PENDING, clr);
+}
+
+int earcrx_dmac_get_irqs(struct regmap *top_map)
+{
+	return mmio_read(top_map, EARCRX_DMAC_INT_PENDING);
+}
+
+void earcrx_enable(struct regmap *cmdc_map,
+		   struct regmap *dmac_map, bool enable)
 {
+	enum attend_type type = earcrx_cmdc_get_attended_type(cmdc_map);
+
 	if (enable) {
-		earcrx_dmac_update_bits(EARCRX_DMAC_SYNC_CTRL0,
-			1 << 30,	 /* reg_rst_afifo_out_n */
-			1 << 30);
+		mmio_update_bits(dmac_map, EARCRX_DMAC_SYNC_CTRL0,
+				 1 << 30,	 /* reg_rst_afifo_out_n */
+				 1 << 30);
 
-		earcrx_dmac_update_bits(EARCRX_DMAC_SYNC_CTRL0,
-			1 << 29,	 /* reg_rst_afifo_in_n */
-			0x1 << 29);
+		mmio_update_bits(dmac_map, EARCRX_DMAC_SYNC_CTRL0,
+				 1 << 29,	 /* reg_rst_afifo_in_n */
+				 0x1 << 29);
 
-		earcrx_dmac_update_bits(EARCRX_ERR_CORRECT_CTRL0,
-			1 << 29,  /* reg_rst_afifo_out_n */
-			1 << 29
-			);
-		earcrx_dmac_update_bits(EARCRX_ERR_CORRECT_CTRL0,
-			1 << 28, /* reg_rst_afifo_in_n */
-			1 << 28	/* reg_rst_afifo_in_n */
+		mmio_update_bits(dmac_map, EARCRX_ERR_CORRECT_CTRL0,
+				 1 << 29,  /* reg_rst_afifo_out_n */
+				 1 << 29
+				);
+		mmio_update_bits(dmac_map, EARCRX_ERR_CORRECT_CTRL0,
+				 1 << 28, /* reg_rst_afifo_in_n */
+				 1 << 28	/* reg_rst_afifo_in_n */
+				);
+	} else {
+		mmio_update_bits(dmac_map, EARCRX_DMAC_SYNC_CTRL0,
+				 0x3 << 29,
+				 0x0 << 29);
+
+		mmio_update_bits(dmac_map, EARCRX_ERR_CORRECT_CTRL0,
+				 0x3 << 28, 0x0 << 28);
+	}
+
+	if (type == ATNDTYP_EARC)
+		mmio_update_bits(dmac_map, EARCRX_DMAC_SYNC_CTRL0,
+				 1 << 31,	 /* reg_work_en */
+				 enable << 31);
+	else if (type == ATNDTYP_ARC) {
+		mmio_update_bits(dmac_map,
+				 EARCRX_SPDIFIN_SAMPLE_CTRL0,
+				 0x1 << 31, /* reg_work_enable */
+				 enable << 31);
+
+		mmio_write(dmac_map, EARCRX_DMAC_SYNC_CTRL0, 0x0);
+	}
+
+	mmio_update_bits(dmac_map, EARCRX_DMAC_UBIT_CTRL0,
+			 1 << 31, /* reg_work_enable */
+			 enable << 31);
+
+	mmio_update_bits(dmac_map, EARCRX_ERR_CORRECT_CTRL0,
+			 1 << 31,
+			 enable << 31); /* reg_work_en */
+
+	mmio_update_bits(dmac_map, EARCRX_DMAC_TOP_CTRL0,
+			 1 << 31,
+			 enable << 31); /* reg_top_work_en */
+}
+
+void earctx_cmdc_int_mask(struct regmap *top_map)
+{
+	mmio_write(top_map, EARCTX_CMDC_INT_MASK,
+		   (0x0 << 17) | /* hpd_high_int */
+		   (0x0 << 16) | /* hpd_low_int */
+		   (0x1 << 15) | /* idle2_int */
+		   (0x1 << 14) | /* idle1_int */
+		   (0x1 << 13) | /* disc2_int */
+		   (0x1 << 12) | /* disc1_int */
+		   (0x1 << 11) | /* earc_int */
+		   (0x0 << 10) | /* hb_status_int */
+		   (0x1 << 9) |  /* losthb_int */
+		   (0x1 << 8) |  /* timeout_int */
+		   (0x0 << 7) |  /* status_ch_int */
+		   (0x0 << 6) |  /* int_recv_finished */
+		   (0x0 << 5) |  /* int_recv_nack */
+		   (0x0 << 4) |  /* int_recv_norsp */
+		   (0x0 << 3) |  /* int_recv_unexp */
+		   (0x0 << 2) |  /* int_recv_data */
+		   (0x0 << 1) |  /* int_recv_ack */
+		   (0x0 << 0)	  /* int_recv_ecc_err */
+		  );
+}
+
+void earctx_cmdc_init(struct regmap *top_map)
+{
+	/* ana */
+	mmio_write(top_map, EARCTX_ANA_CTRL0,
+		   0x1 << 31 |  /* earctx_en_d2a */
+		   0x1 << 28 |  /* earctx_cmdcrx_rcfilter_sel */
+		   0x4 << 26 |  /* earctx_cmdcrx_hystrim */
+		   0x8 << 20 |  /* earctx_idr_trim */
+		   0x10 << 12 | /* earctx_rterm_trim */
+		   0x4 << 8 |   /* earctx_dmac_slew_con */
+		   0x4 << 5 |  /* earctx_cmdctx_ack_hystrim */
+		   0x10 << 0   /* earctx_cmdctx_ack_reftrim */
+		  );
+}
+
+void earctx_cmdc_arc_connect(struct regmap *cmdc_map, bool init)
+{
+	if (init)
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_VSM_CTRL0,
+				 0x7 << 25,
+				 0x1 << 27 | /* arc_initiated */
+				 0x0 << 26 | /* arc_terminated */
+				 0x1 << 25   /* arc_enable */
+				);
+	else
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_VSM_CTRL0,
+				 0x7 << 25,
+				 0x0 << 27 | /* arc_initiated */
+				 0x1 << 26 | /* arc_terminated */
+				 0x0 << 25   /* arc_enable */
+				);
+}
+
+void earctx_cmdc_hpd_detect(struct regmap *top_map,
+			    struct regmap *cmdc_map,
+			    int earc_port, bool st)
+{
+	/* select hdmirx_hpd */
+	mmio_update_bits(cmdc_map,
+			 EARC_TX_CMDC_VSM_CTRL1,
+			 0x1 << 8, /* cntl_hpd_sel */
+			 0x1 << 8);
+
+	/* select hdmi_hpd mux */
+	mmio_update_bits(top_map, EARCTX_TOP_CTRL0,
+			 0xf << 8,
+			 0x1 << 11 |    /* hdmi_hpd invent */
+			 earc_port << 8 /* hdmi_hpd mux, port 0/1/2 */
 			);
+
+	if (st) {
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_VSM_CTRL0,
+				 0x1 << 19,
+				 0x1 << 19	/* comma_cnt_rst */
+				);
+
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_VSM_CTRL0,
+				 0x1 << 19 | 0xf << 20,
+				 0x0 << 19 |   /* comma_cnt_rst */
+				 0x3 << 20 | 0x3 << 22
+				);
+
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_VSM_CTRL1,
+				 0xff << 0,
+				 0x4 << 0   /* comma_cnt_th */
+				);
 	} else {
-		earcrx_dmac_update_bits(EARCRX_DMAC_SYNC_CTRL0,
-			0x3 << 29,
-			0x0 << 29);
+		/* soft reset */
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_TOP_CTRL1,
+				 0xf << 0,
+				 0xf << 0);
+		mmio_update_bits(cmdc_map,
+				 EARC_TX_CMDC_TOP_CTRL1,
+				 0xf << 0,
+				 0x0 << 0);
+	}
+}
+
+void earctx_dmac_init(struct regmap *top_map, struct regmap *dmac_map)
+{
+	mmio_update_bits(dmac_map, EARCTX_SPDIFOUT_CTRL0,
+			 0x3 << 28,
+			 0x0 << 28);
+	mmio_update_bits(dmac_map, EARCTX_SPDIFOUT_CTRL0,
+			 0x1 << 29, /* afifo out reset */
+			 0x1 << 29);
+	mmio_update_bits(dmac_map, EARCTX_SPDIFOUT_CTRL0,
+			 0x1 << 28 | /* afifo in reset */
+			 0x1 << 26 | /* user Bit select */
+			 0x1 << 24 | /* chdata select*/
+			 0x1 << 20 | /* reg_data_sel, 1: data from 27bit */
+			 0x1 << 19 | /* 0: lsb first */
+			 0x1 << 18 | /* biphase encode valid Bit value sel */
+			 0xff << 4,   /* lane mask */
+			 0x1 << 28 |
+			 0x1 << 26 |
+			 0x1 << 24 |
+			 0x1 << 20 |
+			 0x0 << 19 |
+			 0x1 << 18 |
+			 0x3 << 4   //  ODO: lane 0 now
+			);
+
+	mmio_update_bits(dmac_map, EARCTX_ERR_CORRT_CTRL0,
+			 0x1 << 16 | /* reg_ubit_fifo_init_n */
+			 0x7 << 8  | /* r channel select */
+			 0x7 << 4,   /* l channel select */
+			 0x1 << 16 |
+			 0x1 << 8 |
+			 0x0 << 4);
+
+	mmio_update_bits(dmac_map, EARCTX_ERR_CORRT_CTRL4,
+			 0xf << 17,
+			 0x1 << 19 |  /* userBit sel, 1: reg_value */
+			 0x1 << 18 |  /* validBit sel, 1: reg_value */
+			 0x1 << 17    /* reg_chst_sel, 1: reg_value */
+			);
+}
+
+void earctx_dmac_set_format(struct regmap *dmac_map,
+			    int frddr_idx, int msb, int frddr_type)
+{
+	mmio_update_bits(dmac_map, EARCTX_SPDIFOUT_CTRL1,
+			 0x7 << 24 |  /* frddr src */
+			 0xff << 16 | /* waiting count after enabled */
+			 0x1f << 8  | /* msb position */
+			 0x7 << 4,    /* frddr type */
+			 frddr_idx << 24 |
+			 0x40 << 16 |
+			 msb << 8 |
+			 frddr_type << 4);
 
-		earcrx_dmac_update_bits(EARCRX_ERR_CORRECT_CTRL0,
-			0x3 << 28, 0x0 << 28);
+	mmio_update_bits(dmac_map, EARCTX_ERR_CORRT_CTRL4,
+			 0x1f << 25,
+			 0x1f << 25  /* msb */
+			);
+
+	/* for raw data */
+	mmio_update_bits(dmac_map, EARCTX_ERR_CORRT_CTRL3,
+			 0x1f << 24,
+			 0x17 << 24
+			);
+}
+
+void earctx_set_channel_status_info(struct regmap *dmac_map,
+				    struct iec958_chsts *chsts)
+{
+	/* ch status = reg_chsts0~B */
+
+	/* L Channel */
+	mmio_write(dmac_map, EARCTX_SPDIFOUT_CHSTS0,
+		   ((chsts->chstat1_l >> 8) & 0xf) << 24 | chsts->chstat0_l);
+
+	/* R Channel */
+	mmio_write(dmac_map, EARCTX_SPDIFOUT_CHSTS6,
+		   ((chsts->chstat1_r >> 8) & 0xf) << 24 | chsts->chstat0_r);
+}
+
+enum cmdc_st earctx_cmdc_get_state(struct regmap *cmdc_map)
+{
+	int val = mmio_read(cmdc_map, EARC_TX_CMDC_STATUS0);
+	enum cmdc_st state = (enum cmdc_st)(val & 0x7);
+
+	return state;
+}
+
+enum attend_type earctx_cmdc_get_attended_type(struct regmap *cmdc_map)
+{
+	int val = mmio_read(cmdc_map, EARC_TX_CMDC_STATUS0);
+	enum cmdc_st state = (enum cmdc_st)(val & 0x7);
+	enum attend_type tx_type = ATNDTYP_DISCNCT;
+
+	if ((val & (1 << 0x3)) && (state == CMDC_ST_ARC))
+		tx_type = ATNDTYP_ARC;
+	else if ((val & (1 << 0x4)) && (state == CMDC_ST_EARC))
+		tx_type = ATNDTYP_EARC;
+
+	return tx_type;
+}
+
+void earctx_cdmc_clr_irqs(struct regmap *top_map, int clr)
+{
+	mmio_write(top_map, EARCTX_CMDC_INT_PENDING, clr);
+}
+
+int earctx_cdmc_get_irqs(struct regmap *top_map)
+{
+	return mmio_read(top_map, EARCTX_CMDC_INT_PENDING);
+}
+
+void earctx_dmac_clr_irqs(struct regmap *top_map, int clr)
+{
+	mmio_write(top_map, EARCTX_DMAC_INT_PENDING, clr);
+}
+
+int earctx_dmac_get_irqs(struct regmap *top_map)
+{
+	return mmio_read(top_map, EARCTX_DMAC_INT_PENDING);
+}
+
+void earctx_enable(struct regmap *top_map,
+		   struct regmap *cmdc_map,
+		   struct regmap *dmac_map,
+		   bool enable)
+{
+	mmio_update_bits(dmac_map, EARCTX_SPDIFOUT_CTRL0,
+			 0x1 << 31,
+			 enable << 31);
+
+	mmio_update_bits(dmac_map, EARC_RX_CMDC_BIPHASE_CTRL1,
+			 0x1 << 30,
+			 enable << 30);
+
+	if (enable)
+		mmio_write(top_map, EARCTX_DMAC_INT_MASK,
+			   (0x1 << 4)	| /* fe_modulation c_hold_clr */
+			   (0x1 << 3)	| /* fe_modulation c_hold_start */
+			   (0x1 << 2)	| /* err_correct c_fifo_thd_less_pass */
+			   (0x1 << 1)	| /* err_correct r_fifo_overflow_set */
+			   (0x1 << 0)	  /* err_correct c_fifo_empty_set */
+			   );
+	else
+		mmio_write(top_map, EARCTX_DMAC_INT_MASK,
+			   0x0
+			   );
+
+	if (earctx_cmdc_get_attended_type(cmdc_map) == ATNDTYP_EARC) {
+		if (spdifout_is_raw()) {
+			mmio_update_bits(dmac_map, EARCTX_ERR_CORRT_CTRL3,
+					 0x1 << 29,
+					 enable << 29);
+		}
+		mmio_update_bits(dmac_map, EARCTX_FE_CTRL0,
+				 0x1 << 30,
+				 enable << 30);
+	}
+}
+
+static void earcrx_cmdc_get_reg(struct regmap *cmdc_map, int dev_id, int offset,
+				u8 *data, int bytes)
+{
+	int i;
+
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 31 | /* apb_write  */
+			 0x1 << 30 | /* apb_read */
+			 0x1 << 29 | /* apb_w_r_done */
+			 0xff << 8 | /* apb_rwid */
+			 0xff << 0,   /* apbrw_start_addr */
+			 0x0 << 31 |
+			 0x1 << 30 |
+			 0x0 << 29 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	for (i = 0; i < bytes; i++) {
+		data[i] = mmio_read(cmdc_map, EARC_RX_CMDC_DEVICE_RDATA);
+		pr_info("%s, data[%d]:%#x\n", __func__, i, data[i]);
+	}
+
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x1 << 29);
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x0 << 29);
+}
+
+static void earcrx_cmdc_set_reg(struct regmap *cmdc_map, int dev_id, int offset,
+				u8 *data, int bytes)
+{
+	int i;
+
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 31 | /* apb_write  */
+			 0x1 << 30 | /* apb_read */
+			 0x1 << 29 | /* apb_w_r_done */
+			 0xff << 8 | /* apb_rwid */
+			 0xff << 0,   /* apbrw_start_addr */
+			 0x1 << 31 |
+			 0x0 << 30 |
+			 0x0 << 29 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	for (i = 0; i < bytes; i++) {
+		pr_info("%s, data[%d]:%#x\n", __func__, i, data[i]);
+		mmio_write(cmdc_map, EARC_RX_CMDC_DEVICE_WDATA, data[i]);
 	}
 
-	earcrx_dmac_update_bits(EARCRX_DMAC_SYNC_CTRL0,
-		1 << 31,	 /* reg_work_en */
-		enable << 31);
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x1 << 29);
+	mmio_update_bits(cmdc_map, EARC_RX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x0 << 29);
+}
+
+/* Latency */
+void earcrx_cmdc_get_latency(struct regmap *cmdc_map, u8 *latency)
+{
+	earcrx_cmdc_get_reg(cmdc_map,
+			    STAT_CTRL_DEV_ID,
+			    ERX_LATENCY_REG,
+			    latency,
+			    1);
+}
+
+void earcrx_cmdc_set_latency(struct regmap *cmdc_map, u8 *latency)
+{
+	earcrx_cmdc_set_reg(cmdc_map,
+			    STAT_CTRL_DEV_ID,
+			    ERX_LATENCY_REG,
+			    latency,
+			    1);
+}
 
-	earcrx_dmac_update_bits(EARCRX_DMAC_UBIT_CTRL0,
-		1 << 31, /* reg_work_enable */
-		enable << 31);
+void earcrx_cmdc_get_cds(struct regmap *cmdc_map, u8 *cds)
+{
+	earcrx_cmdc_get_reg(cmdc_map,
+			    CAP_DEV_ID,
+			    0x0,
+			    cds,
+			    CDS_MAX_BYTES);
+}
+
+void earcrx_cmdc_set_cds(struct regmap *cmdc_map, u8 *cds)
+{
+	earcrx_cmdc_set_reg(cmdc_map,
+			    CAP_DEV_ID,
+			    0x0,
+			    cds,
+			    CDS_MAX_BYTES);
+}
+
+static int earctx_cmdc_get_reg(struct regmap *cmdc_map, int dev_id, int offset,
+			       u8 *data, int bytes)
+{
+	int val = 0, i;
+	int ret = -1;
+
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_MASTER_CTRL,
+			 0x1 << 31 | /* master_cmd_rw, read */
+			 0x1 << 30 | /* master_hb_ignore */
+			 0xf << 24 | /* hb_cmd_val_th */
+			 0xff << 16 | /* master_cmd_count */
+			 0xff << 8 | /* master_cmd_id */
+			 0xff << 0,  /* master_cmd_address */
+			 0x0 << 31 |
+			 0x1 << 30 |
+			 0x4 << 24 |
+			 (bytes - 1) << 16 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	/* wait read from rx done */
+	while (!(val & (1 << 29))) {
+		usleep_range(500, 1500);
+		val = mmio_read(cmdc_map, EARC_TX_CMDC_MASTER_CTRL);
+	}
+
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 31 | /* apb_write */
+			 0x1 << 30 | /* apb_read */
+			 0x1 << 29 | /* apb_rw_done */
+			 0x1 << 16 | /* hpb_rst_enable */
+			 0xff << 8 | /* apb_rwid */
+			 0xff << 0,   /* apbrw_start_addr */
+			 0x0 << 31 |
+			 0x1 << 30 |
+			 0x0 << 29 |
+			 0x1 << 16 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	for (i = 0; i < bytes; i++) {
+		data[i] = mmio_read(cmdc_map, EARC_TX_CMDC_DEVICE_RDATA);
+		pr_info("%s, bytes:%d, data[%d]:%#x\n",
+			__func__,
+			bytes,
+			i,
+			data[i]);
+	}
 
-	earcrx_dmac_update_bits(EARCRX_ERR_CORRECT_CTRL0,
-		1 << 31,
-		enable << 31); /* reg_work_en */
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x1 << 29);
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x0 << 29);
 
-	earcrx_dmac_update_bits(EARCRX_DMAC_TOP_CTRL0,
-		1 << 31,
-		enable << 31); /* reg_top_work_en */
+	if (val & (1 << 29))
+		ret = 0;
+
+	return ret;
+}
+
+static int earctx_cmdc_set_reg(struct regmap *cmdc_map, int dev_id, int offset,
+			       u8 *data, int bytes)
+{
+	int val = 0, i;
+	int ret = -1;
+	int cnt = 0;
+
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 31 | /* apb_write */
+			 0x1 << 30 | /* apb_read */
+			 0x1 << 29 | /* apb_rw_done */
+			 0x1 << 16 | /* hpb_rst_enable */
+			 0xff << 8 | /* apb_rwid */
+			 0xff << 0,   /* apbrw_start_addr */
+			 0x1 << 31 |
+			 0x0 << 30 |
+			 0x0 << 29 |
+			 0x1 << 16 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	for (i = 0; i < bytes; i++) {
+		mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_WDATA,
+				 0xff << 0,
+				 data[i] << 0);
+		pr_info("%s, data[%d]:%#x, bytes:%d\n",
+			__func__,
+			i,
+			data[i],
+			bytes);
+	}
+
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_MASTER_CTRL,
+			 0x1 << 31 | /* master_cmd_rw, write */
+			 0x1 << 30 | /* master_hb_ignore */
+			 0xf << 24 | /* hb_cmd_cal_th */
+			 0xff << 16 | /* master_cmd_count */
+			 0xff << 8 | /* master_cmd_id */
+			 0xff << 0,  /* master_cmd_address */
+			 0x1 << 31 |
+			 0x1 << 30 |
+			 4 << 24 |
+			 (bytes - 1) << 16 |
+			 dev_id << 8 |
+			 offset << 0);
+
+	/* wait write done */
+	while (!(val & (1 << 29))) {
+		usleep_range(500, 1500);
+		val = mmio_read(cmdc_map, EARC_TX_CMDC_MASTER_CTRL);
+		cnt++;
+	}
+	pr_info("%s, cnt:%d\n", __func__, cnt);
+
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x1 << 29);
+	mmio_update_bits(cmdc_map, EARC_TX_CMDC_DEVICE_ID_CTRL,
+			 0x1 << 29, 0x0 << 29);
+
+	if (val & (1 << 29))
+		ret = 0;
+
+	return ret;
+}
+
+/* Latency */
+void earctx_cmdc_get_latency(struct regmap *cmdc_map, u8 *latency)
+{
+	earctx_cmdc_get_reg(cmdc_map,
+			    STAT_CTRL_DEV_ID,
+			    ERX_LATENCY_REG,
+			    latency,
+			    1);
+}
+
+void earctx_cmdc_set_latency(struct regmap *cmdc_map, u8 *latency)
+{
+	earctx_cmdc_set_reg(cmdc_map,
+			    STAT_CTRL_DEV_ID,
+			    ERX_LATENCY_REQ_REG,
+			    latency,
+			    1);
+}
+
+/* Capability Data Structure, fetch CDS from RX */
+void earctx_cmdc_get_cds(struct regmap *cmdc_map, u8 *cds)
+{
+	earctx_cmdc_get_reg(cmdc_map,
+			    CAP_DEV_ID,
+			    0x0,
+			    cds,
+			    CDS_MAX_BYTES);
 }
diff --git a/sound/soc/amlogic/auge/earc_hw.h b/sound/soc/amlogic/auge/earc_hw.h
index 1630733add2f..d40120985ec4 100644
--- a/sound/soc/amlogic/auge/earc_hw.h
+++ b/sound/soc/amlogic/auge/earc_hw.h
@@ -19,9 +19,156 @@
 
 #include "regs.h"
 #include "iomap.h"
+#include <linux/amlogic/media/sound/iomapres.h>
+#include <linux/amlogic/media/sound/spdif_info.h>
+
+#define INT_EARCRX_CMDC_IDLE2               (0x1 << 15)
+#define INT_EARCRX_CMDC_IDLE1               (0x1 << 14)
+#define INT_EARCRX_CMDC_DISC2               (0x1 << 13)
+#define INT_EARCRX_CMDC_DISC1               (0x1 << 12)
+#define INT_EARCRX_CMDC_EARC                (0x1 << 11)
+#define INT_EARCRX_CMDC_HB_STATUS           (0x1 << 10)
+#define INT_EARCRX_CMDC_LOSTHB              (0x1 << 9)
+#define INT_EARCRX_CMDC_TIMEOUT             (0x1 << 8)
+#define INT_EARCRX_CMDC_STATUS_CH           (0x1 << 7)
+#define INT_EARCRX_CMDC_REC_INVALID_ID      (0x1 << 6)
+#define INT_EARCRX_CMDC_REC_INVALID_OFFSET  (0x1 << 5)
+#define INT_EARCRX_CMDC_REC_UNEXP           (0x1 << 4)
+#define INT_EARCRX_CMDC_REC_ECC_ERR         (0x1 << 3)
+#define INT_EARCRX_CMDC_REC_PARITY_ERR      (0x1 << 2)
+#define INT_EARCRX_CMDC_RECV_PACKET         (0x1 << 1)
+#define INT_EARCRX_CMDC_REC_TIME_OUT        (0x1 << 0)
+
+#define INT_EARCRX_ANA_RST_C_NEW_FORMAT_SET                (0x1 << 17)
+#define INT_EARCRX_ANA_RST_C_EARCRX_DIV2_HOLD_SET          (0x1 << 16)
+#define INT_EARCRX_ERR_CORRECT_C_BCHERR_INT_SET            (0x1 << 15)
+#define INT_EARCRX_ERR_CORRECT_R_AFIFO_OVERFLOW_SET        (0x1 << 14)
+#define INT_EARCRX_ERR_CORRECT_R_FIFO_OVERFLOW_SET         (0x1 << 13)
+#define INT_EARCRX_USER_BIT_CHECK_R_FIFO_OVERFLOW          (0x1 << 12)
+#define INT_EARCRX_USER_BIT_CHECK_C_FIFO_THD_PASS          (0x1 << 11)
+#define INT_EARCRX_USER_BIT_CHECK_C_U_PK_LOST_INT_SET      (0x1 << 10)
+#define INT_ARCRX_USER_BIT_CHECK_C_IU_PK_END               (0x1 << 9)
+#define INT_ARCRX_BIPHASE_DECODE_C_CHST_MUTE_CLR           (0x1 << 8)
+#define INT_ARCRX_BIPHASE_DECODE_C_FIND_PAPB               (0x1 << 7)
+#define INT_ARCRX_BIPHASE_DECODE_C_VALID_CHANGE            (0x1 << 6)
+#define INT_ARCRX_BIPHASE_DECODE_C_FIND_NONPCM2PCM         (0x1 << 5)
+#define INT_ARCRX_BIPHASE_DECODE_C_PCPD_CHANGE             (0x1 << 4)
+#define INT_ARCRX_BIPHASE_DECODE_C_CH_STATUS_CHANGE        (0x1 << 3)
+#define INT_ARCRX_BIPHASE_DECODE_I_SAMPLE_MODE_CHANGE      (0x1 << 2)
+#define INT_ARCRX_BIPHASE_DECODE_R_PARITY_ERR              (0x1 << 1)
+#define INT_ARCRX_DMAC_SYNC_AFIFO_OVERFLOW                 (0x1 << 0)
+
+#define INT_EARCTX_CMDC_HPD_H               (0x1 << 17)
+#define INT_EARCTX_CMDC_HPD_L               (0x1 << 16)
+#define INT_EARCTX_CMDC_IDLE2               (0x1 << 15)
+#define INT_EARCTX_CMDC_IDLE1               (0x1 << 14)
+#define INT_EARCTX_CMDC_DISC2               (0x1 << 13)
+#define INT_EARCTX_CMDC_DISC1               (0x1 << 12)
+#define INT_EARCTX_CMDC_EARC                (0x1 << 11)
+#define INT_EARCTX_CMDC_HB_STATUS           (0x1 << 10)
+#define INT_EARCTX_CMDC_LOSTHB              (0x1 << 9)
+#define INT_EARCTX_CMDC_TIMEOUT             (0x1 << 8)
+#define INT_EARCTX_CMDC_STATUS_CH           (0x1 << 7)
+#define INT_EARCTX_CMDC_RECV_FINISHED       (0x1 << 6)
+#define INT_EARCTX_CMDC_RECV_NACK           (0x1 << 5)
+#define INT_EARCTX_CMDC_RECV_NORSP          (0x1 << 4)
+#define INT_EARCTX_CMDC_RECV_UNEXP          (0x1 << 3)
+#define INT_EARCTX_CMDC_RECV_DATA           (0x1 << 2)
+#define INT_EARCTX_CMDC_RECV_ACK            (0x1 << 1)
+#define INT_EARCTX_CMDC_RECV_ECC_ERR        (0x1 << 0)
+
+#define INT_EARCTX_FEM_C_HOLD_CLR                (0x1 << 4)
+#define INT_EARCTX_FEM_C_HOLD_START              (0x1 << 3)
+#define INT_EARCTX_ERRCORR_C_FIFO_THD_LESS_PASS  (0x1 << 2)
+#define INT_EARCTX_ERRCORR_C_FIFO_OVERFLOW       (0x1 << 1)
+#define INT_EARCTX_ERRCORR_C_FIFO_EMPTY          (0x1 << 0)
+
+/* cmdc discovery and disconnect state */
+enum cmdc_st {
+	CMDC_ST_OFF,
+	CMDC_ST_IDLE1,
+	CMDC_ST_IDLE2,
+	CMDC_ST_DISC1,
+	CMDC_ST_DISC2,
+	CMDC_ST_EARC,
+	CMDC_ST_ARC
+};
+
+/* attended type: disconect, ARC, eARC */
+enum attend_type {
+	ATNDTYP_DISCNCT,
+	ATNDTYP_ARC,
+	ATNDTYP_EARC
+};
+
+enum tx_hd_hdp_mux {
+	GPIOW_1,
+	GPIOW_9,
+	GPIOW_5
+};
+
+enum device_id {
+	/* Capabilities Data Structure */
+	CAP_DEV_ID = 0xA0,
+	/* eARC status and latency control registers */
+	STAT_CTRL_DEV_ID = 0x74
+};
+
+enum reg_offset {
+	/* eARC Status Register Offset */
+	EARCRX_STAT_REG = 0xD0,
+	EARCTX_STAT_REG = 0xD1,
+	/* eARC Latency Registers Offset */
+	ERX_LATENCY_REG = 0xD2,
+	ERX_LATENCY_REQ_REG = 0xD3
+};
+
+#define CDS_MAX_BYTES 256
+
+void earcrx_pll_refresh(struct regmap *top_map);
+void earcrx_cmdc_init(struct regmap *top_map);
+void earcrx_cmdc_arc_connect(struct regmap *cmdc_map, bool init);
+void earcrx_cmdc_hpd_detect(struct regmap *cmdc_map, bool st);
+void earcrx_dmac_init(struct regmap *top_map, struct regmap *dmac_map);
+void earcrx_arc_init(struct regmap *dmac_map);
+enum cmdc_st earcrx_cmdc_get_state(struct regmap *cmdc_map);
+enum attend_type earcrx_cmdc_get_attended_type(struct regmap *cmdc_map);
+void earcrx_cdmc_clr_irqs(struct regmap *top_map, int clr);
+int earcrx_cdmc_get_irqs(struct regmap *top_map);
+void earcrx_dmac_clr_irqs(struct regmap *top_map, int clr);
+int earcrx_dmac_get_irqs(struct regmap *top_map);
+void earcrx_enable(struct regmap *cmdc_map,
+		   struct regmap *dmac_map, bool enable);
+void earctx_cmdc_int_mask(struct regmap *top_map);
+
+void earctx_cmdc_init(struct regmap *top_map);
+void earctx_cmdc_arc_connect(struct regmap *cmdc_map, bool init);
+void earctx_cmdc_hpd_detect(struct regmap *top_map,
+			    struct regmap *cmdc_map,
+			    int earc_port, bool st);
+void earctx_dmac_init(struct regmap *top_map, struct regmap *dmac_map);
+void earctx_dmac_set_format(struct regmap *dmac_map,
+			    int frddr_idx, int msb, int frddr_type);
+void earctx_set_channel_status_info(struct regmap *dmac_map,
+				    struct iec958_chsts *chsts);
+enum cmdc_st earctx_cmdc_get_state(struct regmap *cmdc_map);
+enum attend_type earctx_cmdc_get_attended_type(struct regmap *cmdc_map);
+void earctx_cdmc_clr_irqs(struct regmap *top_map, int clr);
+int earctx_cdmc_get_irqs(struct regmap *top_map);
+void earctx_dmac_clr_irqs(struct regmap *top_map, int clr);
+int earctx_dmac_get_irqs(struct regmap *top_map);
+void earctx_enable(struct regmap *top_map,
+		   struct regmap *cmdc_map,
+		   struct regmap *dmac_map,
+		   bool enable);
+
+void earcrx_cmdc_get_latency(struct regmap *cmdc_map, u8 *latency);
+void earcrx_cmdc_set_latency(struct regmap *cmdc_map, u8 *latency);
+void earcrx_cmdc_get_cds(struct regmap *cmdc_map, u8 *cds);
+void earcrx_cmdc_set_cds(struct regmap *cmdc_map, u8 *cds);
+
+void earctx_cmdc_get_latency(struct regmap *cmdc_map, u8 *latency);
+void earctx_cmdc_set_latency(struct regmap *cmdc_map, u8 *latency);
+void earctx_cmdc_get_cds(struct regmap *cmdc_map, u8 *cds);
 
-extern void earcrx_cmdc_init(void);
-extern void earcrx_dmac_init(void);
-extern void earc_arc_init(void);
-extern void earc_rx_enable(bool enable);
 #endif
diff --git a/sound/soc/amlogic/auge/effects_hw_v2_coeff.h b/sound/soc/amlogic/auge/effects_hw_v2_coeff.h
index d0c943359719..305a2efce2e6 100644
--- a/sound/soc/amlogic/auge/effects_hw_v2_coeff.h
+++ b/sound/soc/amlogic/auge/effects_hw_v2_coeff.h
@@ -101,69 +101,75 @@ static unsigned int CROSSOVER_COEFF[CROSSOVER_FILTER_SIZE] = {
 #define AED_MULTIBAND_DRC_BANDS  (3)
 #define AED_MULTIBAND_DRC_SIZE   (30)
 #define MULTIBAND_DRC_PARAM_BYTE (120) /*"0x%8.8x "*/
-/*RMS:5ms, ATTACK:2ms, RELEASE:20ms*/
+
 static unsigned int multiband_drc_coeff[AED_MULTIBAND_DRC_SIZE] = {
-	0x34ebb,   /* Low RMS coeff0 */
-	0x7cb145,  /* Low RMS coeff1 */
-	0x5188,    /* Low RELEASE coeff0 */
-	0x7fae78,  /* Low RELEASE coeff1 */
-	0x3263a,   /* Low ATTACK coeff0 */
-	0x7cd9c6,  /* Low ATTACK coeff1 */
-	0x0,	   /* Low THD0 coeff */
-	0x40000,   /* Low K0 coeff */
-	0x40000,   /* Low GAIN */
-	0x0,	   /* Low OFFSET coeff*/
+	/*RMS:5ms, ATTACK:10ms, RELEASE:100ms, THD: 0dB, K = 0*/
+	0x00012aa0,  /* Low RMS coeff0 */
+	0x007ed560,  /* Low RMS coeff1 */
+	0x00000eff,  /* Low RELEASE coeff0 */
+	0x007ff101,  /* Low RELEASE coeff1 */
+	0x000095a8,  /* Low ATTACK coeff0 */
+	0x007f6a58,  /* Low ATTACK coeff1 */
+	0x00000000,  /* Low THD0 coeff */
+	0x00000000,  /* Low K0 coeff */
+	0x00040000,  /* Low GAIN */
+	0x00000000,  /* Low OFFSET coeff*/
 
-	0x34ebb,   /* Mid RMS coeff0 */
-	0x7cb145,  /* Mid RMS coeff1 */
-	0x5188,    /* Mid RELEASE coeff0 */
-	0x7fae78,  /* Mid RELEASE coeff1 */
-	0x3263a,   /* Mid ATTACK coeff0 */
-	0x7cd9c6,  /* Mid ATTACK coeff1 */
-	0x0,	   /* Mid THD0 coeff */
-	0x40000,   /* Mid K0 coeff */
-	0x0,	   /* Mid OFFSET coeff*/
-	0x40000,   /* Mid GAIN */
+	/*RMS:2ms, ATTACK:5ms, RELEASE:100ms, THD: 0dB, K = 0*/
+	0x0002e578,  /* Mid RMS coeff0 */
+	0x007d1a88,  /* Mid RMS coeff1 */
+	0x00000eff,  /* Mid RELEASE coeff0 */
+	0x007ff101,  /* Mid RELEASE coeff1 */
+	0x00012aa0,  /* Mid ATTACK coeff0 */
+	0x007ed560,  /* Mid ATTACK coeff1 */
+	0x00000000,  /* Mid THD0 coeff */
+	0x00000000,  /* Mid K0 coeff */
+	0x00000000,  /* Mid OFFSET coeff*/
+	0x00040000,  /* Mid GAIN */
 
-	0x34ebb,   /* High RMS coeff0 */
-	0x7cb145,  /* High RMS coeff1 */
-	0x5188,    /* High RELEASE coeff0 */
-	0x7fae78,  /* High RELEASE coeff1 */
-	0x3263a,   /* High ATTACK coeff0 */
-	0x7cd9c6,  /* High ATTACK coeff1 */
-	0x0,	   /* High THD0 coeff */
-	0x40000,   /* High K0 coeff */
-	0x0,	   /* High OFFSET coeff*/
-	0x40000,   /* High GAIN */
+	/*RMS:1ms, ATTACK:1ms, RELEASE:100ms, THD: 0dB, K = 0*/
+	0x0005ba29,  /* High RMS coeff0 */
+	0x007a45d7,  /* High RMS coeff1 */
+	0x00000eff,  /* High RELEASE coeff0 */
+	0x007ff101,  /* High RELEASE coeff1 */
+	0x0005ba29,  /* High ATTACK coeff0 */
+	0x007a45d7,  /* High ATTACK coeff1 */
+	0x00000000,  /* High THD0 coeff */
+	0x00000000,  /* High K0 coeff */
+	0x00000000,  /* High OFFSET coeff*/
+	0x00040000,  /* High GAIN */
 };
 
 #define AED_FULLBAND_DRC_SIZE        (17)
 #define AED_FULLBAND_DRC_BYTES       (70)
 #define AED_FULLBAND_DRC_OFFSET      (6)
 #define AED_FULLBAND_DRC_GROUP_SIZE  (3)
-/*K0 = 0dB; THD0 = 0; K1 = 3.0; THD1 = -70dB*/
-/*RMS:5ms, ATTACK:2ms, RELEASE:20ms*/
+
+/*K0 = 0dB; THD0 = 0; K1 = 1.0; THD1 = -100dB*/
+/*ATTACK0:2ms, RELEASE0:20ms*/
+/*ATTACK1:100ms, RELEASE1:100ms*/
+/*RMS:1ms*/
 /*delay: 144 sample max:255*/
 static int fullband_drc_coeff[AED_FULLBAND_DRC_SIZE] = {
-	0x5188,		/* RELEASE_COEF00 */
-	0x7fae78,	/* RELEASE_COEF01 */
-	0x3263a,	/* ATTACK_COEF00 */
-	0x7cd9c6,	/* ATTACK_COEF01 */
-	0x0,		/* THD0 */
-	0x0,		/* K0 */
+	0x00004aea,	/* RELEASE_COEF00 */
+	0x007fb516,	/* RELEASE_COEF01 */
+	0x0002e578,	/* ATTACK_COEF00 */
+	0x007d1a88,	/* ATTACK_COEF01 */
+	0x00000000,	/* THD0 */
+	0x00000000,	/* K0 */
 
-	0x5188,		/* RELEASE_COEF10 */
-	0x7fae78,	/* RELEASE_COEF11 */
-	0x3263a,	/* ATTACK_COEF10 */
-	0x7cd9c6,	/* ATTACK_COEF11 */
-	0xdd000000,	/* THD1 */
-	0xc0000,	/* K2 */
+	0x00000eff,	/* RELEASE_COEF10 */
+	0x007ff101,	/* RELEASE_COEF11 */
+	0x00000eff,	/* ATTACK_COEF10 */
+	0x007ff101,	/* ATTACK_COEF11 */
+	0xce000000,	/* THD1 */
+	0x00040000,	/* K2 */
 
-	0x34ebb,	/* RMS coeff0 */
-	0x7cb145,	/* RMS coeff1 */
-	0x90,		/* Delay time*/
+	0x0005ba29,	/* RMS coeff0 */
+	0x007a45d7,	/* RMS coeff1 */
+	0x00000090,	/* Delay time*/
 	0xdd000000,	/* THD_OUT0 */
-	0x40000,	/* K1 */
+	0x00040000,	/* K1 */
 };
 
 #endif
diff --git a/sound/soc/amlogic/auge/effects_v2.c b/sound/soc/amlogic/auge/effects_v2.c
index b7ca4bc283ef..e064e86f6437 100644
--- a/sound/soc/amlogic/auge/effects_v2.c
+++ b/sound/soc/amlogic/auge/effects_v2.c
@@ -505,6 +505,10 @@ static const struct snd_kcontrol_new snd_effect_controls[] = {
 		AED_EQ_VOLUME, 16, 0x3FF, 1,
 		mixer_aed_read, mixer_aed_write,
 		master_vol_tlv),
+
+	SOC_SINGLE_EXT("AED Clip THD",
+		AED_CLIP_THD, 0, 0x7FFFFF, 0,
+		mixer_aed_read, mixer_aed_write),
 };
 
 int card_add_effect_v2_kcontrols(struct snd_soc_card *card)
diff --git a/sound/soc/amlogic/auge/extn.c b/sound/soc/amlogic/auge/extn.c
index a5fd6428a537..efe2d73376f9 100644
--- a/sound/soc/amlogic/auge/extn.c
+++ b/sound/soc/amlogic/auge/extn.c
@@ -35,6 +35,7 @@
 #include <sound/control.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <sound/tlv.h>
 
 #include "ddr_mngr.h"
 #include "audio_utils.h"
@@ -47,11 +48,24 @@
 
 #define MAX_INT    0x7ffffff
 
+#define DYNC_KCNTL_CNT 2
+
+enum {
+	HDMIRX_MODE_SPDIFIN = 0,
+	HDMIRX_MODE_PAO = 1,
+};
+
 struct extn_chipinfo {
 	/* try to check papb before fetch pcpd
 	 * no nonpcm2pcm irq for tl1
 	 */
 	bool no_nonpcm2pcm_clr;
+
+	/* eARC-ARC or CEC-ARC
+	 * CEC-ARC: tl1
+	 * eARC-ARC: sm1/tm2, etc
+	 */
+	bool cec_arc;
 };
 
 struct extn {
@@ -91,6 +105,8 @@ struct extn {
 	bool nonpcm_flag;
 
 	struct extn_chipinfo *chipinfo;
+	struct snd_kcontrol *controls[DYNC_KCNTL_CNT];
+
 };
 
 #define PREALLOC_BUFFER		(256 * 1024)
@@ -136,27 +152,24 @@ static irqreturn_t extn_ddr_isr(int irq, void *devid)
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct device *dev = rtd->platform->dev;
 	struct extn *p_extn = (struct extn *)dev_get_drvdata(dev);
-	int timeout_thres = 5;
-
-#ifdef CONFIG_AMLOGIC_MEDIA_TVIN_HDMI
-	int sample_rate_index = get_hdmi_sample_rate_index();
-
-	/*192K audio*/
-	if (sample_rate_index == 7)
-		timeout_thres = 10;
-	else
-		timeout_thres = 5;
-#endif
 
 	if (!snd_pcm_running(substream))
 		return IRQ_HANDLED;
 
 	snd_pcm_period_elapsed(substream);
 
-	/* check pcm or nonpcm */
-	if (p_extn &&
-		p_extn->chipinfo &&
-		p_extn->chipinfo->no_nonpcm2pcm_clr) {
+	/* check pcm or nonpcm for PAO*/
+	if (p_extn->hdmirx_mode == HDMIRX_MODE_PAO) {
+		int timeout_thres = 5;
+#ifdef CONFIG_AMLOGIC_MEDIA_TVIN_HDMI
+		int sample_rate_index = get_hdmi_sample_rate_index();
+
+		/*192K audio*/
+		if (sample_rate_index == 7)
+			timeout_thres = 10;
+		else
+			timeout_thres = 5;
+#endif
 		if (p_extn->frhdmirx_last_cnt == p_extn->frhdmirx_cnt) {
 
 			p_extn->frhdmirx_same_cnt++;
@@ -172,6 +185,8 @@ static irqreturn_t extn_ddr_isr(int irq, void *devid)
 			p_extn->nonpcm_flag = true;
 			frhdmirx_clr_PAO_irq_bits();
 		}
+	} else {
+	    frhdmirx_clr_SPDIF_irq_bits();
 	}
 
 	return IRQ_HANDLED;
@@ -249,8 +264,7 @@ static int extn_close(struct snd_pcm_substream *substream)
 
 		if (toddr_src_get() == FRHDMIRX) {
 			frhdmirx_nonpcm2pcm_clr_reset(p_extn);
-			if (p_extn->hdmirx_mode == 1)
-				frhdmirx_clr_PAO_irq_bits();
+			frhdmirx_clr_all_irq_bits();
 			free_irq(p_extn->irq_frhdmirx, p_extn);
 		}
 	}
@@ -343,6 +357,38 @@ static int extn_mmap(struct snd_pcm_substream *substream,
 	return snd_pcm_lib_default_mmap(substream, vma);
 }
 
+static int extn_copy(struct snd_pcm_substream *substream, int channel,
+			snd_pcm_uframes_t pos,
+			void __user *buf, snd_pcm_uframes_t count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, pos);
+	int bytes = frames_to_bytes(runtime, count);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (copy_from_user(hwbuf, buf, bytes))
+			return -EFAULT;
+	}  else {
+#ifdef CONFIG_AMLOGIC_MEDIA_TVIN_HDMI
+		enum toddr_src src = toddr_src_get();
+
+		/*if hdmirx or N&CTS is unstable, clear all buffer data.*/
+		if (src == FRHDMIRX && (!get_hdmiin_audio_stable() ||
+				get_hdmi_sample_rate_index() == 0)) {
+			char *buffer = runtime->dma_area;
+			int buffer_size = snd_pcm_lib_buffer_bytes(substream);
+
+			memset(buffer, 0, buffer_size);
+		}
+#endif
+		if (copy_to_user(buf, hwbuf, bytes))
+			return -EFAULT;
+
+		memset(hwbuf, 0, bytes);
+	}
+	return 0;
+}
+
 static struct snd_pcm_ops extn_ops = {
 	.open      = extn_open,
 	.close     = extn_close,
@@ -354,6 +400,7 @@ static struct snd_pcm_ops extn_ops = {
 	.pointer   = extn_pointer,
 	.silence   = extn_silence,
 	.mmap      = extn_mmap,
+	.copy      = extn_copy,
 };
 
 static int extn_new(struct snd_soc_pcm_runtime *rtd)
@@ -369,10 +416,19 @@ struct snd_soc_platform_driver extn_platform = {
 	.pcm_new = extn_new,
 };
 
+static int extn_create_controls(struct snd_card *card,
+				struct extn *p_extn);
+
 static int extn_dai_probe(struct snd_soc_dai *cpu_dai)
 {
+	struct snd_card *card = cpu_dai->component->card->snd_card;
+	struct extn *p_extn = snd_soc_dai_get_drvdata(cpu_dai);
+
 	pr_info("asoc debug: %s-%d\n", __func__, __LINE__);
 
+	if (p_extn->chipinfo && p_extn->chipinfo->cec_arc)
+		extn_create_controls(card, p_extn);
+
 	return 0;
 }
 
@@ -386,7 +442,7 @@ static int extn_dai_startup(
 	struct snd_soc_dai *cpu_dai)
 {
 	if (get_audioresample(RESAMPLE_A))
-		resample_set_inner_rate(RESAMPLE_A);
+		resample_set(RESAMPLE_A, RATE_48K);
 
 	return 0;
 }
@@ -395,7 +451,6 @@ static void extn_dai_shutdown(
 	struct snd_pcm_substream *substream,
 	struct snd_soc_dai *cpu_dai)
 {
-	//resample_set(RESAMPLE_A, RATE_OFF, false);
 }
 
 static int extn_dai_prepare(
@@ -427,10 +482,6 @@ static int extn_dai_prepare(
 		else
 			toddr_type = 0;
 
-		pr_info("%s Expected toddr src:%s\n",
-			__func__,
-			toddr_src_get_str(src));
-
 		if (src == FRATV) {
 			/* Now tv supports 48k, 16bits */
 			if ((bit_depth != 16) || (runtime->rate != 48000)) {
@@ -442,22 +493,31 @@ static int extn_dai_prepare(
 			msb = 15;
 			lsb = 0;
 
-			fratv_src_select(1);
+			/* commented it, selected by atv demod,
+			 * select 0 for non standard signal.
+			 */
+			/* fratv_src_select(1); */
 		} else if (src == FRHDMIRX) {
-			if (p_extn->hdmirx_mode) { /* PAO */
 
-				if (bit_depth == 32)
-					toddr_type = 3;
-				else if (bit_depth == 24)
-					toddr_type = 4;
-				else
-					toddr_type = 0;
+			if (bit_depth == 32)
+				toddr_type = 3;
+			else if (bit_depth == 24)
+				toddr_type = 4;
+			else
+				toddr_type = 0;
 
+			if (p_extn->hdmirx_mode == HDMIRX_MODE_PAO) { /* PAO */
 				msb = 28 - 1 - 4;
 				if (bit_depth == 16)
 					lsb = 24 - bit_depth;
 				else
 					lsb = 4;
+			} else { /* SPDIFIN */
+				msb = 28 - 1;
+				if (bit_depth <= 24)
+					lsb = 28 - bit_depth;
+				else
+					lsb = 4;
 			}
 
 			frhdmirx_ctrl(runtime->channels, p_extn->hdmirx_mode);
@@ -468,7 +528,9 @@ static int extn_dai_prepare(
 			return -EINVAL;
 		}
 
-		pr_info("%s m:%d, n:%d\n", __func__, msb, lsb);
+		pr_debug("%s Expected toddr src:%s, m:%d, n:%d, toddr type:%d\n",
+			__func__, toddr_src_get_str(src),
+			msb, lsb, toddr_type);
 
 		fmt.type      = toddr_type;
 		fmt.msb       = msb;
@@ -501,7 +563,8 @@ static int extn_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 
 			aml_frddr_enable(p_extn->fddr, true);
 		} else {
-			dev_info(substream->pcm->card->dev, "External Capture enable\n");
+			dev_dbg(substream->pcm->card->dev,
+				"External Capture enable\n");
 
 			if (src == FRATV)
 				fratv_enable(true);
@@ -525,7 +588,9 @@ static int extn_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 				fratv_enable(false);
 			else if (src == FRHDMIRX)
 				frhdmirx_enable(false);
-			dev_info(substream->pcm->card->dev, "External Capture disable\n");
+
+			dev_dbg(substream->pcm->card->dev,
+				"External Capture disable\n");
 
 			toddr_stopped = aml_toddr_burst_finished(p_extn->tddr);
 			if (toddr_stopped)
@@ -625,8 +690,10 @@ static int arc_get_src(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct extn *p_extn = dev_get_drvdata(component->dev);
+	struct extn *p_extn = snd_kcontrol_chip(kcontrol);
+
+	if (!p_extn)
+		return 0;
 
 	ucontrol->value.integer.value[0] = p_extn->arc_src;
 
@@ -637,8 +704,10 @@ static int arc_set_src(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct extn *p_extn = dev_get_drvdata(component->dev);
+	struct extn *p_extn = snd_kcontrol_chip(kcontrol);
+
+	if (!p_extn)
+		return 0;
 
 	p_extn->arc_src = ucontrol->value.integer.value[0];
 
@@ -651,8 +720,10 @@ static int arc_get_enable(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct extn *p_extn = dev_get_drvdata(component->dev);
+	struct extn *p_extn = snd_kcontrol_chip(kcontrol);
+
+	if (!p_extn)
+		return 0;
 
 	ucontrol->value.integer.value[0] = p_extn->arc_en;
 
@@ -663,8 +734,10 @@ static int arc_set_enable(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct extn *p_extn = dev_get_drvdata(component->dev);
+	struct extn *p_extn = snd_kcontrol_chip(kcontrol);
+
+	if (!p_extn)
+		return 0;
 
 	p_extn->arc_en = ucontrol->value.integer.value[0];
 
@@ -680,6 +753,9 @@ static int frhdmirx_get_mode(
 	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct extn *p_extn = dev_get_drvdata(component->dev);
 
+	if (!p_extn)
+		return 0;
+
 	ucontrol->value.integer.value[0] = p_extn->hdmirx_mode;
 
 	return 0;
@@ -692,6 +768,9 @@ static int frhdmirx_set_mode(
 	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct extn *p_extn = dev_get_drvdata(component->dev);
 
+	if (!p_extn)
+		return 0;
+
 	p_extn->hdmirx_mode = ucontrol->value.integer.value[0];
 
 	return 0;
@@ -741,7 +820,7 @@ static int hdmiin_check_audio_type(struct extn *p_extn)
 	int audio_type = 0;
 	int i;
 
-	if (!p_extn->nonpcm_flag)
+	if (!p_extn->nonpcm_flag && p_extn->hdmirx_mode)
 		return audio_type;
 
 	for (i = 0; i < total_num; i++) {
@@ -763,6 +842,9 @@ static int hdmirx_audio_type_get_enum(
 	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
 	struct extn *p_extn = dev_get_drvdata(component->dev);
 
+	if (!p_extn)
+		return 0;
+
 	ucontrol->value.enumerated.item[0] =
 		hdmiin_check_audio_type(p_extn);
 
@@ -770,8 +852,7 @@ static int hdmirx_audio_type_get_enum(
 }
 #endif
 
-static const struct snd_kcontrol_new extn_controls[] = {
-	/* Out */
+static const struct snd_kcontrol_new extn_arc_controls[DYNC_KCNTL_CNT] = {
 	SOC_ENUM_EXT("HDMI ARC Source",
 		arc_src_enum,
 		arc_get_src,
@@ -781,6 +862,34 @@ static const struct snd_kcontrol_new extn_controls[] = {
 		0,
 		arc_get_enable,
 		arc_set_enable),
+};
+
+static int extn_create_controls(struct snd_card *card,
+				struct extn *p_extn)
+{
+	int i, err = 0;
+
+	memset(p_extn->controls, 0, sizeof(p_extn->controls));
+
+	for (i = 0; i < DYNC_KCNTL_CNT; i++) {
+		p_extn->controls[i] =
+			snd_ctl_new1(&extn_arc_controls[i], p_extn);
+		err = snd_ctl_add(card, p_extn->controls[i]);
+		if (err < 0)
+			goto __error;
+	}
+
+	return 0;
+
+__error:
+	for (i = 0; i < DYNC_KCNTL_CNT; i++)
+		if (p_extn->controls[i])
+			snd_ctl_remove(card, p_extn->controls[i]);
+
+	return err;
+}
+
+static const struct snd_kcontrol_new extn_controls[] = {
 
 	/* In */
 	SOC_SINGLE_BOOL_EXT("SPDIFIN PAO",
@@ -834,9 +943,9 @@ static const struct snd_kcontrol_new extn_controls[] = {
 		aml_set_atmos_audio_edid),
 
 	SOC_ENUM_EXT("HDMIIN Audio Type",
-			 hdmirx_audio_type_enum,
-			 hdmirx_audio_type_get_enum,
-			 NULL),
+		hdmirx_audio_type_enum,
+		hdmirx_audio_type_get_enum,
+		NULL),
 #endif
 
 };
@@ -849,12 +958,12 @@ static const struct snd_soc_component_driver extn_component = {
 
 struct extn_chipinfo tl1_extn_chipinfo = {
 	.no_nonpcm2pcm_clr = true,
+	.cec_arc           = true,
 };
 
 static const struct of_device_id extn_device_id[] = {
 	{
 		.compatible = "amlogic, snd-extn",
-		.data       = &tl1_extn_chipinfo,
 	},
 	{
 		.compatible = "amlogic, tl1-snd-extn",
@@ -913,13 +1022,13 @@ static int extn_platform_probe(struct platform_device *pdev)
 	/* Default ARC SRC */
 	p_extn->arc_src = 1;
 
-	/* Default: PAO mode */
-	p_extn->hdmirx_mode = 1;
+	/* Default: SPDIFIN mode */
+	p_extn->hdmirx_mode = HDMIRX_MODE_SPDIFIN;
 
-	ret = snd_soc_register_component(&pdev->dev,
-				&extn_component,
-				extn_dai,
-				ARRAY_SIZE(extn_dai));
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &extn_component,
+					      extn_dai,
+					      ARRAY_SIZE(extn_dai));
 	if (ret) {
 		dev_err(&pdev->dev,
 			"snd_soc_register_component failed\n");
diff --git a/sound/soc/amlogic/auge/frhdmirx_hw.c b/sound/soc/amlogic/auge/frhdmirx_hw.c
index 1dd059365a71..6f2846bcfd9c 100644
--- a/sound/soc/amlogic/auge/frhdmirx_hw.c
+++ b/sound/soc/amlogic/auge/frhdmirx_hw.c
@@ -51,12 +51,7 @@ void frhdmirx_src_select(int src)
 
 static void frhdmirx_enable_irq_bits(int channels, int src)
 {
-	int lane, int_bits = 0, i;
-
-	if (channels % 2)
-		lane = channels / 2 + 1;
-	else
-		lane = channels / 2;
+	unsigned int int_bits = 0;
 
 	/* interrupt bits */
 	if (src) { /* PAO mode */
@@ -66,78 +61,59 @@ static void frhdmirx_enable_irq_bits(int channels, int src)
 			);
 	} else { /* SPDIF Lane */
 		int lane_irq_bits = (0x1 << 7 | /* lane: find papb */
-			0x1 << 6 | /* lane: find papb */
+			0x1 << 6 | /* lane: find valid changed */
 			0x1 << 5 | /* lane: find nonpcm to pcm */
 			0x1 << 4 | /* lane: find pcpd changed */
 			0x1 << 3 | /* lane: find ch status changed */
 			0x1 << 1 /* lane: find parity error */
 			);
 
+		int lane, i;
+
+		lane = (channels % 2) ? (channels / 2 + 1) : (channels / 2);
 		for (i = 0; i < lane; i++)
-			int_bits |= (lane_irq_bits << i);
+			int_bits |= (lane_irq_bits << 8 * i);
 	}
+
+	int_bits |= audiobus_read(EE_AUDIO_FRHDMIRX_CTRL2);
 	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL2, int_bits);
 }
 
-void frhdmirx_clr_irq_bits(int channels, int src)
+void frhdmirx_clr_all_irq_bits(void)
 {
-	int lane, int_clr_mask = 0, i;
-
-	if (channels % 2)
-		lane = channels / 2 + 1;
-	else
-		lane = channels / 2;
-
-	/* interrupt bits */
-	if (src) { /* PAO mode */
-		int_clr_mask = (
-			0x1 << INT_PAO_PAPB_MASK | /* find papb */
-			0x1 << INT_PAO_PCPD_MASK   /* find pcpd changed */
-			);
-	} else { /* SPDIF Lane */
-		int lane_irq_bits = (0x1 << 7 | /* lane: find papb */
-			0x1 << 6 | /* lane: find valid changed; */
-			0x1 << 5 | /* lane: find nonpcm to pcm */
-			0x1 << 4 | /* lane: find pcpd changed */
-			0x1 << 3 | /* lane: find ch status changed */
-			0x1 << 1 /* lane: find parity error */
-			);
-
-		for (i = 0; i < lane; i++)
-			int_clr_mask |= (lane_irq_bits << i);
-	}
-	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL3, ~int_clr_mask);
-	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL3, int_clr_mask);
-	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, ~int_clr_mask);
-	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, int_clr_mask);
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL3, 0xffffffff);
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL3, 0x0);
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, 0xffffffff);
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, 0x0);
 }
 
 void frhdmirx_ctrl(int channels, int src)
 {
-	int lane, lane_mask = 0, i;
-
 	/* PAO mode */
 	if (src) {
 		audiobus_write(EE_AUDIO_FRHDMIRX_CTRL0,
 			0x1 << 22 | /* capture input by fall edge*/
 			0x1 << 8  | /* start detect PAPB */
+			0x1 << 7  | /* add channel num */
 			0x4 << 4    /* chan status sel: pao pc/pd value */
 			);
 	} else {
-		if (channels % 2)
-			lane = channels / 2 + 1;
-		else
-			lane = channels / 2;
+		int lane, lane_mask = 0, i;
 
+		lane = (channels % 2) ? (channels / 2 + 1) : (channels / 2);
 		for (i = 0; i < lane; i++)
 			lane_mask |= (1 << i);
 
 		audiobus_update_bits(EE_AUDIO_FRHDMIRX_CTRL0,
-			0x1 << 30 | 0xf << 24 | 0x1 << 22 | 0x3 << 11,
+			0x1 << 30 | 0xf << 24 | 0x1 << 22 |
+			0x3 << 11 | 0x1 << 8 | 0x1 << 7 | 0x7 << 0,
 			0x1 << 30 | /* chnum_sel */
 			lane_mask << 24 | /* chnum_sel */
 			0x1 << 22 | /* clk_inv */
-			0x0 << 11  /* req_sel, Sync 4 spdifin by which */
+			0x0 << 11 | /* req_sel, Sync 4 spdifin by which */
+			0x1 << 8  | /* start detect PAPB */
+			0x1 << 7  | /* add channel num*/
+			0x6 << 0    /* channel status*/
 			);
 	}
 	/* nonpcm2pcm_th */
@@ -158,6 +134,35 @@ void frhdmirx_clr_PAO_irq_bits(void)
 		0x0 << INT_PAO_PAPB_MASK | 0x0 << INT_PAO_PCPD_MASK);
 }
 
+void frhdmirx_clr_SPDIF_irq_bits(void)
+{
+	unsigned int value = audiobus_read(EE_AUDIO_FRHDMIRX_STAT0);
+	unsigned int clr_mask = audiobus_read(EE_AUDIO_FRHDMIRX_CTRL4);
+	unsigned int reg = 0;
+	int i;
+
+	reg = clr_mask | value;
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, reg);
+
+	reg = clr_mask & (~value);
+	audiobus_write(EE_AUDIO_FRHDMIRX_CTRL4, reg);
+
+	/*compressed audio only transfer through lane0*/
+	for (i = 0; i < 1; i++) {
+		/*nonpcm2pcm irq, clear papb/pcpd/nonpcm*/
+		if (value & (0x20 << 8 * i)) {
+			audiobus_update_bits(
+				EE_AUDIO_FRHDMIRX_CTRL3,
+				0xf << 8 * i, 0xf << 8 * i);
+			audiobus_update_bits(
+				EE_AUDIO_FRHDMIRX_CTRL3,
+				0xf << 8 * i, 0x0 << 8 * i);
+			pr_info("raw to pcm change: irq status:%x, lane: %d\n",
+				value, i);
+		}
+	}
+}
+
 unsigned int frhdmirx_get_ch_status0to31(void)
 {
 	return (unsigned int)audiobus_read(EE_AUDIO_FRHDMIRX_STAT0);
@@ -170,3 +175,4 @@ unsigned int frhdmirx_get_chan_status_pc(void)
 	val = audiobus_read(EE_AUDIO_FRHDMIRX_STAT1);
 	return (val >> 16) & 0xff;
 }
+
diff --git a/sound/soc/amlogic/auge/frhdmirx_hw.h b/sound/soc/amlogic/auge/frhdmirx_hw.h
index 7c83dd01c704..6b336cda7c66 100644
--- a/sound/soc/amlogic/auge/frhdmirx_hw.h
+++ b/sound/soc/amlogic/auge/frhdmirx_hw.h
@@ -20,10 +20,13 @@
 #define INT_PAO_PAPB_MASK    24
 #define INT_PAO_PCPD_MASK    16
 
-extern void frhdmirx_enable(bool enable);
-extern void frhdmirx_src_select(int src);
-extern void frhdmirx_ctrl(int channels, int src);
-extern void frhdmirx_clr_PAO_irq_bits(void);
-extern unsigned int frhdmirx_get_ch_status0to31(void);
-extern unsigned int frhdmirx_get_chan_status_pc(void);
+void frhdmirx_enable(bool enable);
+void frhdmirx_src_select(int src);
+void frhdmirx_ctrl(int channels, int src);
+void frhdmirx_clr_PAO_irq_bits(void);
+void frhdmirx_clr_SPDIF_irq_bits(void);
+unsigned int frhdmirx_get_ch_status0to31(void);
+unsigned int frhdmirx_get_chan_status_pc(void);
+void frhdmirx_clr_all_irq_bits(void);
+
 #endif
diff --git a/sound/soc/amlogic/auge/g12a,clocks.c b/sound/soc/amlogic/auge/g12a,clocks.c
index 66131cf05242..808abc7b304e 100644
--- a/sound/soc/amlogic/auge/g12a,clocks.c
+++ b/sound/soc/amlogic/auge/g12a,clocks.c
@@ -22,8 +22,6 @@
 #include "audio_clks.h"
 #include "regs.h"
 
-static spinlock_t aclk_lock;
-
 static const char *const mclk_parent_names[] = {"mpll0", "mpll1",
 	"mpll2", "mpll3", "hifi_pll", "fclk_div3", "fclk_div4", "gp0_pll"};
 
diff --git a/sound/soc/amlogic/auge/iomap.c b/sound/soc/amlogic/auge/iomap.c
index 3ee30b7c0f92..8eac45ffa501 100644
--- a/sound/soc/amlogic/auge/iomap.c
+++ b/sound/soc/amlogic/auge/iomap.c
@@ -22,6 +22,7 @@
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
 
+#include "regs.h"
 #include "iomap.h"
 #include "audio_aed_reg_list.h"
 #include "audio_top_reg_list.h"
@@ -70,9 +71,8 @@ static void aml_snd_write(u32 base_type, unsigned int reg, unsigned int val)
 	pr_err("write snd reg %x error\n", reg);
 }
 
-static void aml_snd_update_bits(u32 base_type,
-			unsigned int reg, unsigned int mask,
-			unsigned int val)
+static void aml_snd_update_bits(u32 base_type, unsigned int reg,
+				unsigned int mask, unsigned int val)
 {
 	if (base_type < IO_MAX) {
 		unsigned int tmp, orig;
@@ -109,8 +109,8 @@ void aml_pdm_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(aml_pdm_write);
 
-void aml_pdm_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void aml_pdm_update_bits(unsigned int reg, unsigned int mask,
+			 unsigned int val)
 {
 	aml_snd_update_bits(IO_PDM_BUS, reg, mask, val);
 }
@@ -136,8 +136,8 @@ void audiobus_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(audiobus_write);
 
-void audiobus_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void audiobus_update_bits(unsigned int reg, unsigned int mask,
+			  unsigned int val)
 {
 	aml_snd_update_bits(IO_AUDIO_BUS, reg, mask, val);
 }
@@ -163,8 +163,8 @@ void audiolocker_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(audiolocker_write);
 
-void audiolocker_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void audiolocker_update_bits(unsigned int reg, unsigned int mask,
+			     unsigned int val)
 {
 	aml_snd_update_bits(IO_AUDIO_LOCKER, reg, mask, val);
 }
@@ -190,8 +190,8 @@ void eqdrc_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(eqdrc_write);
 
-void eqdrc_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void eqdrc_update_bits(unsigned int reg, unsigned int mask,
+		       unsigned int val)
 {
 	aml_snd_update_bits(IO_EQDRC_BUS, reg, mask, val);
 }
@@ -217,8 +217,8 @@ void audioreset_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(audioreset_write);
 
-void audioreset_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void audioreset_update_bits(unsigned int reg, unsigned int mask,
+			    unsigned int val)
 {
 	aml_snd_update_bits(IO_RESET, reg, mask, val);
 }
@@ -244,93 +244,47 @@ void vad_write(unsigned int reg, unsigned int val)
 }
 EXPORT_SYMBOL(vad_write);
 
-void vad_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void vad_update_bits(unsigned int reg, unsigned int mask,
+		     unsigned int val)
 {
 	aml_snd_update_bits(IO_VAD, reg, mask, val);
 }
 EXPORT_SYMBOL(vad_update_bits);
 
-int earcrx_cmdc_read(unsigned int reg)
+unsigned int new_resample_read(enum resample_idx id, unsigned int reg)
 {
-	int ret, val = 0;
+	unsigned int val = 0;
 
-	ret = aml_snd_read(IO_EARCRX_CMDC, reg, &val);
+	if (id == RESAMPLE_A)
+		val = readl((aml_snd_reg_map[IO_RESAMPLEA] +
+			    (reg << 2)));
+	else if (id == RESAMPLE_B)
+		val = readl((aml_snd_reg_map[IO_RESAMPLEB] +
+			    (reg << 2)));
 
-	if (ret) {
-		pr_err("read audio reg %x error %d\n", reg, ret);
-		return -1;
-	}
 	return val;
 }
-EXPORT_SYMBOL(earcrx_cmdc_read);
-
-void earcrx_cmdc_write(unsigned int reg, unsigned int val)
-{
-	aml_snd_write(IO_EARCRX_CMDC, reg, val);
-}
-EXPORT_SYMBOL(earcrx_cmdc_write);
-
-void earcrx_cmdc_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
-{
-	aml_snd_update_bits(IO_EARCRX_CMDC, reg, mask, val);
-}
-EXPORT_SYMBOL(earcrx_cmdc_update_bits);
-
-int earcrx_dmac_read(unsigned int reg)
-{
-	int ret, val = 0;
 
-	ret = aml_snd_read(IO_EARCRX_DMAC, reg, &val);
-
-	if (ret) {
-		pr_err("read audio reg %x error %d\n", reg, ret);
-		return -1;
-	}
-	return val;
-}
-EXPORT_SYMBOL(earcrx_dmac_read);
-
-void earcrx_dmac_write(unsigned int reg, unsigned int val)
-{
-	aml_snd_write(IO_EARCRX_DMAC, reg, val);
-}
-EXPORT_SYMBOL(earcrx_dmac_write);
-
-void earcrx_dmac_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
+void new_resample_write(enum resample_idx id, unsigned int reg,
+			unsigned int val)
 {
-	aml_snd_update_bits(IO_EARCRX_DMAC, reg, mask, val);
+	if (id == RESAMPLE_A)
+		writel(val, (aml_snd_reg_map[IO_RESAMPLEA] + (reg << 2)));
+	else if (id == RESAMPLE_B)
+		writel(val, (aml_snd_reg_map[IO_RESAMPLEB] + (reg << 2)));
 }
-EXPORT_SYMBOL(earcrx_dmac_update_bits);
 
-int earcrx_top_read(unsigned int reg)
+void new_resample_update_bits(enum resample_idx id, unsigned int reg,
+			      unsigned int mask, unsigned int val)
 {
-	int ret, val = 0;
+	unsigned int tmp, orig;
 
-	ret = aml_snd_read(IO_EARCRX_TOP, reg, &val);
+	orig = new_resample_read(id, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
 
-	if (ret) {
-		pr_err("read audio reg %x error %d\n", reg, ret);
-		return -1;
-	}
-	return val;
-}
-EXPORT_SYMBOL(earcrx_top_read);
-
-void earcrx_top_write(unsigned int reg, unsigned int val)
-{
-	aml_snd_write(IO_EARCRX_TOP, reg, val);
-}
-EXPORT_SYMBOL(earcrx_top_write);
-
-void earcrx_top_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val)
-{
-	aml_snd_update_bits(IO_EARCRX_TOP, reg, mask, val);
+	new_resample_write(id, reg, tmp);
 }
-EXPORT_SYMBOL(earcrx_top_update_bits);
 
 static int snd_iomap_probe(struct platform_device *pdev)
 {
diff --git a/sound/soc/amlogic/auge/iomap.h b/sound/soc/amlogic/auge/iomap.h
index 07b8b54c2d89..092998a70c44 100644
--- a/sound/soc/amlogic/auge/iomap.h
+++ b/sound/soc/amlogic/auge/iomap.h
@@ -18,6 +18,8 @@
 #ifndef __AML_SND_IOMAP_H__
 #define __AML_SND_IOMAP_H__
 
+#include "ddr_mngr.h"
+
 enum{
 	IO_PDM_BUS = 0,
 	IO_AUDIO_BUS,
@@ -25,53 +27,45 @@ enum{
 	IO_EQDRC_BUS,
 	IO_RESET,
 	IO_VAD,
-	IO_EARCRX_CMDC,
-	IO_EARCRX_DMAC,
-	IO_EARCRX_TOP,
-
+	IO_RESAMPLEA,
+	IO_RESAMPLEB,
 	IO_MAX,
 };
 
-extern int aml_pdm_read(unsigned int reg);
-extern void aml_pdm_write(unsigned int reg, unsigned int val);
-extern void aml_pdm_update_bits(unsigned int reg,
-	unsigned int mask, unsigned int val);
+int aml_pdm_read(unsigned int reg);
+void aml_pdm_write(unsigned int reg, unsigned int val);
+void aml_pdm_update_bits(unsigned int reg, unsigned int mask,
+			 unsigned int val);
+
+int audiobus_read(unsigned int reg);
+void audiobus_write(unsigned int reg, unsigned int val);
+void audiobus_update_bits(unsigned int reg, unsigned int mask,
+			  unsigned int val);
 
-extern int audiobus_read(unsigned int reg);
-extern void audiobus_write(unsigned int reg, unsigned int val);
-extern void audiobus_update_bits(unsigned int reg,
-	unsigned int mask, unsigned int val);
+int audiolocker_read(unsigned int reg);
+void audiolocker_write(unsigned int reg, unsigned int val);
+void audiolocker_update_bits(unsigned int reg, unsigned int mask,
+			     unsigned int val);
 
-extern int audiolocker_read(unsigned int reg);
-extern void audiolocker_write(unsigned int reg, unsigned int val);
-extern void audiolocker_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
+int eqdrc_read(unsigned int reg);
+void eqdrc_write(unsigned int reg, unsigned int val);
+void eqdrc_update_bits(unsigned int reg, unsigned int mask,
+		       unsigned int val);
 
-extern int eqdrc_read(unsigned int reg);
-extern void eqdrc_write(unsigned int reg, unsigned int val);
-extern void eqdrc_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
+int audioreset_read(unsigned int reg);
+void audioreset_write(unsigned int reg, unsigned int val);
+void audioreset_update_bits(unsigned int reg, unsigned int mask,
+			    unsigned int val);
 
-extern int audioreset_read(unsigned int reg);
-extern void audioreset_write(unsigned int reg, unsigned int val);
-extern void audioreset_update_bits(unsigned int reg,
-	unsigned int mask, unsigned int val);
+int vad_read(unsigned int reg);
+void vad_write(unsigned int reg, unsigned int val);
+void vad_update_bits(unsigned int reg, unsigned int mask,
+		     unsigned int val);
 
-extern int vad_read(unsigned int reg);
-extern void vad_write(unsigned int reg, unsigned int val);
-extern void vad_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
+unsigned int new_resample_read(enum resample_idx id, unsigned int reg);
+void new_resample_write(enum resample_idx id, unsigned int reg,
+			unsigned int val);
+void new_resample_update_bits(enum resample_idx id, unsigned int reg,
+			      unsigned int mask, unsigned int val);
 
-extern int earcrx_cmdc_read(unsigned int reg);
-extern void earcrx_cmdc_write(unsigned int reg, unsigned int val);
-extern void earcrx_cmdc_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
-extern int earcrx_dmac_read(unsigned int reg);
-extern void earcrx_dmac_write(unsigned int reg, unsigned int val);
-extern void earcrx_dmac_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
-extern int earcrx_top_read(unsigned int reg);
-extern void earcrx_top_write(unsigned int reg, unsigned int val);
-extern void earcrx_top_update_bits(unsigned int reg,
-		unsigned int mask, unsigned int val);
 #endif
diff --git a/sound/soc/amlogic/auge/locker.c b/sound/soc/amlogic/auge/locker.c
index d41cc4ab6ca7..6a6fa3f91266 100644
--- a/sound/soc/amlogic/auge/locker.c
+++ b/sound/soc/amlogic/auge/locker.c
@@ -182,10 +182,8 @@ static DEVICE_ATTR(locker_enable, 0644,
 
 void audio_locker_set(int enable)
 {
-	if (!s_locker) {
-		pr_debug("audio locker is not init\n");
+	if (!s_locker)
 		return;
-	}
 
 	s_locker->enable = enable;
 	audiolocker_init(s_locker);
@@ -193,10 +191,8 @@ void audio_locker_set(int enable)
 
 int audio_locker_get(void)
 {
-	if (!s_locker) {
-		pr_debug("audio locker is not init\n");
-		return -1;
-	}
+	if (!s_locker)
+		return 0;
 
 	return s_locker->enable;
 }
diff --git a/sound/soc/amlogic/auge/loopback.c b/sound/soc/amlogic/auge/loopback.c
index d5a325e93627..99ca3f81051f 100644
--- a/sound/soc/amlogic/auge/loopback.c
+++ b/sound/soc/amlogic/auge/loopback.c
@@ -23,12 +23,17 @@
 
 #include <sound/pcm_params.h>
 
+#include <linux/amlogic/pm.h>
+
 #include "loopback.h"
 #include "loopback_hw.h"
 #include "loopback_match_table.c"
 #include "ddr_mngr.h"
 #include "tdm_hw.h"
 #include "pdm_hw.h"
+#include "resample.h"
+
+#include "vad.h"
 
 #define DRV_NAME "loopback"
 
@@ -586,7 +591,10 @@ static int loopback_set_ctrl(struct loopback *p_loopback, int bitwidth)
 	datalb_cfg.type        = datalb_toddr_type;
 	datalb_cfg.m           = datalb_msb;
 	datalb_cfg.n           = datalb_lsb;
-	datalb_cfg.datalb_src  = p_loopback->datalb_src;
+	datalb_cfg.datalb_src  = 0; /* todo: tdmin_LB */
+	/* get resample B status */
+	datalb_cfg.resample_enable =
+		(unsigned int)get_resample_enable(RESAMPLE_B);
 
 	if (p_loopback->chipinfo) {
 		datain_cfg.ch_ctrl_switch = p_loopback->chipinfo->ch_ctrl;
@@ -646,6 +654,10 @@ static int loopback_dai_prepare(
 		struct toddr_fmt fmt;
 		unsigned int src;
 
+		if (vad_lb_is_running(p_loopback->id) &&
+		    pm_audio_is_suspend())
+			return 0;
+
 		if (p_loopback->id == 0)
 			src = LOOPBACK_A;
 		else
@@ -746,6 +758,15 @@ static int loopback_dai_trigger(
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (ss->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			if (vad_lb_is_running(p_loopback->id) &&
+			    pm_audio_is_suspend()) {
+				pm_audio_set_suspend(false);
+				/* VAD switch to alsa buffer */
+				vad_update_buffer(0);
+				audio_toddr_irq_enable(p_loopback->tddr, true);
+				break;
+			}
+
 			dev_info(ss->pcm->card->dev, "Loopback Capture enable\n");
 
 			pdm_fifo_reset();
@@ -766,6 +787,14 @@ static int loopback_dai_trigger(
 		if (ss->stream == SNDRV_PCM_STREAM_CAPTURE) {
 			bool toddr_stopped = false;
 
+			if (vad_lb_is_running(p_loopback->id) &&
+			    pm_audio_is_suspend()) {
+				/* switch to VAD buffer */
+				vad_update_buffer(1);
+				audio_toddr_irq_enable(p_loopback->tddr, false);
+				break;
+			}
+
 			pdm_enable(0);
 
 			/* loopback */
@@ -1472,6 +1501,45 @@ static int loopback_platform_probe(struct platform_device *pdev)
 		&loopback_platform_drv);
 }
 
+static int loopback_platform_suspend(
+	struct platform_device *pdev, pm_message_t state)
+{
+	struct loopback *p_loopback = dev_get_drvdata(&pdev->dev);
+
+	pr_info("%s\n", __func__);
+
+	/* whether in freeze */
+	if (is_pm_freeze_mode() &&
+	    vad_lb_is_running(p_loopback->id)) {
+		lb_set_chnum_en(p_loopback->id, true);
+		vad_lb_force_two_channel(true);
+
+		pr_info("%s, Entry in freeze, p_loopback:%p\n",
+			__func__, p_loopback);
+	}
+
+	return 0;
+}
+
+static int loopback_platform_resume(
+	struct platform_device *pdev)
+{
+	struct loopback *p_loopback = dev_get_drvdata(&pdev->dev);
+
+	pr_info("%s\n", __func__);
+
+	/* whether in freeze mode */
+	if (is_pm_freeze_mode() &&
+	    vad_lb_is_running(p_loopback->id)) {
+		pr_info("%s, Exist from freeze, p_loopback:%p\n",
+			__func__, p_loopback);
+		lb_set_chnum_en(p_loopback->id, false);
+		vad_lb_force_two_channel(false);
+	}
+
+	return 0;
+}
+
 static struct platform_driver loopback_platform_driver = {
 	.driver = {
 		.name           = DRV_NAME,
@@ -1479,6 +1547,8 @@ static struct platform_driver loopback_platform_driver = {
 		.of_match_table = of_match_ptr(loopback_device_id),
 	},
 	.probe  = loopback_platform_probe,
+	.suspend = loopback_platform_suspend,
+	.resume  = loopback_platform_resume,
 };
 module_platform_driver(loopback_platform_driver);
 
diff --git a/sound/soc/amlogic/auge/loopback_hw.c b/sound/soc/amlogic/auge/loopback_hw.c
index 6b64e9863cce..5fadd77676f5 100644
--- a/sound/soc/amlogic/auge/loopback_hw.c
+++ b/sound/soc/amlogic/auge/loopback_hw.c
@@ -22,8 +22,7 @@
 #include "regs.h"
 #include "iomap.h"
 
-static unsigned int
-get_tdmin_id_from_lb_src(enum datalb_src lb_src)
+static unsigned int get_tdmin_id_from_lb_src(enum datalb_src lb_src)
 {
 	return lb_src % TDMINLB_PAD_TDMINA;
 }
@@ -186,8 +185,9 @@ void lb_set_datalb_cfg(int id, struct data_cfg *datalb_cfg)
 
 	if (datalb_cfg->ch_ctrl_switch) {
 		audiobus_update_bits(reg,
-			0x1 << 29 | 0x7 << 13 | 0x1f << 8
-			| 0x1f << 3 | 0x1 << 1,
+			0x3 << 30 | 0x1 << 29 | 0x7 << 13 |
+			0x1f << 8 | 0x1f << 3 | 0x1 << 1,
+			datalb_cfg->resample_enable << 30 |
 			datalb_cfg->ext_signed << 29 |
 			datalb_cfg->type       << 13 |
 			datalb_cfg->m          << 8  |
@@ -220,3 +220,11 @@ void lb_enable(int id, bool enable)
 
 	audiobus_update_bits(reg, 0x1 << 31, enable << 31);
 }
+
+void lb_set_chnum_en(int id, bool en)
+{
+	int offset = EE_AUDIO_LB_B_CTRL0 - EE_AUDIO_LB_A_CTRL0;
+	int reg = EE_AUDIO_LB_A_CTRL0 + offset * id;
+
+	audiobus_update_bits(reg, 0x1 << 27, en << 27);
+}
diff --git a/sound/soc/amlogic/auge/loopback_hw.h b/sound/soc/amlogic/auge/loopback_hw.h
index b88c0607bf4f..5cb10dc6c750 100644
--- a/sound/soc/amlogic/auge/loopback_hw.h
+++ b/sound/soc/amlogic/auge/loopback_hw.h
@@ -45,6 +45,9 @@ struct data_cfg {
 
 	/* channel and mask in new ctrol register */
 	bool ch_ctrl_switch;
+
+	/* enable resample B for loopback*/
+	unsigned int resample_enable;
 };
 
 void tdminlb_set_clk(enum datalb_src lb_src,
@@ -70,4 +73,6 @@ extern void lb_set_datalb_cfg(int id, struct data_cfg *datalb_cfg);
 
 extern void lb_enable(int id, bool enable);
 
+void lb_set_chnum_en(int id, bool en);
+
 #endif
diff --git a/sound/soc/amlogic/auge/pdm.c b/sound/soc/amlogic/auge/pdm.c
index b1c3e5787fe9..f03660c954e2 100644
--- a/sound/soc/amlogic/auge/pdm.c
+++ b/sound/soc/amlogic/auge/pdm.c
@@ -944,6 +944,7 @@ static int aml_pdm_dai_trigger(
 			pm_audio_set_suspend(false);
 			/* VAD switch to alsa buffer */
 			vad_update_buffer(0);
+			audio_toddr_irq_enable(p_pdm->tddr, true);
 			break;
 		}
 
@@ -966,6 +967,7 @@ static int aml_pdm_dai_trigger(
 				&& pm_audio_is_suspend()) {
 				/* switch to VAD buffer */
 				vad_update_buffer(1);
+				audio_toddr_irq_enable(p_pdm->tddr, false);
 				break;
 			}
 			pdm_enable(0);
diff --git a/sound/soc/amlogic/auge/pdm_hw.c b/sound/soc/amlogic/auge/pdm_hw.c
index fd5116b9c194..b05e84b132b5 100644
--- a/sound/soc/amlogic/auge/pdm_hw.c
+++ b/sound/soc/amlogic/auge/pdm_hw.c
@@ -24,7 +24,7 @@
 #include "pdm_hw.h"
 #include "regs.h"
 #include "iomap.h"
-#include "pdm_hw_coeff.c"
+#include "pdm_hw_coeff.h"
 
 static DEFINE_SPINLOCK(pdm_lock);
 static unsigned long pdm_enable_cnt;
diff --git a/sound/soc/amlogic/auge/pdm_hw_coeff.c b/sound/soc/amlogic/auge/pdm_hw_coeff.h
similarity index 99%
rename from sound/soc/amlogic/auge/pdm_hw_coeff.c
rename to sound/soc/amlogic/auge/pdm_hw_coeff.h
index b44ba53f1e74..5b4195cbef48 100644
--- a/sound/soc/amlogic/auge/pdm_hw_coeff.c
+++ b/sound/soc/amlogic/auge/pdm_hw_coeff.h
@@ -1,5 +1,5 @@
 /*
- * sound/soc/amlogic/auge/pdm_hw_coeff.c
+ * sound/soc/amlogic/auge/pdm_hw_coeff.h
  *
  * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
  *
@@ -20,6 +20,9 @@
  * For filter 2, it's only relative with osr and hcic stage number
  */
 
+#ifndef __PDM_HW_COEFF_H__
+#define __PDM_HW_COEFF_H__
+
 static const int lpf2_osr64[]  = {
 	0x00050a, 0xfff004, 0x0002c1, 0x003c12, 0xffa818,
 	0xffc87d, 0x010aef, 0xff5223, 0xfebd93, 0x028f41,
@@ -274,3 +277,5 @@ static const int lpf3_mode4[] = {
 	0x018208, 0xfedaef, 0xff25e9, 0x009ddb, 0x006ded,
 	0xffb7a1, 0xffd46b
 };
+
+#endif
diff --git a/sound/soc/amlogic/auge/regs.h b/sound/soc/amlogic/auge/regs.h
index 7a53e59905ee..6bb0a01cb2dc 100644
--- a/sound/soc/amlogic/auge/regs.h
+++ b/sound/soc/amlogic/auge/regs.h
@@ -1161,5 +1161,38 @@ struct register_table {
 #define EARCTX_ANA_CTRL1                   0x006
 #define EARCTX_ANA_CTRL2                   0x007
 #define EARCTX_ANA_STAT0                   0x008
+/* new resample */
+#define AUDIO_RSAMP_CTRL0                  0x000
+#define AUDIO_RSAMP_CTRL1                  0x001
+#define AUDIO_RSAMP_CTRL2                  0x002
+#define AUDIO_RSAMP_PHSINIT                0x003
+#define AUDIO_RSAMP_PHSSTEP                0x004
+#define AUDIO_RSAMP_SHIFT                  0x005
+#define AUDIO_RSAMP_ADJ_CTRL0              0x006
+#define AUDIO_RSAMP_ADJ_CTRL1              0x007
+#define AUDIO_RSAMP_ADJ_SFT                0x008
+#define AUDIO_RSAMP_ADJ_IDET_LEN           0x009
+#define AUDIO_RSAMP_ADJ_FORCE              0x00a
+#define AUDIO_RSAMP_ADJ_KI_FORCE           0x00b
+#define AUDIO_RSAMP_RO_STATUS              0x010
+#define AUDIO_RSAMP_RO_ADJ_FREQ            0x011
+#define AUDIO_RSAMP_RO_ADJ_DIFF_BAK        0x012
+#define AUDIO_RSAMP_RO_ADJ_DIFF_DLT        0x013
+#define AUDIO_RSAMP_RO_ADJ_PHS_ERR         0x014
+#define AUDIO_RSAMP_RO_ADJ_KI_OUT          0x015
+#define AUDIO_RSAMP_RO_IN_CNT              0x016
+#define AUDIO_RSAMP_RO_OUT_CNT             0x017
+#define AUDIO_RSAMP_POST_COEF0             0x020
+#define AUDIO_RSAMP_POST_COEF1             0x021
+#define AUDIO_RSAMP_POST_COEF2             0x022
+#define AUDIO_RSAMP_POST_COEF3             0x023
+#define AUDIO_RSAMP_POST_COEF4             0x024
+#define AUDIO_RSAMP_AA_COEF_ADDR           0x030
+#define AUDIO_RSAMP_AA_COEF_DATA           0x031
+#define AUDIO_RSAMP_SINC_COEF_ADDR         0x040
+#define AUDIO_RSAMP_SINC_COEF_DATA         0x041
+
+/*HHI bus*/
+#define HHI_AUDIO_MEM_PD_REG0              0x045
 
 #endif
diff --git a/sound/soc/amlogic/auge/resample.c b/sound/soc/amlogic/auge/resample.c
index dab9788fbac6..2bf14fb7a593 100644
--- a/sound/soc/amlogic/auge/resample.c
+++ b/sound/soc/amlogic/auge/resample.c
@@ -23,12 +23,15 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/amlogic/iomap.h>
+
 #include <sound/soc.h>
 #include <sound/tlv.h>
 
-#include "resample.h"
 #include "regs.h"
 #include "iomap.h"
+#include "resample.h"
+#include "resample_hw.h"
 
 #define DRV_NAME "audioresample"
 
@@ -36,14 +39,12 @@
 
 /*#define __PTM_RESAMPLE_CLK__*/
 
-//#define RESAMPLE_A    0
-//#define RESAMPLE_B    1
-
 struct resample_chipinfo {
-	int num;    /* support resample a/b */
+	int num; /* support resample a/b */
 	enum resample_idx id;
 
 	bool dividor_fn;
+	int resample_version;
 };
 
 struct audioresample {
@@ -60,13 +61,13 @@ struct audioresample {
 
 	enum resample_idx id;
 
-	/*which module should be resampled */
+	/* which module should be resampled */
 	enum toddr_src resample_module;
-	/*  resample to the rate */
+	/* resample to the rate */
 	int out_rate;
 
 	/* sync with auge_resample_texts */
-	enum samplerate_index asrc_rate_idx;
+	enum samplerate_index asrc_in_sr_idx;
 
 	bool enable;
 };
@@ -81,10 +82,8 @@ struct audioresample *get_audioresample(enum resample_idx id)
 
 	p_resample = ((id == RESAMPLE_A) ? s_resample_a : s_resample_b);
 
-	if (!p_resample) {
-		pr_debug("Not init audio resample\n");
+	if (!p_resample)
 		return NULL;
-	}
 
 	return p_resample;
 }
@@ -99,60 +98,62 @@ int get_resample_module_num(void)
 	return 1;
 }
 
-int set_resample_source(enum resample_idx id, enum toddr_src src)
+int get_resample_version_id(enum resample_idx id)
 {
-	struct audioresample *p_resample = get_audioresample(id);
-	(void)p_resample;
-	(void)src;
-	//p_resample->resample_module = src;
-	return 0;
+	struct audioresample *p_resample;
+
+	p_resample = ((id == RESAMPLE_A) ? s_resample_a : s_resample_b);
+
+	if (!p_resample || !p_resample->chipinfo) {
+		pr_debug("Not init audio resample\n");
+		return -1;
+	}
+
+	return p_resample->chipinfo->resample_version;
 }
 
-static int set_resample_rate_index(
-		enum resample_idx id, enum samplerate_index index)
+bool get_resample_enable(enum resample_idx id)
 {
-	struct audioresample *p_resample = get_audioresample(id);
+	struct audioresample *p_resample;
 
-	p_resample->asrc_rate_idx = index;
-	return 0;
+	p_resample = ((id == RESAMPLE_A) ? s_resample_a : s_resample_b);
+
+	if (!p_resample) {
+		pr_debug("Not init audio resample\n");
+		return 0;
+	}
+
+	return p_resample->enable;
 }
 
-static enum samplerate_index get_resample_rate_index(
-		enum resample_idx id)
+int set_resample_source(enum resample_idx id, enum toddr_src src)
 {
 	struct audioresample *p_resample = get_audioresample(id);
 
-	return p_resample->asrc_rate_idx;
+	(void)p_resample;
+	(void)src;
+	//p_resample->resample_module = src;
+	return 0;
 }
 
-static int resample_clk_set(struct audioresample *p_resample)
+static int resample_clk_set(struct audioresample *p_resample, int output_sr)
 {
 	int ret = 0;
 
-	/* enable clock */
-	if (p_resample->enable) {
-
-		/* defaule tdm out mclk to resample clk */
-		clk_set_rate(p_resample->pll, 48000 * CLK_RATIO * 2);
-		clk_set_rate(p_resample->sclk, 48000 * CLK_RATIO);
-		clk_set_rate(p_resample->clk, 48000 * CLK_RATIO);
+	/* defaule tdm out mclk to resample clk */
+	clk_set_rate(p_resample->pll, output_sr * CLK_RATIO * 2);
+	clk_set_rate(p_resample->sclk, output_sr * CLK_RATIO);
+	clk_set_rate(p_resample->clk, output_sr * CLK_RATIO);
 
-		pr_info("%s, resample_pll:%lu, sclk:%lu, clk:%lu\n",
-			__func__,
-			clk_get_rate(p_resample->pll),
-			clk_get_rate(p_resample->sclk),
-			clk_get_rate(p_resample->clk));
-	}
+	pr_info("%s, resample_pll:%lu, sclk:%lu, clk:%lu\n",
+		__func__,
+		clk_get_rate(p_resample->pll),
+		clk_get_rate(p_resample->sclk),
+		clk_get_rate(p_resample->clk));
 
 	return ret;
 }
 
-static void audio_resample_init(struct audioresample *p_resample)
-{
-	aml_set_resample(p_resample->id, p_resample->enable,
-		p_resample->resample_module);
-}
-
 static int audio_resample_set(
 	struct audioresample *p_resample,
 	bool enable, int rate)
@@ -162,7 +163,9 @@ static int audio_resample_set(
 
 	p_resample->enable = enable;
 	p_resample->out_rate = rate;
-	audio_resample_init(p_resample);
+	aml_set_resample(
+		p_resample->id, p_resample->enable,
+		p_resample->resample_module);
 
 	return 0;
 }
@@ -176,6 +179,7 @@ static const char *const auge_resample_texts[] = {
 	"Enable:96K",
 	"Enable:176K",
 	"Enable:192K",
+	"Enable:16K",
 };
 
 static int resample_idx2rate(enum samplerate_index index)
@@ -198,6 +202,8 @@ static int resample_idx2rate(enum samplerate_index index)
 		rate = 176400;
 	else if (index == RATE_192K)
 		rate = 192000;
+	else if (index == RATE_16K)
+		rate = 16000;
 
 	return rate;
 }
@@ -211,68 +217,72 @@ static int resample_get_enum(
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct audioresample *p_resample = snd_kcontrol_chip(kcontrol);
+	int resample_enable = 0;
 
-	if (!p_resample) {
+	if (!p_resample || !p_resample->chipinfo) {
 		pr_debug("audio resample is not init\n");
 		return 0;
 	}
 
-	ucontrol->value.enumerated.item[0] = p_resample->asrc_rate_idx;
+	if (p_resample->chipinfo->resample_version == 1)
+		resample_enable = new_resample_get_status(p_resample->id);
+	else if (p_resample->chipinfo->resample_version == 0)
+		resample_enable = resample_get_status(p_resample->id);
+
+	if (resample_enable)
+		ucontrol->value.enumerated.item[0] = p_resample->asrc_in_sr_idx;
+	else
+		ucontrol->value.enumerated.item[0] = RATE_OFF;
 
 	return 0;
 }
 
 /* force set to new rate index whatever the resampler holds */
-int resample_set(enum resample_idx id, enum samplerate_index index, bool force)
+int resample_set(enum resample_idx id, enum samplerate_index index)
 {
 	int resample_rate = 0;
 	struct audioresample *p_resample = get_audioresample(id);
 	int ret = 0;
 
-	if (!p_resample)
+	if (!p_resample || !p_resample->chipinfo)
 		return 0;
 
-	if (index < RATE_OFF || index > RATE_192K) {
+	if (index < RATE_OFF || index >= RATE_MAX) {
 		pr_err("%s(), invalid index %d\n", __func__, index);
 		return 0;
 	}
 
-	if (index == p_resample->asrc_rate_idx && !force)
-		return 0;
+	p_resample->asrc_in_sr_idx = index;
 
 	pr_info("%s resample_%c to %s, last %s\n",
 		__func__,
 		(id == RESAMPLE_A) ? 'a' : 'b',
 		auge_resample_texts[index],
-		auge_resample_texts[p_resample->asrc_rate_idx]);
-
-	set_resample_rate_index(id, index);
+		auge_resample_texts[p_resample->asrc_in_sr_idx]);
 
 	resample_rate = resample_idx2rate(index);
-	ret = audio_resample_set(p_resample, (bool)index, resample_rate);
+	ret = audio_resample_set(p_resample, index, resample_rate);
 	if (ret)
 		return ret;
 
-	if (index == RATE_OFF)
-		resample_disable(p_resample->id);
-	else {
-		resample_init(p_resample->id, resample_rate);
-
-		resample_set_hw_param(p_resample->id, index);
+	if (index == RATE_OFF) {
+		if (p_resample->chipinfo->resample_version == 1)
+			new_resample_enable(p_resample->id, false);
+		else if (p_resample->chipinfo->resample_version == 0)
+			resample_enable(p_resample->id, false);
+	} else {
+		if (p_resample->chipinfo->resample_version == 1) {
+			new_resample_set_ratio(id, resample_rate,
+					       DEFAULT_SPK_SAMPLERATE);
+		} else if (p_resample->chipinfo->resample_version == 0) {
+			resample_init(p_resample->id, resample_rate);
+			resample_set_hw_param(p_resample->id, index);
+		}
 	}
 
 	return 0;
 }
 
-int resample_set_inner_rate(enum resample_idx id)
-{
-	enum samplerate_index index = get_resample_rate_index(id);
-
-	pr_debug("%s() index %d\n", __func__, id);
-
-	return resample_set(id, index, true);
-}
-
 static int resample_set_enum(
 	struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
@@ -285,8 +295,10 @@ static int resample_set_enum(
 		return 0;
 	}
 
-	set_resample_rate_index(p_resample->id, index);
-	resample_set_inner_rate(p_resample->id);
+	if (index == p_resample->asrc_in_sr_idx)
+		return 0;
+
+	resample_set(p_resample->id, index);
 
 	return 0;
 }
@@ -396,6 +408,7 @@ static int resample_module_set_enum(
 
 	return 0;
 }
+
 static const struct snd_kcontrol_new asrc_a_controls[] = {
 	SOC_ENUM_EXT("Hardware resample enable",
 		     auge_resample_enum,
@@ -434,26 +447,53 @@ static const struct snd_kcontrol_new asrc_b_controls[] = {
 		     resample_module_set_enum),
 };
 
+static const struct snd_kcontrol_new rsamp_a_controls[] = {
+	SOC_ENUM_EXT("Hardware resample enable",
+		     auge_resample_enum,
+		     resample_get_enum,
+		     resample_set_enum),
+	SOC_ENUM_EXT("Hw resample module",
+		     auge_resample_module_enum,
+		     resample_module_get_enum,
+		     resample_module_set_enum),
+};
+
 int card_add_resample_kcontrols(struct snd_soc_card *card)
 {
 	unsigned int idx;
-	int err;
-
-	if (s_resample_a) {
-		for (idx = 0; idx < ARRAY_SIZE(asrc_a_controls); idx++) {
-			err = snd_ctl_add(card->snd_card,
+	int err = 0;
+
+	if (s_resample_a && s_resample_a->chipinfo) {
+		if (s_resample_a->chipinfo->resample_version == 1) {
+			for (idx = 0; idx < ARRAY_SIZE(rsamp_a_controls);
+				idx++) {
+				err = snd_ctl_add(
+					card->snd_card,
+					snd_ctl_new1(&rsamp_a_controls[idx],
+						     s_resample_a));
+			}
+		} else if (s_resample_a->chipinfo->resample_version == 0) {
+			for (idx = 0; idx < ARRAY_SIZE(asrc_a_controls);
+				idx++) {
+				err = snd_ctl_add(
+					card->snd_card,
 					snd_ctl_new1(&asrc_a_controls[idx],
-						s_resample_a));
-			if (err < 0)
-				return err;
+						     s_resample_a));
+			}
 		}
+		if (err < 0)
+			return err;
 	}
 
-	if (s_resample_b) {
-		for (idx = 0; idx < ARRAY_SIZE(asrc_b_controls); idx++) {
-			err = snd_ctl_add(card->snd_card,
+	if (s_resample_b && s_resample_b->chipinfo) {
+		if (s_resample_b->chipinfo->resample_version == 0) {
+			for (idx = 0; idx < ARRAY_SIZE(asrc_b_controls);
+				idx++) {
+				err = snd_ctl_add(
+					card->snd_card,
 					snd_ctl_new1(&asrc_b_controls[idx],
-						s_resample_b));
+						     s_resample_b));
+			}
 			if (err < 0)
 				return err;
 		}
@@ -462,20 +502,69 @@ int card_add_resample_kcontrols(struct snd_soc_card *card)
 	return 0;
 }
 
+static int new_resample_init(struct audioresample *p_resample)
+{
+	if (!p_resample)
+		return -ENOMEM;
+
+	pr_info("%s: Start init new resample %s parameters!\n",
+		__func__, (p_resample->id == RESAMPLE_A) ? "A" : "B");
+
+	p_resample->enable = 1;
+	new_resample_init_param(p_resample->id);
+
+	if (p_resample->id == RESAMPLE_A) {
+		/* default resample A for tv input source */
+		new_resample_set_ratio(p_resample->id,
+				       DEFAULT_SPK_SAMPLERATE,
+				       DEFAULT_SPK_SAMPLERATE);
+		/*set resample clk to default 256fs mclk.*/
+		/*the same clk source with tdm*/
+		resample_clk_set(p_resample, DEFAULT_SPK_SAMPLERATE);
+	} else if (p_resample->id == RESAMPLE_B) {
+		/* default resample B for loopback downsample */
+		new_resample_set_ratio(p_resample->id,
+				       DEFAULT_SPK_SAMPLERATE,
+				       DEFAULT_MIC_SAMPLERATE);
+		/*set resample clk to default 256fs mclk.*/
+		/*the same clk source with TDMINLB*/
+		resample_clk_set(p_resample, DEFAULT_MIC_SAMPLERATE);
+	}
+
+	return 0;
+}
+
 static struct resample_chipinfo g12a_resample_chipinfo = {
 	.dividor_fn = true,
+	.resample_version = 0,
 };
 
 static struct resample_chipinfo tl1_resample_a_chipinfo = {
 	.num        = 2,
 	.id         = RESAMPLE_A,
 	.dividor_fn = true,
+	.resample_version = 0,
 };
 
 static struct resample_chipinfo tl1_resample_b_chipinfo = {
 	.num        = 2,
 	.id         = RESAMPLE_B,
 	.dividor_fn = true,
+	.resample_version = 0,
+};
+
+static struct resample_chipinfo sm1_resample_a_chipinfo = {
+	.num        = 2,
+	.id         = RESAMPLE_A,
+	.dividor_fn = true,
+	.resample_version = 1,
+};
+
+static struct resample_chipinfo sm1_resample_b_chipinfo = {
+	.num        = 2,
+	.id         = RESAMPLE_B,
+	.dividor_fn = true,
+	.resample_version = 1,
 };
 
 static const struct of_device_id resample_device_id[] = {
@@ -494,6 +583,14 @@ static const struct of_device_id resample_device_id[] = {
 		.compatible = "amlogic, tl1-resample-b",
 		.data = &tl1_resample_b_chipinfo,
 	},
+	{
+		.compatible = "amlogic, sm1-resample-a",
+		.data = &sm1_resample_a_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-resample-b",
+		.data = &sm1_resample_b_chipinfo,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, resample_device_id);
@@ -526,11 +623,15 @@ static int resample_platform_probe(struct platform_device *pdev)
 
 	p_resample->chipinfo = p_chipinfo;
 
-	ret = of_property_read_u32(pdev->dev.of_node, "resample_module",
-			&resample_module);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Can't retrieve resample_module\n");
-		return -EINVAL;
+	if (p_chipinfo->id == 0) {
+		ret = of_property_read_u32(pdev->dev.of_node, "resample_module",
+					   &resample_module);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Can't retrieve resample_module\n");
+			return -EINVAL;
+		}
+	} else {
+		resample_module = LOOPBACK_A;
 	}
 
 	/* config from dts */
@@ -580,10 +681,6 @@ static int resample_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/*set resample clk to default 256fs mclk.*/
-	/*the same clk source with tdm*/
-	resample_clk_set(p_resample);
-
 	p_resample->dev = dev;
 
 	if (p_chipinfo && p_chipinfo->id == 1)
@@ -591,10 +688,21 @@ static int resample_platform_probe(struct platform_device *pdev)
 	else
 		s_resample_a = p_resample;
 
+	if (p_chipinfo && p_chipinfo->resample_version == 1)
+		new_resample_init(p_resample);
+	else if (p_chipinfo && p_chipinfo->resample_version == 0)
+		resample_clk_set(p_resample, DEFAULT_SPK_SAMPLERATE);
+
+	aml_set_resample(p_resample->id, p_resample->enable,
+			 p_resample->resample_module);
+
+	pr_info("resample id = %d, new resample = %d, resample_module = %d\n",
+		p_chipinfo->id, p_chipinfo->resample_version,
+		p_resample->resample_module);
+
 	return 0;
 }
 
-
 static struct platform_driver resample_platform_driver = {
 	.driver = {
 		.name  = DRV_NAME,
diff --git a/sound/soc/amlogic/auge/resample.h b/sound/soc/amlogic/auge/resample.h
index c9735221e999..71fb209f3132 100644
--- a/sound/soc/amlogic/auge/resample.h
+++ b/sound/soc/amlogic/auge/resample.h
@@ -19,17 +19,18 @@
 
 #include "resample_hw.h"
 
-extern int card_add_resample_kcontrols(struct snd_soc_card *card);
+int card_add_resample_kcontrols(struct snd_soc_card *card);
 
-extern int resample_set(enum resample_idx id,
-	enum samplerate_index index, bool force);
+int resample_set(enum resample_idx id, enum samplerate_index index);
 
-extern int get_resample_module_num(void);
+int get_resample_module_num(void);
 
 int set_resample_source(enum resample_idx id, enum toddr_src src);
 
-int resample_set_inner_rate(enum resample_idx id);
-
 struct audioresample *get_audioresample(enum resample_idx id);
 
+int get_resample_version_id(enum resample_idx id);
+
+bool get_resample_enable(enum resample_idx id);
+
 #endif
diff --git a/sound/soc/amlogic/auge/resample_hw.c b/sound/soc/amlogic/auge/resample_hw.c
index f5d4d43f2c11..b7d2d6e8d361 100644
--- a/sound/soc/amlogic/auge/resample_hw.c
+++ b/sound/soc/amlogic/auge/resample_hw.c
@@ -15,13 +15,18 @@
  *
  */
 #include <linux/clk.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/math64.h>
 
 #include "resample_hw.h"
+#include "resample_hw_coeff.h"
 #include "regs.h"
 #include "iomap.h"
 
 /*Cnt_ctrl = mclk/fs_out-1 ; fest 256fs */
-#define RESAMPLE_CNT_CONTROL 255
+#define RESAMPLE_CNT_CONTROL (255)
+#define SINC8_FILTER_COEF_ADDR (0)
+#define AA_FILTER_COEF_ADDR (129 * 32)
 
 static u32 resample_coef_parameters_table[7][5] = {
 	/*coef of 32K, fc = 9000, Q:0.55, G= 14.00, */
@@ -40,22 +45,228 @@ static u32 resample_coef_parameters_table[7][5] = {
 	{0x00800000, 0x0, 0x0, 0x0, 0x0},
 };
 
+void new_resample_set_ram_coeff_aa(enum resample_idx id, int len,
+				   unsigned int *params)
+{
+	int i;
+	unsigned int *p = params;
+
+	new_resample_write(id, AUDIO_RSAMP_AA_COEF_ADDR, AA_FILTER_COEF_ADDR);
+	for (i = 0; i < len; i++, p++)
+		new_resample_write(id, AUDIO_RSAMP_AA_COEF_DATA, *p);
+}
+
+void new_resample_set_ram_coeff_sinc(enum resample_idx id, int len,
+				     unsigned int *params)
+{
+	int i;
+	unsigned int *p = params;
+
+	new_resample_write(id, AUDIO_RSAMP_SINC_COEF_ADDR,
+			   SINC8_FILTER_COEF_ADDR);
+	for (i = 0; i < len; i++, p++)
+		new_resample_write(id, AUDIO_RSAMP_SINC_COEF_DATA, *p);
+}
+
+void new_resample_init_param(enum resample_idx id)
+{
+	new_resample_write(id, AUDIO_RSAMP_CTRL0, 7);
+	new_resample_write(id, AUDIO_RSAMP_CTRL0, 0);
+
+	/*enable memory power*/
+	aml_write_hiubus(HHI_AUDIO_MEM_PD_REG0, 0x0);
+
+	/* filter tap of AA and sinc filter */
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL2, 0xff << 8, 0x3f << 8);
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL2, 0xff, 0x3f);
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL1, 0x1 << 12, 0x1 << 12);
+
+	if (id == RESAMPLE_A) {
+		/*write resample A filter in ram*/
+		new_resample_set_ram_coeff_sinc(id, SINC8_FILTER_COEF_SIZE,
+						&sinc8_coef[0]);
+	} else {
+		/*write resample B filter in ram*/
+		new_resample_set_ram_coeff_sinc(id, SINC8_FILTER_COEF_SIZE,
+						&sinc_coef[0]);
+	}
+}
+
+void new_resample_enable(enum resample_idx id, bool enable)
+{
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL1,
+				 0x1 << 11, enable << 11);
+}
+
+bool new_resample_get_status(enum resample_idx id)
+{
+	unsigned int val = new_resample_read(id, AUDIO_RSAMP_CTRL1);
+
+	return ((val >> 11) & 0x1);
+}
+
+static int new_resample_status_check(enum resample_idx id)
+{
+	int check_times = 20;
+	unsigned int val;
+
+	/* wait resample status to bypass, then change config, max 20us */
+	while (check_times--) {
+		val = new_resample_read(id, AUDIO_RSAMP_RO_STATUS);
+		val = (val >> 11) & 0x7;
+		if (val == 1)
+			break;
+		udelay(1);
+	}
+
+	if (check_times == 0) {
+		pr_err("%s(), check resample status error!", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+void new_resample_set_format(enum resample_idx id, int channel, int bits)
+{
+	int reg_val = bits - 1;
+
+	if (channel > 8 || channel == 0 || bits < 16)
+		return;
+
+	/* resample B is always 2 channel for loopback */
+	if (id == RESAMPLE_B) {
+		channel = 2;
+		reg_val = 31;
+	}
+
+	new_resample_enable(id, false);
+	new_resample_status_check(id);
+
+	new_resample_write(id, AUDIO_RSAMP_PHSINIT, 0x0);
+	/* channel num */
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL2, 0x3f << 24,
+				 channel << 24);
+	/* bit width */
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL1, 0x1f << 13,
+				 reg_val << 13);
+
+	/* enable auto adjust module */
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL0, 0x1 << 2,
+				 0x1 << 2);
+	new_resample_update_bits(id, AUDIO_RSAMP_ADJ_CTRL1, 0xffff << 16,
+				 (256 / channel) << 16);
+	new_resample_write(id, AUDIO_RSAMP_ADJ_SFT, 0x1f020604);
+	new_resample_write(id, AUDIO_RSAMP_ADJ_IDET_LEN, 0x22710);
+	new_resample_write(id, AUDIO_RSAMP_ADJ_FORCE, 0x0);
+	new_resample_write(id, AUDIO_RSAMP_ADJ_CTRL0, 0x1);
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL0, 0x1 << 2, 0x0 << 2);
+
+	new_resample_enable(id, true);
+
+	pr_info("%s(), channel = %d, bits = %d", __func__, channel, bits);
+}
+
+void new_resample_src_select(enum resample_idx id, enum resample_src src)
+{
+    /* resample B is always for loopbackA */
+	if (id == RESAMPLE_B)
+		src = ASRC_LOOPBACK_A;
+
+	new_resample_enable(id, false);
+	new_resample_status_check(id);
+
+	/* resample source select */
+	new_resample_update_bits(id, AUDIO_RSAMP_CTRL1, 0xf, src);
+
+	new_resample_enable(id, true);
+}
+
+void new_resample_set_ratio(enum resample_idx id, int input_sr, int output_sr)
+{
+	u32 down_ratio = 1;
+	u32 input_sample_rate = (u32)input_sr;
+	u32 output_sample_rate = (u32)output_sr;
+	u64 phase_step = (u64)input_sample_rate;
+
+	new_resample_enable(id, false);
+	new_resample_status_check(id);
+
+	if (input_sample_rate <= output_sample_rate) { /* upsample*/
+		new_resample_update_bits(id, AUDIO_RSAMP_CTRL2, 0x3 << 16,
+					 0 << 16);
+		/* disable AA filter */
+		new_resample_update_bits(id, AUDIO_RSAMP_CTRL1, 0x1 << 10,
+					 0 << 10);
+	} else { /* downsample*/
+		int rate = input_sample_rate * 10 / output_sample_rate;
+		/* enable AA filter */
+		new_resample_update_bits(id, AUDIO_RSAMP_CTRL1, 0x1 << 10,
+					 1 << 10);
+		if (id == RESAMPLE_A) {
+			if (rate <= 30) {
+				new_resample_set_ram_coeff_aa(
+						id, AA_FILTER_COEF_SIZE,
+						&aa_coef_a_half[0]);
+				new_resample_update_bits(id, AUDIO_RSAMP_CTRL2,
+							 0x3 << 16, 1 << 16);
+				down_ratio = 2;
+			} else {
+				new_resample_set_ram_coeff_aa(
+						id, AA_FILTER_COEF_SIZE,
+						&aa_coef_a_quarter[0]);
+				new_resample_update_bits(id, AUDIO_RSAMP_CTRL2,
+							 0x3 << 16, 2 << 16);
+				down_ratio = 4;
+			}
+		} else {
+			new_resample_set_ram_coeff_aa(
+					id, AA_FILTER_COEF_SIZE,
+					&aa_coef_one_third[0]);
+			new_resample_update_bits(id, AUDIO_RSAMP_CTRL2,
+						 0x3 << 16, 0 << 16);
+			down_ratio = 3;
+		}
+	}
+
+	output_sample_rate *= down_ratio;
+	phase_step *= (1 << 28);
+	phase_step = div_u64(phase_step, output_sample_rate);
+
+	new_resample_write(id, AUDIO_RSAMP_PHSSTEP, (u32)phase_step);
+
+	new_resample_enable(id, true);
+
+	pr_info("%s(), down_ratio = %d, phase_step = 0x%x", __func__,
+		down_ratio, (u32)phase_step);
+}
+
 void resample_enable(enum resample_idx id, bool enable)
 {
 	int offset = EE_AUDIO_RESAMPLEB_CTRL0 - EE_AUDIO_RESAMPLEA_CTRL0;
 	int reg = EE_AUDIO_RESAMPLEA_CTRL0 + offset * id;
 
-	audiobus_update_bits(reg,
-		0x1 << 31,
-		1 << 31);
+	if (enable == 1) {
+		/*don't change this flow*/
+		audiobus_update_bits(
+			reg, 0x1 << 31 | 0x1 << 28,
+			0 << 31 | 0x0 << 28);
 
-	audiobus_update_bits(reg,
-		0x1 << 31,
-		0 << 31);
+		audiobus_update_bits(reg, 0x1 << 31, 1 << 31);
 
-	audiobus_update_bits(reg,
-		0x1 << 28,
-		enable << 28);
+		audiobus_update_bits(reg, 0x1 << 31, 0 << 31);
+	}
+
+	audiobus_update_bits(reg, 0x1 << 28, enable << 28);
+}
+
+bool resample_get_status(enum resample_idx id)
+{
+	int offset = EE_AUDIO_RESAMPLEB_CTRL0 - EE_AUDIO_RESAMPLEA_CTRL0;
+	int reg = EE_AUDIO_RESAMPLEA_CTRL0 + offset * id;
+	bool enable = (audiobus_read(reg) >> 28) & 0x1;
+
+	return enable;
 }
 
 int resample_init(enum resample_idx id, int input_sr)
@@ -85,16 +296,6 @@ int resample_init(enum resample_idx id, int input_sr)
 	return 0;
 }
 
-int resample_disable(enum resample_idx id)
-{
-	int offset = EE_AUDIO_RESAMPLEB_CTRL0 - EE_AUDIO_RESAMPLEA_CTRL0;
-	int reg = EE_AUDIO_RESAMPLEA_CTRL0 + offset * id;
-
-	audiobus_write(reg, 0);
-
-	return 0;
-}
-
 int resample_set_hw_param(enum resample_idx id,
 		enum samplerate_index rate_index)
 {
@@ -116,7 +317,7 @@ int resample_set_hw_param(enum resample_idx id,
 	offset = EE_AUDIO_RESAMPLEB_CTRL2 - EE_AUDIO_RESAMPLEA_CTRL2;
 	reg = EE_AUDIO_RESAMPLEA_CTRL2 + offset * id;
 
-	audiobus_update_bits(reg, 1 << 25, 1 << 25);
+	audiobus_update_bits(reg, 3 << 26 | 1 << 25, 3 << 26 | 1 << 25);
 	resample_set_hw_pause_thd(id, 128);
 
 	return 0;
@@ -129,6 +330,7 @@ void resample_src_select(int src)
 		0x3 << 29,
 		src << 29);
 }
+
 /* for tl1 and after */
 void resample_src_select_ab(enum resample_idx id, enum resample_src src)
 {
diff --git a/sound/soc/amlogic/auge/resample_hw.h b/sound/soc/amlogic/auge/resample_hw.h
index d3d709073486..29e82adc26fb 100644
--- a/sound/soc/amlogic/auge/resample_hw.h
+++ b/sound/soc/amlogic/auge/resample_hw.h
@@ -28,19 +28,34 @@ enum samplerate_index {
 	RATE_96K,
 	RATE_176K,
 	RATE_192K,
+	RATE_16K,
+	RATE_MAX,
 };
 
-extern void resample_enable(enum resample_idx id, bool enable);
-extern int resample_init(enum resample_idx id, int input_sr);
-extern int resample_disable(enum resample_idx id);
-extern int resample_set_hw_param(enum resample_idx id,
-		enum samplerate_index rate_index);
-extern void resample_src_select(int src);
-extern void resample_src_select_ab(enum resample_idx id, enum resample_src src);
-extern void resample_format_set(enum resample_idx id, int ch_num, int bits);
+#define DEFAULT_SPK_SAMPLERATE 48000
+#define DEFAULT_MIC_SAMPLERATE 16000
 
-extern int resample_ctrl_read(enum resample_idx id);
-extern void resample_ctrl_write(enum resample_idx id, int value);
+bool resample_get_status(enum resample_idx id);
+void resample_enable(enum resample_idx id, bool enable);
+int resample_init(enum resample_idx id, int input_sr);
+int resample_set_hw_param(enum resample_idx id,
+			  enum samplerate_index rate_index);
+void resample_src_select(int src);
+void resample_src_select_ab(enum resample_idx id, enum resample_src src);
+void resample_format_set(enum resample_idx id, int ch_num, int bits);
+int resample_ctrl_read(enum resample_idx id);
+void resample_ctrl_write(enum resample_idx id, int value);
 int resample_set_hw_pause_thd(enum resample_idx id, unsigned int thd);
 
+void new_resample_set_ram_coeff_aa(enum resample_idx id, int len,
+				   unsigned int *params);
+void new_resample_set_ram_coeff_sinc(enum resample_idx id, int len,
+				     unsigned int *params);
+void new_resample_init_param(enum resample_idx id);
+void new_resample_enable(enum resample_idx id, bool enable);
+void new_resample_set_format(enum resample_idx id, int source, int channel);
+void new_resample_set_ratio(enum resample_idx id, int input_sr, int output_sr);
+bool new_resample_get_status(enum resample_idx id);
+void new_resample_src_select(enum resample_idx id, enum resample_src src);
+
 #endif
diff --git a/sound/soc/amlogic/auge/resample_hw_coeff.h b/sound/soc/amlogic/auge/resample_hw_coeff.h
new file mode 100644
index 000000000000..0cb132cbff5c
--- /dev/null
+++ b/sound/soc/amlogic/auge/resample_hw_coeff.h
@@ -0,0 +1,2127 @@
+/*
+ * sound/soc/amlogic/auge/resample_hw_coeff.h
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __RESAMPLE_HW_COEFF_H__
+#define __RESAMPLE_HW_COEFF_H__
+
+#define SINC8_FILTER_COEF_SIZE (129 * 32)
+#define AA_FILTER_COEF_SIZE (32)
+
+static s32 aa_coef_a_half[AA_FILTER_COEF_SIZE] = {
+	1071888850, 682703897,  2418626,  -224301306,
+	-2366746,   130725205,  2282164,  -89357198,
+	-2167624,   65493114,   2026802,  -49690155,
+	-1864146,   38331289,   1684692,  -29737627,
+	-1493853,   23024720,   1297198,  -17681100,
+	-1100227,   13387710,   908158,   -9931723,
+	-725734,    7161999,    557052,   -4964668,
+	-405433,    3249194,    273329,   -1940211
+};
+
+static s32 aa_coef_a_quarter[AA_FILTER_COEF_SIZE] = {
+	536034773,  481655564,   338657708,   158400365,
+	812047,     -90688473,   -104827128,  -62173264,
+	-743181,    43937876,    54060052,    33506097,
+	639092,     -24414671,   -30496133,   -19084204,
+	-513619,    13625521,    16983155,    10573830,
+	382276,     -7160427,    -8801749,    -5389244,
+	-259487,    3325899,     3972125,     2351947,
+	156264,     -1215082,    -1360518,    -743909
+};
+
+static s32 aa_coef_one_third[AA_FILTER_COEF_SIZE] = {
+	0x2c6fdb2e, 0x2412c6b2, 0x1092cf1d, 0xfe41e2aa,
+	0xf6b1b100, 0xfa41a3cd, 0x01a96472, 0x0536bdda,
+	0x02e66971, 0xfe77847b, 0xfc9a36ab, 0xfe72114d,
+	0x015da97a, 0x024d18d2, 0x00c82c5d, 0xfed43275,
+	0xfe74bfe8, 0xffb10712, 0x00f6128d, 0x00fd6486,
+	0x000507b8, 0xff40795d, 0xff6c6634, 0x0025447b,
+	0x008a62ea, 0x00442a96, 0xffc66020, 0xffaa2111,
+	0xfff9eb53, 0x0039c763, 0x00134b02, 0xffe3ffd3
+};
+
+static s32 sinc8_coef[SINC8_FILTER_COEF_SIZE] = {
+	0x7ccccccd, 0x0323eb7f, 0xfd086246, 0x02b2aa5c,
+	0xfda45e2c, 0x01fa5183, 0xfe694e12, 0x0137e672,
+	0xff1c87d3, 0x009ce6d8, 0xff9a68b0, 0x003d150d,
+	0xffde727a, 0x00106595, 0xfff93679, 0x00021fc5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7cc9b757, 0x022ac835, 0xfd7e3a71, 0x026b7da1,
+	0xfdd2b905, 0x01db7c90, 0xfe7db77c, 0x012aa7bf,
+	0xff24dc32, 0x0097dfc9, 0xff9d4ae9, 0x003b8742,
+	0xffdf38e5, 0x00100be5, 0xfff959f5, 0x0002144b,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7cc0773c, 0x01354bc1, 0xfdf365e8, 0x0224726d,
+	0xfe011d2e, 0x01bc908b, 0xfe923a2b, 0x011d528d,
+	0xff2d426f, 0x0092cbc0, 0xffa035cc, 0x0039f42e,
+	0xffe00236, 0x000fb0d2, 0xfff97dfa, 0x000208b0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7cb10d52, 0x0043843f, 0xfe67d5a8, 0x01dd92df,
+	0xfe2f83c1, 0x019d9230, 0xfea6d2e5, 0x010fe901,
+	0xff35b924, 0x008dab9d, 0xffa328d4, 0x00385c1d,
+	0xffe0ce46, 0x000f5471, 0xfff9a27f, 0x0001fcf5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7c9b7afd, 0xff557f58, 0xfedb7ae9, 0x0196e8fe,
+	0xfe5de5e3, 0x017e8635, 0xfebb7e75, 0x01026d40,
+	0xff3e3eed, 0x0088803e, 0xffa6237a, 0x0036bf58,
+	0xffe19cec, 0x000ef6d4, 0xfff9c77d, 0x0001f11e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7c7fc22f, 0xfe6b4a44, 0xff4e471d, 0x01507eb8,
+	0xfe8c3cc3, 0x015f714d, 0xfed039a8, 0x00f4e16f,
+	0xff46d266, 0x00834a83, 0xffa9253b, 0x00351e2d,
+	0xffe26e01, 0x000e980f, 0xfff9eceb, 0x0001e52e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7c5de56a, 0xfd84f1c8, 0xffc02bf2, 0x010a5de2,
+	0xfeba819d, 0x01405821, 0xfee5014c, 0x00e747b0,
+	0xff4f722b, 0x007e0b4b, 0xffac2d8f, 0x003378e7,
+	0xffe3415d, 0x000e3834, 0xfffa12c0, 0x0001d927,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7c35e7bb, 0xfca28234, 0x00311b54, 0x00c49034,
+	0xfee8adba, 0x01213f58, 0xfef9d232, 0x00d9a226,
+	0xff581cd8, 0x0078c375, 0xffaf3bf2, 0x0031cfd1,
+	0xffe416d8, 0x000dd758, 0xfffa38f5, 0x0001cd0d,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7c07ccbe, 0xfbc40766, 0x00a1076e, 0x007f1f4b,
+	0xff16ba71, 0x01022b90, 0xff0ea931, 0x00cbf2f0,
+	0xff60d10b, 0x007373de, 0xffb24fde, 0x00302337,
+	0xffe4ee4b, 0x000d758d, 0xfffa5f81, 0x0001c0e1,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7bd3989d, 0xfae98cc5, 0x010fe2ab, 0x003a14a6,
+	0xff44a128, 0x00e3215e, 0xff238322, 0x00be3c2d,
+	0xff698d62, 0x006e1d66, 0xffb568ce, 0x002e7363,
+	0xffe5c78d, 0x000d12e6, 0xfffa865d, 0x0001b4a8,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7b99500c, 0xfa131d41, 0x017d9fb8, 0xfff579a3,
+	0xff725b54, 0x00c42551, 0xff385ce3, 0x00b07ff8,
+	0xff72507e, 0x0068c0e9, 0xffb8863e, 0x002cc0a2,
+	0xffe6a277, 0x000caf76, 0xfffaad81, 0x0001a863,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7b58f84d, 0xf940c355, 0x01ea3184, 0xffb15783,
+	0xff9fe27d, 0x00a53bed, 0xff4d3358, 0x00a2c06b,
+	0xff7b18fe, 0x00635f45, 0xffbba7aa, 0x002b0b3d,
+	0xffe77ee2, 0x000c4b50, 0xfffad4e4, 0x00019c15,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7b12972d, 0xf8728902, 0x02558b43, 0xff6db764,
+	0xffcd303b, 0x008669ae, 0xff620368, 0x0094ff9b,
+	0xff83e586, 0x005df954, 0xffbecc8d, 0x00295380,
+	0xffe85ca7, 0x000be687, 0xfffafc7f, 0x00018fc1,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7ac63304, 0xf7a877d4, 0x02bfa06d, 0xff2aa243,
+	0xfffa3e37, 0x0067b303, 0xff76ca02, 0x00873f9b,
+	0xff8cb4bb, 0x00588ff1, 0xffc1f465, 0x002799b3,
+	0xffe93b9e, 0x000b812d, 0xfffb244a, 0x0001836a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7a73d2b5, 0xf6e298db, 0x032864c1, 0xfee820f8,
+	0x00270631, 0x00491c54, 0xff8b841a, 0x0079827a,
+	0xff958542, 0x005323f7, 0xffc51eaf, 0x0025de22,
+	0xffea1ba2, 0x000b1b55, 0xfffb4c3e, 0x00017712,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7a1b7daa, 0xf620f4b2, 0x038fcc44, 0xfea63c38,
+	0x005381fa, 0x002aa9fa, 0xffa02eac, 0x006bca44,
+	0xff9e55c6, 0x004db63c, 0xffc84ae9, 0x00242115,
+	0xffeafc8b, 0x000ab510, 0xfffb7452, 0x00016abb,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x79bd3bd8, 0xf5639376, 0x03f5cb46, 0xfe64fc93,
+	0x007fab77, 0x000c6043, 0xffb4c6b9, 0x005e1900,
+	0xffa724f0, 0x00484799, 0xffcb7893, 0x002262d6,
+	0xffebde33, 0x000a4e72, 0xfffb9c80, 0x00015e68,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x795915bc, 0xf4aa7cce, 0x045a565c, 0xfe246a72,
+	0x00ab7ca6, 0xffee4372, 0xffc9494b, 0x005070b0,
+	0xffaff16f, 0x0042d8e1, 0xffcea72c, 0x0020a3ad,
+	0xffecc075, 0x0009e78c, 0xfffbc4bf, 0x0001521b,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x78ef1457, 0xf3f5b7e4, 0x04bd6269, 0xfde48e17,
+	0x00d6ef99, 0xffd057bb, 0xffddb374, 0x0042d353,
+	0xffb8b9f3, 0x003d6aea, 0xffd1d635, 0x001ee3e1,
+	0xffeda32a, 0x00098070, 0xfffbed0a, 0x000145d7,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x787f4134, 0xf3454b6a, 0x051ee498, 0xfda56f9c,
+	0x0101fe7a, 0xffb2a145, 0xfff2024e, 0x003542e2,
+	0xffc17d30, 0x0037fe85, 0xffd50530, 0x001d23b9,
+	0xffee862e, 0x0009192f, 0xfffc1558, 0x0001399e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x7809a65e, 0xf2993d95, 0x057ed264, 0xfd6716f2,
+	0x012ca389, 0xff952429, 0x000632fa, 0x0027c151,
+	0xffca39dd, 0x00329483, 0xffd833a0, 0x001b637e,
+	0xffef695c, 0x0008b1db, 0xfffc3da2, 0x00012d72,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x778e4e68, 0xf1f19421, 0x05dd218f, 0xfd298be0,
+	0x0156d920, 0xff77e470, 0x001a42a4, 0x001a508e,
+	0xffd2eeb3, 0x002d2db0, 0xffdb6109, 0x0019a373,
+	0xfff04c8f, 0x00084a86, 0xfffc65e2, 0x00012155,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x770d4466, 0xf14e544f, 0x0639c82d, 0xfcecd602,
+	0x018099b2, 0xff5ae614, 0x002e2e82, 0x000cf281,
+	0xffdb9a70, 0x0027cada, 0xffde8cf1, 0x0017e3df,
+	0xfff12fa3, 0x0007e33f, 0xfffc8e11, 0x0001154a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x768693ec, 0xf0af82e4, 0x0694bca0, 0xfcb0fcca,
+	0x01a9dfcc, 0xff3e2d01, 0x0041f3d2, 0xffffa90e,
+	0xffe43bd5, 0x00226ccb, 0xffe1b6dd, 0x00162507,
+	0xfff21275, 0x00077c17, 0xfffcb628, 0x00010952,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x75fa4911, 0xf015242b, 0x06edf595, 0xfc76077b,
+	0x01d2a615, 0xff21bd11, 0x00558fdc, 0xfff27611,
+	0xffecd1a6, 0x001d144a, 0xffe4de56, 0x0014672d,
+	0xfff2f4e0, 0x00071520, 0xfffcde20, 0x0000fd6f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x75687068, 0xef7f3bf5, 0x07456a0e, 0xfc3bfd2e,
+	0x01fae74e, 0xff059a0e, 0x0068fff3, 0xffe55b60,
+	0xfff55aae, 0x0017c21c, 0xffe802e6, 0x0012aa95,
+	0xfff3d6c3, 0x0006ae6a, 0xfffd05f3, 0x0000f1a4,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x74d11703, 0xeeedcd98, 0x079b1158, 0xfc02e4cc,
+	0x02229e57, 0xfee9c7af, 0x007c4177, 0xffd85ac9,
+	0xfffdd5b8, 0x00127704, 0xffeb2416, 0x0010ef82,
+	0xfff4b7fb, 0x00064804, 0xfffd2d9b, 0x0000e5f3,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x74344a70, 0xee60dbee, 0x07eee314, 0xfbcac510,
+	0x0249c629, 0xfece499d, 0x008f51cf, 0xffcb7615,
+	0x00064197, 0x000d33c3, 0xffee4174, 0x000f3633,
+	0xfff59866, 0x0005e1fe, 0xfffd5511, 0x0000da5c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x739218b8, 0xedd86958, 0x0840d732, 0xfb93a486,
+	0x027059da, 0xfeb3236b, 0x00a22e71, 0xffbeaf06,
+	0x000e9d1f, 0x0007f915, 0xfff15a8d, 0x000d7eea,
+	0xfff677e2, 0x00057c68, 0xfffd7c4f, 0x0000cee3,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x72ea905a, 0xed5477be, 0x0890e5f7, 0xfb5d898c,
+	0x029654a0, 0xfe98589b, 0x00b4d4dd, 0xffb20754,
+	0x0016e72c, 0x0002c7b6, 0xfff46ef1, 0x000bc9e6,
+	0xfff75650, 0x00051750, 0xfffda350, 0x0000c388,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x723dc051, 0xecd5088e, 0x08df07f6, 0xfb287a4d,
+	0x02bbb1cc, 0xfe7dec9c, 0x00c7429f, 0xffa580b1,
+	0x001f1e9b, 0xfffda05c, 0xfff77e31, 0x000a1765,
+	0xfff8338e, 0x0004b2c7, 0xfffdca0d, 0x0000b84d,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x718bb80b, 0xec5a1cbc, 0x092b3617, 0xfaf47cc4,
+	0x02e06ccf, 0xfe63e2cc, 0x00d97550, 0xff991cc9,
+	0x00274253, 0xfff883be, 0xfffa87df, 0x000867a5,
+	0xfff90f7c, 0x00044eda, 0xfffdf080, 0x0000ad34,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x70d4876b, 0xebe3b4c5, 0x09756994, 0xfac196bb,
+	0x03048139, 0xfe4a3e70, 0x00eb6a95, 0xff8cdd3c,
+	0x002f513a, 0xfff3728d, 0xfffd8b92, 0x0006bae1,
+	0xfff9e9fd, 0x0003eb98, 0xfffe16a6, 0x0000a23f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x70183ec5, 0xeb71d0ab, 0x09bd9bfb, 0xfa8fcdca,
+	0x0327eab8, 0xfe3102bd, 0x00fd2022, 0xff80c3a4,
+	0x00374a40, 0xffee6d78, 0x000088df, 0x00051157,
+	0xfffac2f0, 0x0003890e, 0xfffe3c76, 0x0000976e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6f56eee1, 0xeb046ffc, 0x0a03c72b, 0xfa5f2755,
+	0x034aa51b, 0xfe1832d4, 0x010e93b5, 0xff74d194,
+	0x003f2c57, 0xffe97529, 0x00037f60, 0x00036b3f,
+	0xfffb9a38, 0x0003274c, 0xfffe61ee, 0x00008cc4,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6e90a8f2, 0xea9b91cc, 0x0a47e559, 0xfa2fa890,
+	0x036cac52, 0xfdffd1bd, 0x011fc31c, 0xff690894,
+	0x0046f679, 0xffe48a4a, 0x00066eae, 0x0001c8d2,
+	0xfffc6fb8, 0x0002c65d, 0xfffe8707, 0x00008241,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6dc57e9b, 0xea3734bb, 0x0a89f10c, 0xfa015679,
+	0x038dfc6c, 0xfde7e26f, 0x0130ac31, 0xff5d6a24,
+	0x004ea7a3, 0xffdfad7f, 0x00095666, 0x00002a4a,
+	0xfffd4352, 0x00026650, 0xfffeabbd, 0x000077e8,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6cf581e8, 0xe9d756f3, 0x0ac9e521, 0xf9d435dc,
+	0x03ae919a, 0xfdd067ca, 0x01414cdd, 0xff51f7bb,
+	0x00563edb, 0xffdadf69, 0x000c3627, 0xfffe8fdc,
+	0xfffe14eb, 0x00020730, 0xfffed00a, 0x00006db9,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6c20c550, 0xe97bf627, 0x0b07bcc6, 0xf9a84b50,
+	0x03ce682d, 0xfdb96498, 0x0151a317, 0xff46b2c7,
+	0x005dbb29, 0xffd620a6, 0x000f0d91, 0xfffcf9be,
+	0xfffee466, 0x0001a90b, 0xfffef3ea, 0x000063b5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6b475bb0, 0xe9250f99, 0x0b437380, 0xf97d9b37,
+	0x03ed7c9a, 0xfda2db8c, 0x0161ace5, 0xff3b9cad,
+	0x00651b9c, 0xffd171d1, 0x0011dc47, 0xfffb6825,
+	0xffffb1aa, 0x00014bed, 0xffff1759, 0x000059dd,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6a69584a, 0xe8d2a017, 0x0b7d0525, 0xf95429c0,
+	0x040bcb77, 0xfd8ccf46, 0x01716859, 0xff30b6c8,
+	0x006c5f4b, 0xffccd380, 0x0014a1ee, 0xfff9db44,
+	0x00007c9c, 0x0000efe1, 0xffff3a53, 0x00005033,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x6986cec4, 0xe884a3fb, 0x0bb46de2, 0xf92bfae4,
+	0x0429517b, 0xfd77424c, 0x0180d397, 0xff260269,
+	0x00738551, 0xffc84645, 0x00175e2d, 0xfff8534d,
+	0x00014521, 0x000094f3, 0xffff5cd2, 0x000046b8,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x689fd324, 0xe83b1731, 0x0be9aa34, 0xf9051266,
+	0x04460b81, 0xfd62370e, 0x018fecd1, 0xff1b80da,
+	0x007a8cd0, 0xffc3cab1, 0x001a10ad, 0xfff6d070,
+	0x00020b23, 0x00003b2e, 0xffff7ed3, 0x00003d6c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x67b479cf, 0xe7f5f531, 0x0c1cb6ef, 0xf8df73d6,
+	0x0461f688, 0xfd4dafe6, 0x019eb246, 0xff113358,
+	0x008174ef, 0xffbf614e, 0x001cb91a, 0xfff552de,
+	0x0002ce87, 0xffffe29d, 0xffffa052, 0x00003450,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x66c4d787, 0xe7b53908, 0x0c4d913a, 0xf8bb228c,
+	0x047d0fb1, 0xfd39af17, 0x01ad2249, 0xff071b16,
+	0x00883cdc, 0xffbb0aa3, 0x001f5723, 0xfff3dac3,
+	0x00038f37, 0xffff8b4b, 0xffffc14b, 0x00002b66,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x65d10168, 0xe778dd50, 0x0c7c368d, 0xf89821ac,
+	0x0497543f, 0xfd2636ca, 0x01bb3b37, 0xfefd3941,
+	0x008ee3cd, 0xffb6c735, 0x0021ea76, 0xfff2684e,
+	0x00044d1b, 0xffff3540, 0xffffe1bc, 0x000022ad,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x64d90ce7, 0xe740dc3c, 0x0ca8a4b7, 0xf8767422,
+	0x04b0c19a, 0xfd134913, 0x01c8fb81, 0xfef38ef6,
+	0x009568fc, 0xffb29782, 0x002472c8, 0xfff0fba9,
+	0x0005081f, 0xfffee088, 0x0000019f, 0x00001a28,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x63dd0fcd, 0xe70d2f8d, 0x0cd2d9d5, 0xf8561ca7,
+	0x04c9554e, 0xfd00e7ec, 0x01d661a6, 0xfeea1d4c,
+	0x009bcbab, 0xffae7c06, 0x0026efcc, 0xffef94fe,
+	0x0005c02c, 0xfffe8d2c, 0x000020f3, 0x000011d5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x62dd2039, 0xe6ddd09f, 0x0cfad45a, 0xf8371dbb,
+	0x04e10d0a, 0xfcef153a, 0x01e36c34, 0xfee0e54e,
+	0x00a20b23, 0xffaa7538, 0x0029613a, 0xffee3477,
+	0x0006752d, 0xfffe3b35, 0x00003fb3, 0x000009b6,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x61d95497, 0xe6b2b862, 0x0d209309, 0xf81979ab,
+	0x04f7e6a2, 0xfcddd2c7, 0x01f019cb, 0xfed7e7fd,
+	0x00a826b2, 0xffa6838c, 0x002bc6cd, 0xffecda3b,
+	0x0007270f, 0xfffdeaaa, 0x00005ddd, 0x000001cc,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x60d1c3a6, 0xe68bdf5e, 0x0d4414f9, 0xf7fd328c,
+	0x050de00d, 0xfccd2246, 0x01fc691b, 0xfecf2650,
+	0x00ae1dae, 0xffa2a770, 0x002e2040, 0xffeb866f,
+	0x0007d5bf, 0xfffd9b96, 0x00007b6f, 0xfffffa17,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5fc68470, 0xe6693db5, 0x0d65598f, 0xf7e24a3c,
+	0x0522f766, 0xfcbd0551, 0x020858e2, 0xfec6a130,
+	0x00b3ef73, 0xff9ee150, 0x00306d52, 0xffea3939,
+	0x0008812a, 0xfffd4dff, 0x00009865, 0xfffff297,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5eb7ae46, 0xe64acb24, 0x0d846084, 0xf7c8c267,
+	0x05372aee, 0xfcad7d6b, 0x0213e7f0, 0xfebe5980,
+	0x00b99b65, 0xff9b3192, 0x0032adc4, 0xffe8f2bb,
+	0x0009293e, 0xfffd01ee, 0x0000b4bd, 0xffffeb4c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5da558c5, 0xe6307f05, 0x0da129df, 0xf7b09c7f,
+	0x054a7909, 0xfc9e8bfd, 0x021f1526, 0xfeb65015,
+	0x00bf20ee, 0xff979898, 0x0034e15b, 0xffe7b317,
+	0x0009cdeb, 0xfffcb769, 0x0000d074, 0xffffe438,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5c8f9bcb, 0xe61a504f, 0x0dbbb5f6, 0xf799d9c4,
+	0x055ce03f, 0xfc903258, 0x0229df75, 0xfeae85bb,
+	0x00c47f7f, 0xff9416c1, 0x003707dc, 0xffe67a6f,
+	0x000a6f20, 0xfffc6e78, 0x0000eb89, 0xffffdd5a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5b768f7a, 0xe6083599, 0x0dd40571, 0xf7847b3d,
+	0x056e5f3d, 0xfc8271b4, 0x023445dd, 0xfea6fb32,
+	0x00c9b691, 0xff90ac66, 0x00392111, 0xffe548e0,
+	0x000b0cce, 0xfffc2720, 0x000105f9, 0xffffd6b2,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5a5a4c32, 0xe5fa2519, 0x0dea1943, 0xf77081be,
+	0x057ef4d3, 0xfc754b32, 0x023e4772, 0xfe9fb12e,
+	0x00cec5a1, 0xff8d59dd, 0x003b2cc5, 0xffe41e88,
+	0x000ba6e5, 0xfffbe169, 0x00011fc3, 0xffffd041,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x593aea93, 0xe5f014aa, 0x0dfdf2ae, 0xf75dede5,
+	0x058e9ff8, 0xfc68bfd7, 0x0247e354, 0xfe98a85b,
+	0x00d3ac38, 0xff8a1f77, 0x003d2ac6, 0xffe2fb83,
+	0x000c3d59, 0xfffb9d59, 0x000138e4, 0xffffca06,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x58188376, 0xe5e9f9ca, 0x0e0f9342, 0xf74cc01c,
+	0x059d5fc5, 0xfc5cd092, 0x025118b8, 0xfe91e159,
+	0x00d869e1, 0xff86fd81, 0x003f1ae4, 0xffe1dfec,
+	0x000cd01b, 0xfffb5af3, 0x0001515c, 0xffffc402,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x56f32fea, 0xe5e7c99e, 0x0e1efcdb, 0xf73cf898,
+	0x05ab3377, 0xfc517e38, 0x0259e6e1, 0xfe8b5cba,
+	0x00dcfe32, 0xff83f443, 0x0040fcf3, 0xffe0cbdc,
+	0x000d5f1f, 0xfffb1a3f, 0x00016928, 0xffffbe35,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x55cb0935, 0xe5e978f0, 0x0e2c319d, 0xf72e9758,
+	0x05b81a70, 0xfc46c987, 0x02624d23, 0xfe851b09,
+	0x00e168c5, 0xff810401, 0x0042d0c9, 0xffdfbf6b,
+	0x000dea5a, 0xfffadb40, 0x00018048, 0xffffb89f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x54a028d0, 0xe5eefc35, 0x0e3733fc, 0xf7219c2a,
+	0x05c41435, 0xfc3cb323, 0x026a4ae5, 0xfe7f1cc4,
+	0x00e5a93c, 0xff7e2cfb, 0x0044963d, 0xffdebaaf,
+	0x000e71c1, 0xfffa9dfa, 0x000196ba, 0xffffb340,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5372a862, 0xe5f8478d, 0x0e4006b2, 0xf71606a6,
+	0x05cf2070, 0xfc333b97, 0x0271df9c, 0xfe79625e,
+	0x00e9bf43, 0xff7b6f6c, 0x00464d2b, 0xffddbdbd,
+	0x000ef549, 0xfffa6273, 0x0001ac7d, 0xffffae17,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x5242a1c1, 0xe6054ec6, 0x0e46acc4, 0xf70bd632,
+	0x05d93eee, 0xfc2a6356, 0x02790ace, 0xfe73ec40,
+	0x00edaa88, 0xff78cb8c, 0x0047f571, 0xffdcc8a9,
+	0x000f74e9, 0xfffa28ad, 0x0001c191, 0xffffa924,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x51102eec, 0xe616055a, 0x0e4b297c, 0xf7030a01,
+	0x05e26f9f, 0xfc222abb, 0x027fcc12, 0xfe6ebac6,
+	0x00f16ac4, 0xff76418b, 0x00498eed, 0xffdbdb84,
+	0x000ff098, 0xfff9f0ac, 0x0001d5f4, 0xffffa467,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4fdb6a09, 0xe62a5e76, 0x0e4d806f, 0xf6fba113,
+	0x05eab296, 0xfc1a9208, 0x02862311, 0xfe69ce43,
+	0x00f4ffb6, 0xff73d199, 0x004b1984, 0xffdaf65e,
+	0x0010684e, 0xfff9ba73, 0x0001e9a7, 0xffff9fe0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4ea46d66, 0xe6424cf8, 0x0e4db575, 0xf6f59a36,
+	0x05f20809, 0xfc139968, 0x028c0f83, 0xfe6526fe,
+	0x00f86924, 0xff717bdf, 0x004c951b, 0xffda1948,
+	0x0010dc05, 0xfff98604, 0x0001fca8, 0xffff9b8f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4d6b536f, 0xe65dc373, 0x0e4bccac, 0xf6f0f407,
+	0x05f87053, 0xfc0d40ec, 0x0291912f, 0xfe60c533,
+	0x00fba6da, 0xff6f4083, 0x004e0199, 0xffd9444e,
+	0x00114bb4, 0xfff95363, 0x00020ef7, 0xffff9773,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4c3036b2, 0xe67cb42f, 0x0e47ca78, 0xf6edacf2,
+	0x05fdebee, 0xfc07888e, 0x0296a7f0, 0xfe5ca913,
+	0x00feb8ad, 0xff6d1fa5, 0x004f5ee9, 0xffd8777d,
+	0x0011b757, 0xfff92290, 0x00022095, 0xffff938c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4af331d9, 0xe69f112f, 0x0e41b37c, 0xf6ebc332,
+	0x06027b78, 0xfc027031, 0x029b53af, 0xfe58d2c5,
+	0x01019e78, 0xff6b1961, 0x0050acf7, 0xffd7b2e0,
+	0x00121ee9, 0xfff8f38e, 0x00023181, 0xffff8fd9,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x49b45fa8, 0xe6c4cc2e, 0x0e398c9f, 0xf6eb34d4,
+	0x06061fb2, 0xfbfdf79e, 0x029f9466, 0xfe554265,
+	0x0104581c, 0xff692dd2, 0x0051ebb4, 0xffd6f67f,
+	0x00128265, 0xfff8c65d, 0x000241bb, 0xffff8c5a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4873daf7, 0xe6edd6a4, 0x0e2f5b0b, 0xf6ebffb2,
+	0x0608d97c, 0xfbfa1e88, 0x02a36a1e, 0xfe51f802,
+	0x0106e583, 0xff675d09, 0x00531b12, 0xffd64264,
+	0x0012e1c8, 0xfff89b00, 0x00025143, 0xffff890e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4731beb7, 0xe71a21c7, 0x0e232425, 0xf6ee217b,
+	0x060aa9da, 0xfbf6e48c, 0x02a6d4f0, 0xfe4ef3a4,
+	0x0109469d, 0xff65a718, 0x00543b04, 0xffd59695,
+	0x00133d0e, 0xfff87176, 0x0002601b, 0xffff85f5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x45ee25e7, 0xe7499e8f, 0x0e14ed93, 0xf6f197ad,
+	0x060b91ee, 0xfbf4492d, 0x02a9d508, 0xfe4c3546,
+	0x010b7b61, 0xff640c08, 0x00554b83, 0xffd4f316,
+	0x00139436, 0xfff849c0, 0x00026e41, 0xffff830e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x44a92b96, 0xe77c3db4, 0x0e04bd39, 0xf6f65f9b,
+	0x060b92ff, 0xfbf24bd9, 0x02ac6a9e, 0xfe49bcd9,
+	0x010d83cb, 0xff628be3, 0x00564c88, 0xffd457ec,
+	0x0013e73e, 0xfff823dd, 0x00027bb8, 0xffff805a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x4362eadc, 0xe7b1efb4, 0x0df29936, 0xf6fc766a,
+	0x060aae6e, 0xfbf0ebe7, 0x02ae95fb, 0xfe478a42,
+	0x010f5fe2, 0xff6126a9, 0x00573e0f, 0xffd3c519,
+	0x00143626, 0xfff7ffce, 0x0002887f, 0xffff7dd6,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x421b7edf, 0xe7eaa4d4, 0x0dde87e2, 0xf703d912,
+	0x0608e5c2, 0xfbf02896, 0x02b05779, 0xfe459d5e,
+	0x01110faf, 0xff5fdc5b, 0x00582016, 0xffd33a9e,
+	0x001480ec, 0xfff7dd92, 0x00029497, 0xffff7b82,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x40d302c5, 0xe8264d21, 0x0dc88fd2, 0xf70c8461,
+	0x06063a9d, 0xfbf00112, 0x02b1af7f, 0xfe43f5ff,
+	0x01129344, 0xff5eacf3, 0x0058f29f, 0xffd2b87c,
+	0x0014c792, 0xfff7bd28, 0x0002a002, 0xffff795f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3f8991bd, 0xe864d874, 0x0db0b7d1, 0xf71674fa,
+	0x0602aec3, 0xfbf0746e, 0x02b29e84, 0xfe4293ec,
+	0x0113eabb, 0xff5d9867, 0x0059b5ad, 0xffd23eaf,
+	0x00150a19, 0xfff79e8f, 0x0002aac0, 0xffff776a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3e3f46f2, 0xe8a63671, 0x0d9706e1, 0xf721a756,
+	0x05fe4414, 0xfbf181a9, 0x02b3250f, 0xfe4176e2,
+	0x01151632, 0xff5c9eaa, 0x005a6946, 0xffd1cd37,
+	0x00154883, 0xfff781c5, 0x0002b4d2, 0xffff75a3,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3cf43d8f, 0xe8ea568f, 0x0d7b843b, 0xf72e17c4,
+	0x05f8fc8f, 0xfbf327ab, 0x02b343b5, 0xfe409e95,
+	0x011615ce, 0xff5bbfaa, 0x005b0d72, 0xffd1640e,
+	0x001582d3, 0xfff766c8, 0x0002be3b, 0xffff740a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3ba890b9, 0xe9312813, 0x0d5e3749, 0xf73bc26b,
+	0x05f2da52, 0xfbf56549, 0x02b2fb1a, 0xfe400aae,
+	0x0116e9bc, 0xff5afb53, 0x005ba23b, 0xffd1032f,
+	0x0015b90b, 0xfff74d97, 0x0002c6fa, 0xffff729e,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3a5c5b8e, 0xe97a9a17, 0x0d3f27ab, 0xf74aa34c,
+	0x05ebdf97, 0xfbf83941, 0x02b24bf1, 0xfe3fbacd,
+	0x0117922f, 0xff5a5189, 0x005c27af, 0xffd0aa93,
+	0x0015eb2f, 0xfff7362f, 0x0002cf12, 0xffff715d,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x390fb920, 0xe9c69b8c, 0x0d1e5d32, 0xf75ab63f,
+	0x05e40eb3, 0xfbfba23f, 0x02b136f9, 0xfe3fae87,
+	0x01180f5d, 0xff59c230, 0x005c9ddc, 0xffd05a33,
+	0x00161944, 0xfff7208d, 0x0002d684, 0xffff7047,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x37c2c474, 0xea151b3a, 0x0cfbdfdd, 0xf76bf6f7,
+	0x05db6a19, 0xfbff9ed7, 0x02afbd02, 0xfe3fe569,
+	0x01186187, 0xff594d27, 0x005d04d4, 0xffd01205,
+	0x0016434f, 0xfff70caf, 0x0002dd53, 0xffff6f5c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x36759880, 0xea6607c4, 0x0cd7b7dd, 0xf77e6103,
+	0x05d1f459, 0xfc042d8e, 0x02addee8, 0xfe405ef6,
+	0x011888f2, 0xff58f249, 0x005d5cab, 0xffcfd1ff,
+	0x00166956, 0xfff6fa92, 0x0002e37e, 0xffff6e99,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x35285026, 0xeab94fa9, 0x0cb1ed8c, 0xf791efcb,
+	0x05c7b01a, 0xfc094cd2, 0x02ab9d96, 0xfe411aa8,
+	0x011885e7, 0xff58b16c, 0x005da575, 0xffcf9a15,
+	0x00168b5e, 0xfff6ea31, 0x0002e90a, 0xffff6dff,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x33db0631, 0xeb0ee148, 0x0c8a8973, 0xf7a69e96,
+	0x05bca021, 0xfc0efafe, 0x02a8fa03, 0xfe4217ef,
+	0x011858b9, 0xff588a65, 0x005ddf4c, 0xffcf6a3b,
+	0x0016a96f, 0xfff6db89, 0x0002edf6, 0xffff6d8d,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x328dd556, 0xeb66aae0, 0x0c619444, 0xf7bc6889,
+	0x05b0c74b, 0xfc15365c, 0x02a5f535, 0xfe435633,
+	0x011801be, 0xff587d03, 0x005e0a48, 0xffcf4262,
+	0x0016c390, 0xfff6ce97, 0x0002f246, 0xffff6d40,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x3140d82e, 0xebc09a94, 0x0c3716da, 0xf7d348a4,
+	0x05a42890, 0xfc1bfd22, 0x02a2903e, 0xfe44d4d3,
+	0x01178152, 0xff588913, 0x005e2687, 0xffcf227b,
+	0x0016d9c9, 0xfff6c356, 0x0002f5fc, 0xffff6d1a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2ff42933, 0xec1c9e6d, 0x0c0b1a37, 0xf7eb39cc,
+	0x0596c6ff, 0xfc234d75, 0x029ecc3c, 0xfe469325,
+	0x0116d7d7, 0xff58ae5d, 0x005e3427, 0xffcf0a77,
+	0x0016ec22, 0xfff6b9c1, 0x0002f919, 0xffff6d17,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2ea7e2c0, 0xec7aa45b, 0x0bdda783, 0xf80436c0,
+	0x0588a5bf, 0xfc2b2567, 0x029aaa5a, 0xfe489077,
+	0x011605b5, 0xff58eca8, 0x005e3347, 0xffcefa44,
+	0x0016faa5, 0xfff6b1d5, 0x0002fba0, 0xffff6d38,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2d5c1f0e, 0xecda9a39, 0x0baec80a, 0xf81e3a25,
+	0x0579c812, 0xfc3382fb, 0x02962bd1, 0xfe4acc0e,
+	0x01150b5a, 0xff5943b4, 0x005e240a, 0xffcef1cf,
+	0x0017055b, 0xfff6ab8c, 0x0002fd94, 0xffff6d7c,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2c10f82d, 0xed3c6dce, 0x0b7e853c, 0xf8393e81,
+	0x056a314b, 0xfc3c6420, 0x029151e3, 0xfe4d4526,
+	0x0113e937, 0xff59b340, 0x005e0694, 0xffcef106,
+	0x00170c4f, 0xfff6a6e2, 0x0002fef6, 0xffff6de2,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2ac68807, 0xeda00cd1, 0x0b4ce8a8, 0xf8553e3c,
+	0x0559e4da, 0xfc45c6b6, 0x028c1de0, 0xfe4ffaf6,
+	0x01129fc5, 0xff5a3b09, 0x005ddb0b, 0xffcef7d4,
+	0x00170f8a, 0xfff6a3d0, 0x0002ffc9, 0xffff6e67,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x297ce85a, 0xee0564e8, 0x0b19fbfe, 0xf87233a4,
+	0x0548e63f, 0xfc4fa88f, 0x02869122, 0xfe52ecab,
+	0x01112f81, 0xff5adac6, 0x005da198, 0xffcf0623,
+	0x00170f18, 0xfff6a252, 0x00030010, 0xffff6f0d,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x283432b9, 0xee6c63ad, 0x0ae5c90b, 0xf89018eb,
+	0x05373912, 0xfc5a076a, 0x0280ad0f, 0xfe561969,
+	0x010f98eb, 0xff5b922d, 0x005d5a62, 0xffcf1bde,
+	0x00170b04, 0xfff6a262, 0x0002ffcd, 0xffff6fd1,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x26ec8083, 0xeed4f6b0, 0x0ab059bc, 0xf8aee828,
+	0x0524e100, 0xfc64e0f9, 0x027a7318, 0xfe598050,
+	0x010ddc8c, 0xff5c60ee, 0x005d0597, 0xffcf38ec,
+	0x0017035a, 0xfff6a3f9, 0x0002ff03, 0xffff70b2,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x25a5eae8, 0xef3f0b78, 0x0a79b814, 0xf8ce9b5d,
+	0x0511e1c6, 0xfc7032de, 0x0273e4b8, 0xfe5d2075,
+	0x010bfaee, 0xff5d46bb, 0x005ca363, 0xffcf5d36,
+	0x0016f828, 0xfff6a713, 0x0002fdb4, 0xffff71b0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x24608ae2, 0xefaa8f87, 0x0a41ee32, 0xf8ef2c71,
+	0x04fe3f39, 0xfc7bfaad, 0x026d0374, 0xfe60f8ea,
+	0x0109f4a2, 0xff5e433e, 0x005c33f6, 0xffcf88a2,
+	0x0016e979, 0xfff6aba9, 0x0002fbe4, 0xffff72c9,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x231c7932, 0xf017705a, 0x0a09064e, 0xf9109535,
+	0x04e9fd3c, 0xfc8835ed, 0x0265d0dd, 0xfe6508b6,
+	0x0107ca3c, 0xff5f5621, 0x005bb77f, 0xffcfbb17,
+	0x0016d75b, 0xfff6b1b4, 0x0002f995, 0xffff73fc,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x21d9ce63, 0xf0859b6e, 0x09cf0ab4, 0xf932cf65,
+	0x04d51fc6, 0xfc94e216, 0x025e4e8b, 0xfe694edd,
+	0x01057c57, 0xff607f0b, 0x005b2e31, 0xffcff478,
+	0x0016c1dc, 0xfff6b92d, 0x0002f6c9, 0xffff7549,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x2098a2bf, 0xf0f4fe3d, 0x099405c6, 0xf955d4a7,
+	0x04bfaadf, 0xfca1fc96, 0x02567e22, 0xfe6dca58,
+	0x01030b8e, 0xff61bd9f, 0x005a9840, 0xffd034ac,
+	0x0016a90a, 0xfff6c20f, 0x0002f385, 0xffff76ae,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1f590e55, 0xf1658649, 0x095801f8, 0xf9799e8f,
+	0x04a9a29e, 0xfcaf82ca, 0x024e614c, 0xfe727a1f,
+	0x01007885, 0xff631180, 0x0059f5e1, 0xffd07b95,
+	0x00168cf2, 0xfff6cc52, 0x0002efca, 0xffff782a,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1e1b28f2, 0xf1d72114, 0x091b09d1, 0xf99e269e,
+	0x04930b2b, 0xfcbd7206, 0x0245f9bf, 0xfe775d1f,
+	0x00fdc3e0, 0xff647a4b, 0x0059474a, 0xffd0c915,
+	0x00166da5, 0xfff6d7f0, 0x0002eb9c, 0xffff79bc,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1cdf0a20, 0xf249bc2c, 0x08dd27e6, 0xf9c36642,
+	0x047be8bc, 0xfccbc793, 0x023d4937, 0xfe7c7243,
+	0x00faee49, 0xff65f79e, 0x00588cb4, 0xffd11d0f,
+	0x00164b32, 0xfff6e4e1, 0x0002e6fe, 0xffff7b63,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1ba4c923, 0xf2bd4523, 0x089e66dd, 0xf9e956da,
+	0x04643f95, 0xfcda80ad, 0x0234517a, 0xfe81b86d,
+	0x00f7f86e, 0xff678912, 0x0057c658, 0xffd17764,
+	0x001625a7, 0xfff6f31d, 0x0002e1f3, 0xffff7d1f,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1a6c7cf9, 0xf331a99b, 0x085ed167, 0xfa0ff1b6,
+	0x044c1409, 0xfce99a86, 0x022b1455, 0xfe872e7c,
+	0x00f4e2ff, 0xff692e3f, 0x0056f471, 0xffd1d7f5,
+	0x0015fd15, 0xfff7029f, 0x0002dc7d, 0xffff7eed,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x19363c54, 0xf3a6d741, 0x081e7241, 0xfa373017,
+	0x04336a75, 0xfcf91246, 0x0221939d, 0xfe8cd349,
+	0x00f1aeb2, 0xff6ae6ba, 0x0056173b, 0xffd23ea1,
+	0x0015d18b, 0xfff7135d, 0x0002d6a0, 0xffff80cd,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x18021d9d, 0xf41cbbd3, 0x07dd5430, 0xfa5f0b30,
+	0x041a4744, 0xfd08e50c, 0x0217d12d, 0xfe92a5a7,
+	0x00ee5c3e, 0xff6cb218, 0x00552ef3, 0xffd2ab47,
+	0x0015a31b, 0xfff72551, 0x0002d060, 0xffff82bf,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x16d036eb, 0xf493451f, 0x079b8203, 0xfa877c29,
+	0x0400aeec, 0xfd190fed, 0x020dcee8, 0xfe98a466,
+	0x00eaec5e, 0xff6e8fe9, 0x00543bd8, 0xffd31dc7,
+	0x001571d5, 0xfff73873, 0x0002c9be, 0xffff84c0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x15a09e09, 0xf50a610a, 0x0759068f, 0xfab07c1d,
+	0x03e6a5ee, 0xfd298ff6, 0x02038eb7, 0xfe9ece4f,
+	0x00e75fd1, 0xff707fbd, 0x00533e29, 0xffd395fd,
+	0x00153dca, 0xfff74cba, 0x0002c2be, 0xffff86d0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1473686d, 0xf581fd8b, 0x0715ecae, 0xfada0420,
+	0x03cc30d4, 0xfd3a622b, 0x01f9128a, 0xfea52227,
+	0x00e3b758, 0xff728121, 0x00523626, 0xffd413c9,
+	0x0015070b, 0xfff76220, 0x0002bb64, 0xffff88ee,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x1348ab3a, 0xf5fa08b5, 0x06d23f3d, 0xfb040d3b,
+	0x03b15431, 0xfd4b8389, 0x01ee5c55, 0xfeab9eb2,
+	0x00dff3b7, 0xff7493a2, 0x00512412, 0xffd49705,
+	0x0014cdab, 0xfff7789c, 0x0002b3b3, 0xffff8b19,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x12207b3e, 0xf67270b1, 0x068e091c, 0xfb2e906f,
+	0x039614a1, 0xfd5cf105, 0x01e36e14, 0xfeb242ac,
+	0x00dc15b4, 0xff76b6ca, 0x0050082f, 0xffd51f90,
+	0x001491b9, 0xfff79026, 0x0002abad, 0xffff8d50,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x10faecee, 0xf6eb23c6, 0x0649552a, 0xfb5986b6,
+	0x037a76c7, 0xfd6ea790, 0x01d849c7, 0xfeb90cce,
+	0x00d81e1a, 0xff78ea20, 0x004ee2c1, 0xffd5ad44,
+	0x00145349, 0xfff7a8b6, 0x0002a357, 0xffff8f92,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0fd81464, 0xf7641059, 0x06042e45, 0xfb84e906,
+	0x035e7f4e, 0xfd80a411, 0x01ccf173, 0xfebffbd0,
+	0x00d40db3, 0xff7b2d2d, 0x004db40c, 0xffd63ffe,
+	0x0014126c, 0xfff7c245, 0x00029ab2, 0xffff91de,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0eb80562, 0xf7dd24ef, 0x05be9f49, 0xfbb0b04e,
+	0x034232e6, 0xfd92e36c, 0x01c16720, 0xfec70e64,
+	0x00cfe54f, 0xff7d7f76, 0x004c7c55, 0xffd6d798,
+	0x0013cf36, 0xfff7dcc8, 0x000291c3, 0xffff9434,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0d9ad348, 0xf856502d, 0x0578b30e, 0xfbdcd57a,
+	0x03259644, 0xfda5627e, 0x01b5acdd, 0xfece433a,
+	0x00cba5bc, 0xff7fe07f, 0x004b3be3, 0xffd773ed,
+	0x001389b7, 0xfff7f83a, 0x0002888c, 0xffff9691,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c80911b, 0xf8cf80de, 0x05327467, 0xfc095174,
+	0x0308ae24, 0xfdb81e22, 0x01a9c4bc, 0xfed598fe,
+	0x00c74fce, 0xff824fca, 0x0049f2fc, 0xffd814d7,
+	0x00134204, 0xfff81490, 0x00027f11, 0xffff98f5,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0b69517e, 0xf948a5f0, 0x04ebee1c, 0xfc361d25,
+	0x02eb7f44, 0xfdcb132d, 0x019db0d0, 0xfedd0e5c,
+	0x00c2e457, 0xff84ccdb, 0x0048a1e7, 0xffd8ba31,
+	0x0012f82e, 0xfff831c3, 0x00027555, 0xffff9b60,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0a5526b0, 0xf9c1ae7b, 0x04a52af2, 0xfc633173,
+	0x02ce0e67, 0xfdde3e6f, 0x01917334, 0xfee4a1fa,
+	0x00be642f, 0xff875731, 0x004748ed, 0xffd963d4,
+	0x0012ac48, 0xfff84fcb, 0x00026b5b, 0xffff9dd0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0944228e, 0xfa3a89be, 0x045e359f, 0xfc908746,
+	0x02b0604f, 0xfdf19cb9, 0x01850e00, 0xfeec527e,
+	0x00b9d02b, 0xff89ee4d, 0x0045e856, 0xffda1199,
+	0x00125e66, 0xfff86e9e, 0x00026126, 0xffffa045,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x08365690, 0xfab32723, 0x041718d2, 0xfcbe1789,
+	0x029279c4, 0xfe052ad4, 0x01788354, 0xfef41e8c,
+	0x00b52925, 0xff8c91ad, 0x0044806c, 0xffdac35a,
+	0x00120e9b, 0xfff88e35, 0x000256b9, 0xffffa2be,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x072bd3c5, 0xfb2b7641, 0x03cfdf29, 0xfcebdb26,
+	0x02745f8c, 0xfe18e58c, 0x016bd54f, 0xfefc04c6,
+	0x00b06ff7, 0xff8f40d0, 0x00431177, 0xffdb78ef,
+	0x0011bcf9, 0xfff8ae88, 0x00024c18, 0xffffa539,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0624aad6, 0xfba366df, 0x03889336, 0xfd19cb0e,
+	0x02561670, 0xfe2cc9a7, 0x015f0612, 0xff0403cc,
+	0x00aba57c, 0xff91fb31, 0x00419bc2, 0xffdc3231,
+	0x00116994, 0xfff8cf8d, 0x00024146, 0xffffa7b7,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0520ec00, 0xfc1ae8f2, 0x03413f7b, 0xfd47e035,
+	0x0237a337, 0xfe40d3ed, 0x015217c0, 0xff0c1a3c,
+	0x00a6ca90, 0xff94c04f, 0x00401f98, 0xffdceef9,
+	0x00111480, 0xfff8f13c, 0x00023645, 0xffffaa35,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0420a716, 0xfc91eca1, 0x02f9ee68, 0xfd761395,
+	0x02190aa6, 0xfe550124, 0x01450c7f, 0xff1446b5,
+	0x00a1e00f, 0xff978fa6, 0x003e9d42, 0xffddaf1e,
+	0x0010bdcf, 0xfff9138e, 0x00022b19, 0xffffacb4,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0323eb7f, 0xfd086246, 0x02b2aa5c, 0xfda45e2c,
+	0x01fa5183, 0xfe694e12, 0x0137e672, 0xff1c87d3,
+	0x009ce6d8, 0xff9a68b0, 0x003d150d, 0xffde727a,
+	0x00106595, 0xfff93679, 0x00021fc5, 0xffffaf33,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
+
+static s32 sinc_coef[SINC8_FILTER_COEF_SIZE] = {
+	0x2ccccccd, 0x2440a9d0, 0x1063d655, 0xfde6dcbb,
+	0xf68692d2, 0xfa6f621e, 0x01fee099, 0x055e3775,
+	0x02bc8b72, 0xfe2a8d09, 0xfc7665a3, 0xfe956e3f,
+	0x01a01620, 0x026e03d6, 0x00ad9260, 0xfe9d324b,
+	0xfe555d13, 0xffc14197, 0x0121f722, 0x011d0e04,
+	0x00000000, 0xff1e2930, 0xff4a325e, 0x001f0fc3,
+	0x00a62ef7, 0x006c3756, 0xffd6cf32, 0xff8e135f,
+	0xffc5c7b9, 0x0026442b, 0x0046f3c9, 0x001ac227,
+	0x2ccca901, 0x2420bc3d, 0x10396c36, 0xfdcb7879,
+	0xf684dbd3, 0xfa7dead7, 0x020b8402, 0x055e49fc,
+	0x02b38232, 0xfe233882, 0xfc775567, 0xfe9bd934,
+	0x01a490ea, 0x026c98ca, 0x00a8dd14, 0xfe9a7f19,
+	0xfe56edee, 0xffc4afca, 0x01237ec3, 0x011b8e0d,
+	0xfffd9280, 0xff1d65ae, 0xff4b7ffe, 0x0020b33e,
+	0x00a6783e, 0x006b2d6c, 0xffd5c6cc, 0xff8e0e9c,
+	0xffc688fd, 0x0026dad7, 0x0046da04, 0x001a453c,
+	0x2ccc3d9e, 0x24009fec, 0x100f0910, 0xfdb043b7,
+	0xf68353f7, 0xfa8c81a0, 0x02181471, 0x055e42c0,
+	0x02aa714a, 0xfe1bf0e2, 0xfc7855a3, 0xfea247b5,
+	0x01a901b6, 0x026b22c1, 0x00a426bc, 0xfe97d3d1,
+	0xfe588612, 0xffc81d94, 0x01250039, 0x011a096f,
+	0xfffb262a, 0xff1ca6ce, 0xff4cd065, 0x0022554a,
+	0x00a6be3a, 0x006a2208, 0xffd4bfc8, 0xff8e0c07,
+	0xffc74ae2, 0x00277061, 0x0046bef4, 0x0019c82e,
+	0x2ccb8aa5, 0x23e05538, 0x0fe4ad4e, 0xfd953ea0,
+	0xf681fb15, 0xfa9b262c, 0x022491b9, 0x055e21d1,
+	0x02a158e9, 0xfe14b644, 0xfc796649, 0xfea8b9a2,
+	0x01ad6875, 0x0269a1c8, 0x009f6f6e, 0xfe95307a,
+	0xfe5a2575, 0xffcb8ae4, 0x01267b82, 0x01188033,
+	0xfff8bb09, 0xff1bec90, 0xff4e2389, 0x0023f5e0,
+	0x00a700eb, 0x00691531, 0xffd3ba2a, 0xff8e0b9f,
+	0xffc80d63, 0x002804c6, 0x0046a29a, 0x00194aff,
+	0x2cca9017, 0x23bfdc7c, 0x0fba595c, 0xfd7a6960,
+	0xf680d102, 0xfaa9d82d, 0x0230fbb1, 0x055de740,
+	0x0298393e, 0xfe0d88c4, 0xfc7a874c, 0xfeaf2eda,
+	0x01b1c516, 0x026815ea, 0x009ab742, 0xfe92951f,
+	0xfe5bcc0b, 0xffcef7aa, 0x0127f097, 0x0116f263,
+	0xfff6512a, 0xff1b36f6, 0xff4f7965, 0x002594f8,
+	0x00a74050, 0x006806ed, 0xffd2b5f5, 0xff8e0d62,
+	0xffc8d07d, 0x00289806, 0x004684f8, 0x0018cdb4,
+	0x2cc94df9, 0x239f3613, 0x0f900da4, 0xfd5fc420,
+	0xf67fd594, 0xfab89756, 0x023d522b, 0x055d931f,
+	0x028f1279, 0xfe06687d, 0xfc7bb89e, 0xfeb5a73d,
+	0x01b6178a, 0x02667f35, 0x0095fe4e, 0xfe9001c9,
+	0xfe5d79c9, 0xffd263d6, 0x01295f75, 0x01156008,
+	0xfff3e896, 0xff1a8601, 0xff50d1f0, 0x0027328b,
+	0x00a77c6b, 0x0066f741, 0xffd1b32e, 0xff8e1150,
+	0xffc9942b, 0x00292a1c, 0x0046660f, 0x0018504d,
+	0x2cc7c44d, 0x237e625a, 0x0f65ca90, 0xfd454f09,
+	0xf67f089e, 0xfac76359, 0x024994fe, 0x055d257f,
+	0x0285e4c8, 0xfdff5588, 0xfc7cfa31, 0xfebc22ab,
+	0x01ba5fc0, 0x0264ddb4, 0x009144a9, 0xfe8d7680,
+	0xfe5f2ea4, 0xffd5cf58, 0x012ac818, 0x0113c92c,
+	0xfff1815a, 0xff19d9b3, 0xff522d21, 0x0028ce92,
+	0x00a7b53c, 0x0065e633, 0xffd0b1d9, 0xff8e1766,
+	0xffca586a, 0x0029bb08, 0x004645e0, 0x0017d2cd,
+	0x2cc5f318, 0x235d61ae, 0x0f3b908c, 0xfd2b0a43,
+	0xf67e69f5, 0xfad63be9, 0x0255c400, 0x055c9e74,
+	0x027cb05a, 0xfdf85000, 0xfc7e4bf7, 0xfec2a102,
+	0x01be9da9, 0x02633175, 0x008c8a6b, 0xfe8af34d,
+	0xfe60ea90, 0xffd93a1f, 0x012c2a7b, 0x01122dd8,
+	0xffef1b7f, 0xff19320c, 0xff538af2, 0x002a6907,
+	0x00a7eac3, 0x0064d3ca, 0xffcfb1fb, 0xff8e1fa4,
+	0xffcb1d35, 0x002a4ac7, 0x0046246e, 0x00175538,
+	0x2cc3da5f, 0x233c346b, 0x0f116001, 0xfd10f5f7,
+	0xf67df96b, 0xfae520b8, 0x0261df07, 0x055bfe0f,
+	0x0273755f, 0xfdf157ff, 0xfc7fade2, 0xfec92224,
+	0x01c2d135, 0x02617a84, 0x0087cfab, 0xfe887839,
+	0xfe62ad83, 0xffdca41c, 0x012d869b, 0x01108e17,
+	0xffecb711, 0xff188f0e, 0xff54eb5b, 0x002c01e1,
+	0x00a81d02, 0x0063c00b, 0xffceb397, 0xff8e2a08,
+	0xffcbe288, 0x002ad958, 0x004601ba, 0x0016d78f,
+	0x2cc17a28, 0x231adaef, 0x0ee7395a, 0xfcf7124a,
+	0xf67db6d5, 0xfaf41179, 0x026de5ea, 0x055b4463,
+	0x026a3406, 0xfdea6d9f, 0xfc811fe2, 0xfecfa5f0,
+	0x01c6fa56, 0x025fb8ef, 0x0083147e, 0xfe86054b,
+	0xfe647770, 0xffe00d3e, 0x012edc74, 0x010ee9f3,
+	0xffea541b, 0xff17f0b9, 0xff564e53, 0x002d991b,
+	0x00a84bf8, 0x0062aafd, 0xffcdb6b2, 0xff8e3691,
+	0xffcca85e, 0x002b66b7, 0x0045ddc5, 0x001659d6,
+	0x2cbed27b, 0x22f95597, 0x0ebd1cff, 0xfcdd5f64,
+	0xf67da203, 0xfb030de0, 0x0279d87f, 0x055a7185,
+	0x0260ec7d, 0xfde390f8, 0xfc82a1e8, 0xfed62c45,
+	0x01cb18fc, 0x025decc2, 0x007e58fd, 0xfe839a8c,
+	0xfe66484c, 0xffe37576, 0x01302c03, 0x010d4174,
+	0xffe7f2a7, 0xff17570f, 0xff57b3d2, 0x002f2eac,
+	0x00a877a7, 0x006194a5, 0xffccbb4f, 0xff8e453d,
+	0xffcd6eb5, 0x002bf2e4, 0x0045b890, 0x0015dc0e,
+	0x2cbbe35e, 0x22d7a4c3, 0x0e930b5a, 0xfcc3dd6a,
+	0xf67dbac8, 0xfb12159d, 0x0285b69f, 0x05598589,
+	0x02579ef5, 0xfddcc224, 0xfc8433e6, 0xfedcb503,
+	0x01cf2d18, 0x025c160b, 0x00799d3d, 0xfe813804,
+	0xfe68200b, 0xffe6dcb3, 0x01317543, 0x010b94a5,
+	0xffe592c2, 0xff16c20f, 0xff591bd1, 0x0030c28f,
+	0x00a8a010, 0x00607d09, 0xffcbc173, 0xff8e560a,
+	0xffce3587, 0x002c7ddd, 0x0045921e, 0x00155e3b,
+	0x2cb8acdb, 0x22b5c8d0, 0x0e6904d4, 0xfcaa8c81,
+	0xf67e00f5, 0xfb212866, 0x02918022, 0x05588082,
+	0x024e4b9c, 0xfdd6013c, 0xfc85d5cc, 0xfee3400a,
+	0x01d3369d, 0x025a34d7, 0x0074e156, 0xfe7eddba,
+	0xfe69fea1, 0xffea42e5, 0x0132b832, 0x0109e391,
+	0xffe33474, 0xff1631bb, 0xff5a8647, 0x003254bc,
+	0x00a8c534, 0x005f6430, 0xffcac921, 0xff8e68f7,
+	0xffcefcd0, 0x002d079e, 0x00456a70, 0x0014e05e,
+	0x2cb52efb, 0x2293c21f, 0x0e3f09d6, 0xfc916ccd,
+	0xf67e745a, 0xfb3045eb, 0x029d34e0, 0x05576285,
+	0x0244f2a1, 0xfdcf4e57, 0xfc878789, 0xfee9cd3a,
+	0x01d7357b, 0x02584935, 0x0070255e, 0xfe7c8bb7,
+	0xfe6be402, 0xffeda7fd, 0x0133f4cc, 0x01082e41,
+	0xffe0d7c9, 0xff15a613, 0xff5bf32d, 0x0033e52d,
+	0x00a8e713, 0x005e4a1e, 0xffc9d25d, 0xff8e7e03,
+	0xffcfc48d, 0x002d9027, 0x00454188, 0x0014627b,
+	0x2cb169c7, 0x2271910e, 0x0e151ac9, 0xfc787e72,
+	0xf67f14c9, 0xfb3f6de1, 0x02a8d4b2, 0x05562ba8,
+	0x023b9434, 0xfdc8a98f, 0xfc89490f, 0xfef05c72,
+	0x01db29a5, 0x02565333, 0x006b696c, 0xfe7a4201,
+	0xfe6dd023, 0xfff10bea, 0x01352b0e, 0x010674bf,
+	0xffde7ccc, 0xff151f17, 0xff5d627a, 0x003573db,
+	0x00a905ae, 0x005d2edc, 0xffc8dd2b, 0xff8e952c,
+	0xffd08cb8, 0x002e1776, 0x00451768, 0x0013e493,
+	0x2cad5d4b, 0x224f35fe, 0x0deb3814, 0xfc5fc193,
+	0xf67fe211, 0xfb4e9ff9, 0x02b45f73, 0x0554dc00,
+	0x02323084, 0xfdc212fa, 0xfc8b1a4b, 0xfef6ed93,
+	0x01df130d, 0x025452de, 0x0066ad97, 0xfe7800a0,
+	0xfe6fc2f6, 0xfff46e9e, 0x01365af6, 0x0104b716,
+	0xffdc2388, 0xff149cc8, 0xff5ed426, 0x003700bf,
+	0x00a92108, 0x005c126e, 0xffc7e990, 0xff8eae70,
+	0xffd1554f, 0x002e9d89, 0x0044ec10, 0x001366aa,
+	0x2ca90993, 0x222cb14f, 0x0dc16220, 0xfc473651,
+	0xf680dc01, 0xfb5ddbe8, 0x02bfd4fb, 0x055373a3,
+	0x0228c7bf, 0xfdbb8ab0, 0xfc8cfb2f, 0xfefd807b,
+	0x01e2f1a5, 0x02524845, 0x0061f1f6, 0xfe75c79b,
+	0xfe71bc6f, 0xfff7d007, 0x0137847f, 0x0102f550,
+	0xffd9cc06, 0xff141f27, 0xff604829, 0x00388bd2,
+	0x00a9391f, 0x005af4da, 0xffc6f78e, 0xff8ec9cd,
+	0xffd21e4d, 0x002f225e, 0x0044bf83, 0x0012e8c2,
+	0x2ca46eaa, 0x220a0362, 0x0d979954, 0xfc2edccf,
+	0xf6820268, 0xfb6d2161, 0x02cb3525, 0x0551f2a7,
+	0x021f5a16, 0xfdb510c9, 0xfc8eeba9, 0xff04150c,
+	0x01e6c55f, 0x02503376, 0x005d369e, 0xfe7396fa,
+	0xfe73bc83, 0xfffb3017, 0x0138a7a8, 0x01012f77,
+	0xffd77651, 0xff13a633, 0xff61be7b, 0x003a150e,
+	0x00a94df7, 0x0059d627, 0xffc6072a, 0xff8ee741,
+	0xffd2e7ad, 0x002fa5f2, 0x004491c3, 0x00126add,
+	0x2c9f8ca0, 0x21e72c99, 0x0d6dde17, 0xfc16b52c,
+	0xf6835514, 0xfb7c7015, 0x02d67fcd, 0x05505923,
+	0x0215e7b7, 0xfdaea55b, 0xfc90eba8, 0xff0aab24,
+	0x01ea8e30, 0x024e147f, 0x00587ba7, 0xfe716ec2,
+	0xfe75c324, 0xfffe8ebd, 0x0139c46e, 0x00ff6596,
+	0xffd52275, 0xff1331ec, 0xff633713, 0x003b9c6d,
+	0x00a95f91, 0x0058b65b, 0xffc51867, 0xff8f06cc,
+	0xffd3b16c, 0x00302846, 0x004462d1, 0x0011ecff,
+	0x2c9a6381, 0x21c42d54, 0x0d4430d1, 0xfbfebf8a,
+	0xf684d3d4, 0xfb8bc7ba, 0x02e1b4cd, 0x054ea72d,
+	0x020c70d0, 0xfda8487d, 0xfc92fb1a, 0xff1142a4,
+	0x01ee4c09, 0x024beb71, 0x0053c127, 0xfe6f4efb,
+	0xfe77d046, 0x0001ebeb, 0x013adace, 0x00fd97b7,
+	0xffd2d07a, 0xff12c253, 0xff64b1ea, 0x003d21e7,
+	0x00a96ded, 0x0057957c, 0xffc42b49, 0xff8f286b,
+	0xffd47b85, 0x0030a956, 0x004432ae, 0x00116f28,
+	0x2c94f35c, 0x21a105f7, 0x0d1a91e8, 0xfbe6fc07,
+	0xf6867e73, 0xfb9b2802, 0x02ecd402, 0x054cdcde,
+	0x0202f592, 0xfda1fa45, 0xfc9519ef, 0xff17db6c,
+	0x01f1fedd, 0x0249b858, 0x004f0734, 0xfe6d37aa,
+	0xfe79e3dc, 0x00054790, 0x013beac6, 0x00fbc5e5,
+	0xffd0806c, 0xff125767, 0xff662ef7, 0x003ea577,
+	0x00a9790c, 0x0056738f, 0xffc33fd4, 0xff8f4c1b,
+	0xffd545f5, 0x00312921, 0x0044015e, 0x0010f15c,
+	0x2c8f3c42, 0x217db6e3, 0x0cf101c3, 0xfbcf6ac2,
+	0xf68854c0, 0xfbaa90a0, 0x02f7dd48, 0x054afa4d,
+	0x01f9762c, 0xfd9bbac8, 0xfc974813, 0xff1e755b,
+	0x01f5a6a2, 0x02477b46, 0x004a4de5, 0xfe6b28d7,
+	0xfe7bfdd9, 0x0008a19e, 0x013cf453, 0x00f9f02a,
+	0xffce3255, 0xff11f128, 0xff67ae32, 0x00402715,
+	0x00a980f2, 0x0055509b, 0xffc2560a, 0xff8f71dc,
+	0xffd610b6, 0x0031a7a6, 0x0043cee1, 0x0010739e,
+	0x2c893e42, 0x215a407b, 0x0cc780c8, 0xfbb80bd9,
+	0xf68a5687, 0xfbba0149, 0x0302d07b, 0x0548ff93,
+	0x01eff2cc, 0xfd958a1d, 0xfc998576, 0xff251052,
+	0x01f94349, 0x02453448, 0x00459550, 0xfe692287,
+	0xfe7e1e31, 0x000bfa04, 0x013df775, 0x00f81691,
+	0xffcbe640, 0xff118f96, 0xff692f92, 0x0041a6bd,
+	0x00a9859e, 0x00542ca7, 0xffc16df1, 0xff8f99ab,
+	0xffd6dbc6, 0x003224e2, 0x00439b3a, 0x000ff5ef,
+	0x2c82f96f, 0x2136a323, 0x0c9e0f5c, 0xfba0df69,
+	0xf68c8394, 0xfbc979af, 0x030dad79, 0x0546ecc7,
+	0x01e66ba1, 0xfd8f685a, 0xfc9bd204, 0xff2bac31,
+	0x01fcd4c8, 0x0242e36f, 0x0040dd8b, 0xfe6724c0,
+	0xfe8044d6, 0x000f50b3, 0x013ef427, 0x00f63924,
+	0xffc99c35, 0xff1132b0, 0xff6ab30f, 0x00432466,
+	0x00a98713, 0x005307b8, 0xffc0878a, 0xff8fc387,
+	0xffd7a720, 0x0032a0d5, 0x0043666a, 0x000f7853,
+	0x2c7c6ddb, 0x2112df3e, 0x0c74ade4, 0xfb89e58f,
+	0xf68edbb2, 0xfbd8f987, 0x0318741f, 0x0544c202,
+	0x01dce0da, 0xfd895591, 0xfc9e2dac, 0xff3248d8,
+	0x02005b12, 0x024088c9, 0x003c26ae, 0xfe652f88,
+	0xfe8271bb, 0x0012a59d, 0x013fea6a, 0x00f457ef,
+	0xffc75440, 0xff10da77, 0xff6c38a1, 0x0044a00c,
+	0x00a98552, 0x0051e1d4, 0xffbfa2db, 0xff8fef6d,
+	0xffd872bf, 0x00331b7c, 0x00433073, 0x000efacb,
+	0x2c759b98, 0x20eef530, 0x0c4b5cc7, 0xfb731e67,
+	0xf6915eab, 0xfbe88085, 0x0323244d, 0x05427f5f,
+	0x01d352a7, 0xfd8351da, 0xfca0985a, 0xff38e627,
+	0x0203d61b, 0x023e2467, 0x003770cd, 0xfe6342e5,
+	0xfe84a4d3, 0x0015f8b1, 0x0140da3a, 0x00f272fb,
+	0xffc50e6b, 0xff1086e9, 0xff6dc03f, 0x004619a7,
+	0x00a9805d, 0x0050bb01, 0xffbebfe5, 0xff901d5b,
+	0xffd93ea0, 0x003394d6, 0x0042f956, 0x000e7d5b,
+	0x2c6e82ba, 0x20cae55d, 0x0c221c69, 0xfb5c8a0c,
+	0xf6940c4c, 0xfbf80e5c, 0x032dbde0, 0x054024f6,
+	0x01c9c135, 0xfd7d5d47, 0xfca311fb, 0xff3f83fe,
+	0x020745d9, 0x023bb658, 0x0032bbfe, 0xfe615edc,
+	0xfe86de10, 0x001949e1, 0x0141c397, 0x00f08a55,
+	0xffc2cabf, 0xff103806, 0xff6f49e2, 0x00479132,
+	0x00a97836, 0x004f9347, 0xffbddead, 0xff904d4f,
+	0xffda0abf, 0x00340ce2, 0x0042c117, 0x000e0004,
+	0x2c672356, 0x20a6b02a, 0x0bf8ed2d, 0xfb462898,
+	0xf696e45d, 0xfc07a2c0, 0x033840b7, 0x053db2e1,
+	0x01c02cb5, 0xfd7777ed, 0xfca59a7d, 0xff46223e,
+	0x020aaa40, 0x02393ead, 0x002e0859, 0xfe5f8372,
+	0xfe891d66, 0x001c991d, 0x0142a67e, 0x00ee9e07,
+	0xffc08946, 0xff0fedcd, 0xff70d580, 0x004906a6,
+	0x00a96cde, 0x004e6aaa, 0xffbcff36, 0xff907f47,
+	0xffdad717, 0x0034839e, 0x004287b7, 0x000d82c9,
+	0x2c5f7d82, 0x208255fd, 0x0bcfcf79, 0xfb2ffa26,
+	0xf699e6a9, 0xfc173d66, 0x0342acb3, 0x053b293c,
+	0x01b69554, 0xfd71a1e0, 0xfca831cb, 0xff4cc0c7,
+	0x020e0346, 0x0236bd75, 0x002955f3, 0xfe5db0ac,
+	0xfe8b62c7, 0x001fe657, 0x014382ee, 0x00ecae1b,
+	0xffbe4a0b, 0xff0fa83e, 0xff726310, 0x004a79fe,
+	0x00a95e57, 0x004d4130, 0xffbc2183, 0xff90b342,
+	0xffdba3a4, 0x0034f909, 0x00424d37, 0x000d05ac,
+	0x2c579152, 0x205dd739, 0x0ba6c3af, 0xfb19fecd,
+	0xf69d12f8, 0xfc26de03, 0x034d01b4, 0x0538881f,
+	0x01acfb41, 0xfd6bdb32, 0xfcaad7d1, 0xff535f79,
+	0x021150df, 0x023432c1, 0x0024a4e2, 0xfe5be690,
+	0xfe8dae25, 0x0023317f, 0x014458e7, 0x00eaba9d,
+	0xffbc0d18, 0xff0f6757, 0xff73f28c, 0x004beb34,
+	0x00a94ca3, 0x004c16e1, 0xffbb4597, 0xff90e93b,
+	0xffdc7063, 0x00356d20, 0x0042119a, 0x000c88b0,
+	0x2c4f5ee0, 0x20393446, 0x0b7dca34, 0xfb0436a7,
+	0xf6a06914, 0xfc36844a, 0x03573f99, 0x0535cfa8,
+	0x01a35eac, 0xfd6623f8, 0xfcad8c7c, 0xff59fe34,
+	0x02149302, 0x02319ea2, 0x001ff53c, 0xfe5a2522,
+	0xfe8fff72, 0x00267a86, 0x01452867, 0x00e8c398,
+	0xffb9d275, 0xff0f2b18, 0xff7583e9, 0x004d5a40,
+	0x00a937c5, 0x004aebc2, 0xffba6b76, 0xff912133,
+	0xffdd3d4f, 0x0035dfe4, 0x0041d4e1, 0x000c0bd8,
+	0x2c46e641, 0x20146d89, 0x0b54e36a, 0xfaeea1cb,
+	0xf6a3e8c5, 0xfc462ff0, 0x03616645, 0x0532fff0,
+	0x0199bfc2, 0xfd607c43, 0xfcb04fb8, 0xff609cda,
+	0x0217c9a4, 0x022f0127, 0x001b4717, 0xfe586c66,
+	0xfe9256a1, 0x0029c15e, 0x0145f16d, 0x00e6c917,
+	0xffb79a2d, 0xff0ef37f, 0xff771720, 0x004ec71f,
+	0x00a91fbe, 0x0049bfda, 0xffb99322, 0xff915b26,
+	0xffde0a64, 0x00365152, 0x0041970f, 0x000b8f24,
+	0x2c3e278f, 0x1fef8368, 0x0b2c0fb4, 0xfad94050,
+	0xf6a791d2, 0xfc55e0aa, 0x036b7599, 0x05301914,
+	0x01901eb2, 0xfd5ae427, 0xfcb32170, 0xff673b4a,
+	0x021af4ba, 0x022c5a63, 0x00169a88, 0xfe56bc61,
+	0xfe94b3a4, 0x002d05f8, 0x0146b3f7, 0x00e4cb25,
+	0xffb56449, 0xff0ec08c, 0xff78ac28, 0x005031c9,
+	0x00a90490, 0x0048932e, 0xffb8bca0, 0xff919712,
+	0xffded79e, 0x0036c16a, 0x00415826, 0x000b1299,
+	0x2c3522e3, 0x1fca764a, 0x0b034f73, 0xfac4124c,
+	0xf6ab6403, 0xfc65962c, 0x03756d76, 0x052d1b2f,
+	0x01867bab, 0xfd555bb5, 0xfcb6018f, 0xff6dd965,
+	0x021e143c, 0x0229aa65, 0x0011efa5, 0xfe551517,
+	0xfe97166d, 0x00304844, 0x01477006, 0x00e2c9cd,
+	0xffb330d4, 0xff0e923d, 0xff7a42f8, 0x00519a39,
+	0x00a8e63e, 0x004765c5, 0xffb7e7f2, 0xff91d4f4,
+	0xffdfa4f9, 0x00373029, 0x00411827, 0x000a9638,
+	0x2c2bd857, 0x1fa54697, 0x0adaa30a, 0xfaaf17d5,
+	0xf6af5f20, 0xfc75502d, 0x037f4dbf, 0x052a065f,
+	0x017cd6db, 0xfd4fe2ff, 0xfcb8f001, 0xff74770c,
+	0x02212820, 0x0226f13f, 0x000d4683, 0xfe53768d,
+	0xfe997eee, 0x00338836, 0x01482599, 0x00e0c51b,
+	0xffb0ffd6, 0xff0e6890, 0xff7bdb88, 0x00530069,
+	0x00a8c4c9, 0x004637a4, 0xffb7151b, 0xff9214cb,
+	0xffe07271, 0x00379d8e, 0x0040d715, 0x000a1a04,
+	0x2c224806, 0x1f7ff4b5, 0x0ab20adb, 0xfa9a5100,
+	0xf6b382ee, 0xfc850e61, 0x03891658, 0x0526dabf,
+	0x01733071, 0xfd4a7a17, 0xfcbbecb0, 0xff7b1420,
+	0x0224305d, 0x02242f01, 0x00089f39, 0xfe51e0c6,
+	0xfe9bed18, 0x0036c5bc, 0x0148d4af, 0x00debd19,
+	0xffaed158, 0xff0e4386, 0xff7d75cf, 0x00546454,
+	0x00a8a035, 0x004508d3, 0xffb6441e, 0xff925693,
+	0xffe14002, 0x00380999, 0x004094f1, 0x00099dfe,
+	0x2c18720c, 0x1f5a810c, 0x0a898746, 0xfa85bde1,
+	0xf6b7cf34, 0xfc94d07c, 0x0392c724, 0x0523986e,
+	0x0169889a, 0xfd45210e, 0xfcbef787, 0xff81b081,
+	0x02272ce9, 0x022163be, 0x0003f9dc, 0xfe5053c6,
+	0xfe9e60de, 0x003a00ca, 0x01497d48, 0x00dcb1d3,
+	0xffaca566, 0xff0e231b, 0xff7f11c5, 0x0055c5f4,
+	0x00a87882, 0x0043d957, 0xffb574fe, 0xff929a4b,
+	0xffe20da7, 0x00387449, 0x004051be, 0x0009222a,
+	0x2c0e5685, 0x1f34ec04, 0x0a6118ac, 0xfa715e8b,
+	0xf6bc43b8, 0xfca49636, 0x039c6007, 0x05203f87,
+	0x015fdf86, 0xfd3fd7f4, 0xfcc21070, 0xff884c11,
+	0x022a1dbc, 0x021e8f87, 0xffff5681, 0xfe4ecf90,
+	0xfea0da32, 0x003d3951, 0x014a1f63, 0x00daa355,
+	0xffaa7c06, 0xff0e074e, 0xff80af61, 0x00572543,
+	0x00a84db4, 0x0042a936, 0xffb4a7be, 0xff92dff1,
+	0xffe2db5e, 0x0038dd9b, 0x00400d7e, 0x0008a689,
+	0x2c03f58f, 0x1f0f3605, 0x0a38bf6d, 0xfa5d3310,
+	0xf6c0e03f, 0xfcb45f43, 0x03a5e0e5, 0x051cd02a,
+	0x01563561, 0xfd3a9eda, 0xfcc53757, 0xff8ee6b0,
+	0x022d02cc, 0x021bb26d, 0xfffab53d, 0xfe4d5428,
+	0xfea35904, 0x00406f43, 0x014abb01, 0x00d891aa,
+	0xffa85544, 0xff0df01e, 0xff824e9a, 0x0058823c,
+	0x00a81fce, 0x00417876, 0xffb3dc61, 0xff932781,
+	0xffe3a921, 0x0039458e, 0x003fc833, 0x00082b1f,
+	0x2bf94f47, 0x1ee95f78, 0x0a107bea, 0xfa493b84,
+	0xf6c5a48e, 0xfcc42b5a, 0x03af49a4, 0x05194a74,
+	0x014c8a5b, 0xfd3575d1, 0xfcc86c24, 0xff95803f,
+	0x022fdc13, 0x0218cc82, 0xfff61626, 0xfe4be191,
+	0xfea5dd47, 0x0043a290, 0x014b5020, 0x00d67cdd,
+	0xffa63128, 0xff0ddd89, 0xff83ef68, 0x0059dcd9,
+	0x00a7eed0, 0x0040471f, 0xffb312e9, 0xff9370f8,
+	0xffe476ec, 0x0039ac23, 0x003f81de, 0x0007afec,
+	0x2bee63cd, 0x1ec368c5, 0x09e84e81, 0xfa3577f7,
+	0xf6ca9069, 0xfcd3fa2f, 0x03b89a28, 0x0515ae84,
+	0x0142dea0, 0xfd305ce8, 0xfccbaec1, 0xff9c189f,
+	0x0232a987, 0x0215ddd8, 0xfff17951, 0xfe4a77ce,
+	0xfea866ec, 0x0046d32b, 0x014bdec3, 0x00d464f9,
+	0xffa40fbc, 0xff0dcf8e, 0xff8591c2, 0x005b3515,
+	0x00a7babf, 0x003f1535, 0xffb24b5b, 0xff93bc56,
+	0xffe544bd, 0x003a1157, 0x003f3a83, 0x000734f5,
+	0x2be33340, 0x1e9d5256, 0x09c03792, 0xfa21e87a,
+	0xf6cfa395, 0xfce3cb7b, 0x03c1d258, 0x0511fc78,
+	0x01393260, 0xfd2b542e, 0xfcceff19, 0xffa2afb2,
+	0x02356b22, 0x0212e681, 0xffecded3, 0xfe4916e2,
+	0xfeaaf5e4, 0x004a0106, 0x014c66e7, 0x00d24a0b,
+	0xffa1f107, 0xff0dc629, 0xff87359f, 0x005c8aea,
+	0x00a7839c, 0x003de2bf, 0xffb185b7, 0xff940996,
+	0xffe6128e, 0x003a7529, 0x003ef223, 0x0006ba39,
+	0x2bd7bdc1, 0x1e771c95, 0x0998377b, 0xfa0e8d1c,
+	0xf6d4ddd6, 0xfcf39ef2, 0x03caf21a, 0x050e346f,
+	0x012f85c7, 0xfd265bb3, 0xfcd25d14, 0xffa94558,
+	0x023820da, 0x020fe68f, 0xffe846c1, 0xfe47becf,
+	0xfead8a21, 0x004d2c12, 0x014ce88f, 0x00d02c1d,
+	0xff9fd514, 0xff0dc15a, 0xff88daf6, 0x005dde54,
+	0x00a7496b, 0x003cafc3, 0xffb0c202, 0xff9458b7,
+	0xffe6e05c, 0x003ad79a, 0x003ea8c1, 0x00063fbd,
+	0x2bcc0370, 0x1e50c7e9, 0x09704e9b, 0xf9fb65ed,
+	0xf6da3eef, 0xfd03744b, 0x03d3f955, 0x050a5688,
+	0x0125d904, 0xfd217386, 0xfcd5c89b, 0xffafd974,
+	0x023acaa9, 0x020cde14, 0xffe3b130, 0xfe466f99,
+	0xfeb02395, 0x00505442, 0x014d63bb, 0x00ce0b3c,
+	0xff9dbbec, 0xff0dc11e, 0xff8a81c0, 0x005f2f4d,
+	0x00a70c2e, 0x003b7c48, 0xffb0003d, 0xff94a9b5,
+	0xffe7ae23, 0x003b38a6, 0x003e5e5e, 0x0005c583,
+	0x2bc00470, 0x1e2a54be, 0x09487d50, 0xf9e872fc,
+	0xf6dfc6a3, 0xfd134b3d, 0x03dce7f1, 0x050662e5,
+	0x011c2c44, 0xfd1c9bb6, 0xfcd94199, 0xffb66be6,
+	0x023d6888, 0x0209cd23, 0xffdf1e34, 0xfe452941,
+	0xfeb2c22f, 0x00537988, 0x014dd86a, 0x00cbe773,
+	0xff9ba596, 0xff0dc573, 0xff8c29f3, 0x00607dd0,
+	0x00a6cbe7, 0x003a4853, 0xffaf406b, 0xff94fc8f,
+	0xffe87bde, 0x003b984e, 0x003e12fc, 0x00054b8b,
+	0x2bb3c0e3, 0x1e03c37e, 0x0920c3f7, 0xf9d5b456,
+	0xf6e574b4, 0xfd23237f, 0x03e5bdd5, 0x050259a3,
+	0x01127fb4, 0xfd17d44f, 0xfcdcc7f4, 0xffbcfc90,
+	0x023ffa6f, 0x0206b3ce, 0xffda8de3, 0xfe43ebca,
+	0xfeb565e2, 0x00569bd5, 0x014e469e, 0x00c9c0ce,
+	0xff99921d, 0xff0dce57, 0xff8dd386, 0x0061c9d7,
+	0x00a6889a, 0x003913ea, 0xffae8290, 0xff955141,
+	0xffe9498a, 0x003bf691, 0x003dc69f, 0x0004d1da,
+	0x2ba738ed, 0x1ddd1493, 0x08f922ec, 0xf9c32a08,
+	0xf6eb48e5, 0xfd32fcc8, 0x03ee7ae9, 0x04fe3ae4,
+	0x0108d382, 0xfd131d62, 0xfce05b97, 0xffc38b54,
+	0x02428059, 0x02039228, 0xffd60051, 0xfe42b736,
+	0xfeb80e9e, 0x0059bb1c, 0x014eae58, 0x00c79757,
+	0xff978188, 0xff0ddbc7, 0xff8f7e70, 0x0063135e,
+	0x00a64249, 0x0037df14, 0xffadc6ad, 0xff95a7c8,
+	0xffea1723, 0x003c536d, 0x003d7948, 0x00045871,
+	0x2b9a6cb2, 0x1db64868, 0x08d19a8d, 0xf9b0d41f,
+	0xf6f142f7, 0xfd42d6cf, 0x03f71f18, 0x04fa06c8,
+	0x00ff27db, 0xfd0e76fa, 0xfce3fc69, 0xffca1813,
+	0x0244fa3e, 0x02006843, 0xffd17593, 0xfe418b86,
+	0xfebabc55, 0x005cd750, 0x014f0f98, 0x00c56b1c,
+	0xff9573e0, 0xff0dedc1, 0xff912aaa, 0x00645a5f,
+	0x00a5f8f8, 0x0036a9d8, 0xffad0cc5, 0xff960023,
+	0xffeae4a5, 0x003caee2, 0x003d2af9, 0x0003df51,
+	0x2b8d5c57, 0x1d8f5f67, 0x08aa2b35, 0xf99eb2a7,
+	0xf6f762ad, 0xfd52b14c, 0x03ffaa49, 0x04f5bd70,
+	0x00f57ced, 0xfd09e125, 0xfce7aa52, 0xffd0a2af,
+	0x02476818, 0x01fd3633, 0xffccedbd, 0xfe4068bc,
+	0xfebd6ef7, 0x005ff063, 0x014f6a60, 0x00c33c28,
+	0xff93692f, 0xff0e0443, 0xff92d82a, 0x00659ed6,
+	0x00a5aca9, 0x0035743a, 0xffac54da, 0xff965a4d,
+	0xffebb20c, 0x003d08ee, 0x003cdbb4, 0x0003667e,
+	0x2b800802, 0x1d6859fd, 0x0882d541, 0xf98cc5a9,
+	0xf6fda7c7, 0xfd628bf7, 0x04081c68, 0x04f15efe,
+	0x00ebd2e4, 0xfd055bf0, 0xfceb653b, 0xffd72b0b,
+	0x0249c9e1, 0x01f9fc0a, 0xffc868e4, 0xfe3f4eda,
+	0xfec02675, 0x00630646, 0x014fbeb1, 0x00c10a86,
+	0xff91617c, 0xff0e1f49, 0xff9486e7, 0x0066e0be,
+	0x00a55d5f, 0x00343e41, 0xffab9eef, 0xff96b645,
+	0xffec7f54, 0x003d6192, 0x003c8b7d, 0x0002edfa,
+	0x2b726fd9, 0x1d413893, 0x085b990a, 0xf97b0d31,
+	0xf7041206, 0xfd726687, 0x0410755d, 0x04eceb92,
+	0x00e229ee, 0xfd00e768, 0xfcef2d0b, 0xffddb107,
+	0x024c1f94, 0x01f6b9dc, 0xffc3e71c, 0xfe3e3de2,
+	0xfec2e2c1, 0x006618ee, 0x01500c8b, 0x00bed643,
+	0xff8f5ccf, 0xff0e3ed3, 0xff9636d9, 0x00682012,
+	0x00a50b1d, 0x003307f4, 0xffaaeb06, 0xff971407,
+	0xffed4c79, 0x003db8cd, 0x003c3a54, 0x000275c6,
+	0x2b649404, 0x1d19fb96, 0x083476ed, 0xf9698949,
+	0xf70aa12b, 0xfd8240b4, 0x0418b515, 0x04e8634f,
+	0x00d88236, 0xfcfc8399, 0xfcf301ab, 0xffe43486,
+	0x024e692b, 0x01f36fbc, 0xffbf6879, 0xfe3d35d3,
+	0xfec5a3ca, 0x0069284b, 0x015053f1, 0x00bc9f6a,
+	0xff8d5b32, 0xff0e62db, 0xff97e7f6, 0x00695ccd,
+	0x00a4b5e7, 0x0031d158, 0xffaa3921, 0xff977391,
+	0xffee1978, 0x003e0e9c, 0x003be83d, 0x0001fde6,
+	0x2b5674ab, 0x1cf2a372, 0x080d6f43, 0xf95839f8,
+	0xf71154f5, 0xfd921a37, 0x0420db7a, 0x04e3c656,
+	0x00cedbeb, 0xfcf8308f, 0xfcf6e300, 0xffeab56a,
+	0x0250a6a0, 0x01f01dbc, 0xffbaed10, 0xfe3c36b0,
+	0xfec86981, 0x006c3452, 0x015094e5, 0x00ba6607,
+	0xff8b5cad, 0xff0e8b61, 0xff999a37, 0x006a96ea,
+	0x00a45dbf, 0x00309a73, 0xffa98944, 0xff97d4df,
+	0xffeee64c, 0x003e6301, 0x003b953a, 0x0001865a,
+	0x2b4811f7, 0x1ccb3092, 0x07e68267, 0xf9471f48,
+	0xf7182d24, 0xfda1f2c9, 0x0428e878, 0x04df14cb,
+	0x00c53738, 0xfcf3ee56, 0xfcfad0f3, 0xfff13396,
+	0x0252d7ef, 0x01ecc3f2, 0xffb674f4, 0xfe3b4079,
+	0xfecb33d8, 0x006f3cf5, 0x0150cf67, 0x00b82a26,
+	0xff896147, 0xff0eb860, 0xff9b4d92, 0x006bce65,
+	0x00a402aa, 0x002f634c, 0xffa8db6f, 0xff9837ef,
+	0xffefb2f1, 0x003eb5fa, 0x003b414c, 0x00010f25,
+	0x2b396c11, 0x1ca3a363, 0x07bfb0b0, 0xf936393f,
+	0xf71f2978, 0xfdb1ca21, 0x0430dbfc, 0x04da4ece,
+	0x00bb944a, 0xfcefbcf8, 0xfcfecb6a, 0xfff7aeec,
+	0x0254fd13, 0x01e9626f, 0xffb20039, 0xfe3a532e,
+	0xfece02bd, 0x00724227, 0x01510379, 0x00b5ebd3,
+	0xff876909, 0xff0ee9d6, 0xff9d01fe, 0x006d033a,
+	0x00a3a4a9, 0x002e2be9, 0xffa82fa6, 0xff989cbe,
+	0xfff07f64, 0x003f0786, 0x003aec77, 0x0000984a,
+	0x2b2a8324, 0x1c7bfc52, 0x0798fa7a, 0xf92587e5,
+	0xf72649af, 0xfdc19ffa, 0x0438b5f3, 0x04d57485,
+	0x00b1f34e, 0xfceb9c80, 0xfd02d24d, 0xfffe274e,
+	0x02571607, 0x01e5f948, 0xffad8ef4, 0xfe396ed1,
+	0xfed0d623, 0x007543da, 0x0151311e, 0x00b3ab1a,
+	0xff8573fb, 0xff0f1fc0, 0xff9eb773, 0x006e3563,
+	0x00a343c0, 0x002cf44f, 0xffa785e9, 0xff990348,
+	0xfff14ba1, 0x003f57a5, 0x003a96bc, 0x000021ca,
+	0x2b1b575a, 0x1c543bca, 0x0772601b, 0xf9150b40,
+	0xf72d8d89, 0xfdd1740c, 0x04407649, 0x04d08611,
+	0x00a8546f, 0xfce78cfa, 0xfd06e582, 0x00049c9f,
+	0x025922c7, 0x01e28891, 0xffa92137, 0xfe389361,
+	0xfed3adfa, 0x00784203, 0x01515858, 0x00b16806,
+	0xff838225, 0xff0f5a1b, 0xffa06de8, 0x006f64db,
+	0x00a2dff4, 0x002bbc85, 0xffa6de3c, 0xff996b8c,
+	0xfff217a3, 0x003fa656, 0x003a401f, 0xffffaba8,
+	0x2b0be8e0, 0x1c2c6239, 0x074be1ec, 0xf904c354,
+	0xf734f4c4, 0xfde14612, 0x04481cec, 0x04cb8396,
+	0x009eb7d9, 0xfce38e6f, 0xfd0b04ef, 0x000b0ec2,
+	0x025b234e, 0x01df105d, 0xffa4b717, 0xfe37c0df,
+	0xfed68a31, 0x007b3c93, 0x01517928, 0x00af22a5,
+	0xff81938f, 0xff0f98e4, 0xffa22553, 0x007091a0,
+	0x00a27946, 0x002a8492, 0xffa638a1, 0xff99d585,
+	0xfff2e368, 0x003ff398, 0x0039e8a0, 0xffff35e5,
+	0x2afc37e1, 0x1c04700c, 0x07258044, 0xf8f4b028,
+	0xf73c7f1d, 0xfdf115c3, 0x044fa9cb, 0x04c66d38,
+	0x00951db9, 0xfcdfa0ea, 0xfd0f307b, 0x00117d9a,
+	0x025d179a, 0x01db90c1, 0xffa050a7, 0xfe36f74a,
+	0xfed96ab9, 0x007e337f, 0x01519391, 0x00acdb01,
+	0xff7fa841, 0xff0fdc16, 0xffa3ddad, 0x0071bbac,
+	0x00a20fbb, 0x00294c7a, 0xffa59519, 0xff9a4131,
+	0xfff3aeec, 0x00403f6c, 0x00399043, 0xfffec084,
+	0x2aec448d, 0x1bdc65b1, 0x06ff3b7a, 0xf8e4d1be,
+	0xf7442c53, 0xfe00e2dc, 0x04571cd5, 0x04c1431b,
+	0x008b863b, 0xfcdbc474, 0xfd13680d, 0x0017e908,
+	0x025effa5, 0x01d809d0, 0xff9bedfb, 0xfe3636a4,
+	0xfedc4f82, 0x008126b9, 0x0151a795, 0x00aa9128,
+	0xff7dc042, 0xff1023b0, 0xffa596ed, 0x0072e2fb,
+	0x00a1a356, 0x00281444, 0xffa4f3a7, 0xff9aae8c,
+	0xfff47a29, 0x004089d0, 0x0039370a, 0xfffe4b86,
+	0x2adc0f0f, 0x1bb44393, 0x06d913e5, 0xf8d52819,
+	0xf74bfc23, 0xfe10ad15, 0x045e75f9, 0x04bc0563,
+	0x0081f189, 0xfcd7f916, 0xfd17ab89, 0x001e50f2,
+	0x0260db6d, 0x01d47b9f, 0xff978f26, 0xfe357eea,
+	0xfedf387d, 0x00841635, 0x0151b537, 0x00a84524,
+	0xff7bdb9a, 0xff106fad, 0xffa75108, 0x00740789,
+	0x00a1341b, 0x0026dbf6, 0xffa4544c, 0xff9b1d94,
+	0xfff5451e, 0x0040d2c5, 0x0038dcf8, 0xfffdd6ee,
+	0x2acb9798, 0x1b8c0a22, 0x06b309db, 0xf8c5b33e,
+	0xf753ee4a, 0xfe207429, 0x0465b526, 0x04b6b435,
+	0x00785fd0, 0xfcd43eda, 0xfd1bfad6, 0x0024b539,
+	0x0262aaef, 0x01d0e642, 0xff93343b, 0xfe34d01d,
+	0xfee2259a, 0x008701e7, 0x0151bc79, 0x00a5f703,
+	0xff79fa51, 0xff10c009, 0xffa90bf8, 0x00752951,
+	0x00a0c20d, 0x0025a397, 0xffa3b70a, 0xff9b8e45,
+	0xfff60fc6, 0x00411a48, 0x0038820e, 0xfffd62be,
+	0x2abade57, 0x1b63b9ca, 0x068d1db0, 0xf8b6732d,
+	0xf75c0284, 0xfe3037d3, 0x046cda4d, 0x04b14fb5,
+	0x006ed13b, 0xfcd095c7, 0xfd2055da, 0x002b15c1,
+	0x02646e27, 0x01cd49ce, 0xff8edd4d, 0xfe342a3c,
+	0xfee516c8, 0x0089e9c2, 0x0151bd5e, 0x00a3a6d0,
+	0xff781c6e, 0xff1114c3, 0xffaac7b3, 0x00764850,
+	0x00a04d30, 0x00246b2b, 0xffa31be3, 0xff9c009d,
+	0xfff6da1d, 0x0041605b, 0x0038264f, 0xfffceef7,
+	0x2aa9e37b, 0x1b3b52fa, 0x06674fbb, 0xf8a767e8,
+	0xf764388f, 0xfe3ff7ce, 0x0473e55f, 0x04abd809,
+	0x006545f4, 0xfcccfde7, 0xfd24bc7a, 0x0031726d,
+	0x02662513, 0x01c9a656, 0xff8a8a6f, 0xfe338d46,
+	0xfee80bf9, 0x008ccdba, 0x0151b7e9, 0x00a15497,
+	0xff7641f9, 0xff116dd4, 0xffac8430, 0x00776481,
+	0x009fd588, 0x002332ba, 0xffa282d9, 0xff9c7497,
+	0xfff7a41f, 0x0041a4fd, 0x0037c9be, 0xfffc7b9c,
+	0x2a98a737, 0x1b12d61f, 0x0641a050, 0xf898916f,
+	0xf76c9027, 0xfe4fb3d6, 0x047ad64d, 0x04a64d56,
+	0x005bbe28, 0xfcc97740, 0xfd292e9b, 0x0037cb21,
+	0x0267cfb0, 0x01c5fbf0, 0xff863bb5, 0xfe32f93a,
+	0xfeeb051b, 0x008fadc3, 0x0151ac1d, 0x009f0064,
+	0xff746afa, 0xff11cb3b, 0xffae4166, 0x00787de1,
+	0x009f5b18, 0x0021fa48, 0xffa1ebee, 0xff9cea31,
+	0xfff86dca, 0x0041e82d, 0x00376c5d, 0xfffc08af,
+	0x2a8729bc, 0x1aea43a9, 0x061c0fc2, 0xf889efc2,
+	0xf7750906, 0xfe5f6ba5, 0x0481ad08, 0x04a0afc1,
+	0x00523a01, 0xfcc601dc, 0xfd2dac22, 0x003e1fc1,
+	0x02696dfd, 0x01c24ab0, 0xff81f130, 0xfe326e17,
+	0xfeee021f, 0x009289d1, 0x015199fd, 0x009caa44,
+	0xff729776, 0xff122cf2, 0xffafff4c, 0x0079946b,
+	0x009edde4, 0x0020c1dd, 0xffa15723, 0xff9d6168,
+	0xfff93718, 0x004229eb, 0x00370e2e, 0xfffb9632,
+	0x2a756b3b, 0x1ac19c04, 0x05f69e66, 0xf87b82e0,
+	0xf77da2ea, 0xfe6f1ef7, 0x04886983, 0x049aff71,
+	0x0048b9aa, 0xfcc29dc1, 0xfd3234f5, 0x00447031,
+	0x026afff6, 0x01be92ab, 0xff7daaf5, 0xfe31ebdc,
+	0xfef102f4, 0x009561d7, 0x0151818c, 0x009a5243,
+	0xff70c777, 0xff1292f7, 0xffb1bddb, 0x007aa81c,
+	0x009e5df0, 0x001f897e, 0xffa0c47a, 0xff9dda38,
+	0xfffa0007, 0x00426a37, 0x0036af34, 0xfffb2426,
+	0x2a636be9, 0x1a98dfa0, 0x05d14c8d, 0xf86d4ac8,
+	0xf7865d8d, 0xfe7ecd89, 0x048f0bb1, 0x04953c8b,
+	0x003f3d4d, 0xfcbf4af5, 0xfd36c8f8, 0x004abc53,
+	0x026c859b, 0x01bad3f6, 0xff796914, 0xfe317287,
+	0xfef4078b, 0x009835ca, 0x015162ce, 0x0097f86d,
+	0xff6efb02, 0xff12fd45, 0xffb37d08, 0x007bb8f0,
+	0x009ddb40, 0x001e5131, 0xffa033f4, 0xff9e549d,
+	0xfffac893, 0x0042a910, 0x00364f71, 0xfffab28d,
+	0x2a512bfa, 0x1a700eeb, 0x05ac1a8b, 0xf85f4778,
+	0xf78f38aa, 0xfe8e7717, 0x04959384, 0x048f6736,
+	0x0035c515, 0xfcbc0981, 0xfd3b6811, 0x0051040d,
+	0x026dfee9, 0x01b70ea5, 0xff752ba1, 0xfe310217,
+	0xfef70fd4, 0x009b059d, 0x01513dc5, 0x00959cce,
+	0xff6d321f, 0xff136bd8, 0xffb53ccc, 0x007cc6e3,
+	0x009d55d8, 0x001d18fb, 0xff9fa593, 0xff9ed096,
+	0xfffb90b8, 0x0042e677, 0x0035eee8, 0xfffa416a,
+	0x2a3eaba1, 0x1a472a55, 0x058708b1, 0xf85178ed,
+	0xf79833fc, 0xfe9e1b5d, 0x049c00f1, 0x04897f98,
+	0x002c512c, 0xfcb8d969, 0xfd401222, 0x00574743,
+	0x026f6be0, 0x01b342cf, 0xff70f2af, 0xfe309a89,
+	0xfefa1bbe, 0x009dd146, 0x01511275, 0x00933f72,
+	0xff6b6cd5, 0xff13deac, 0xffb6fd1c, 0x007dd1f1,
+	0x009ccdbb, 0x001be0e4, 0xff9f195a, 0xff9f4e1e,
+	0xfffc5873, 0x0043226a, 0x00358d9b, 0xfff9d0be,
+	0x2a2beb14, 0x1a1e324b, 0x05621751, 0xf843df22,
+	0xf7a14f3e, 0xfeadba18, 0x04a253ec, 0x048385d8,
+	0x0022e1bc, 0xfcb5bab4, 0xfd44c712, 0x005d85d9,
+	0x0270cc7e, 0x01af7087, 0xff6cbe4e, 0xfe303bdb,
+	0xfefd2b39, 0x00a098b9, 0x0150e0e3, 0x0090e066,
+	0xff69ab2b, 0xff1455bd, 0xffb8bdf2, 0x007eda17,
+	0x009c42ee, 0x001aa8f0, 0xff9e8f48, 0xff9fcd32,
+	0xfffd1fbf, 0x00435cea, 0x00352b8d, 0xfff9608c,
+	0x2a18ea8a, 0x19f5273c, 0x053d46bc, 0xf8367a15,
+	0xf7aa8a29, 0xfebd5306, 0x04a88c69, 0x047d7a1c,
+	0x001976f0, 0xfcb2ad69, 0xfd4986c4, 0x0063bfb2,
+	0x027220c3, 0x01ab97e3, 0xff688e92, 0xfe2fe60c,
+	0xff003e34, 0x00a35bea, 0x0150a911, 0x008e7fb5,
+	0xff67ed27, 0xff14d106, 0xffba7f43, 0x007fdf51,
+	0x009bb575, 0x00197126, 0xff9e075f, 0xffa04dce,
+	0xfffde69a, 0x004395f7, 0x0034c8c0, 0xfff8f0d5,
+	0x2a05aa39, 0x19cc0999, 0x05189741, 0xf82949bf,
+	0xf7b3e478, 0xfecce5e4, 0x04aeaa5d, 0x04775c8d,
+	0x001010f0, 0xfcafb18b, 0xfd4e511c, 0x0069f4b5,
+	0x027368ad, 0x01a7b8f9, 0xff64638d, 0xfe2f991a,
+	0xff0354a0, 0x00a61acd, 0x01506b04, 0x008c1d6d,
+	0xff6632d1, 0xff155084, 0xffbc4107, 0x0080e19b,
+	0x009b2554, 0x0018398c, 0xff9d81a2, 0xffa0cff0,
+	0xfffeacff, 0x0043cd90, 0x00346537, 0xfff8819a,
+	0x29f22a58, 0x19a2d9cf, 0x04f40932, 0xf81c4e1c,
+	0xf7bd5de4, 0xfedc726f, 0x04b4adbf, 0x04712d52,
+	0x0006afe6, 0xfcacc720, 0xfd5325ff, 0x007024c6,
+	0x0274a43d, 0x01a3d3dd, 0xff603d50, 0xfe2f5500,
+	0xff066e6b, 0x00a8d558, 0x015026bf, 0x0089b999,
+	0xff647c2f, 0xff15d431, 0xffbe0336, 0x0081e0f3,
+	0x009a928e, 0x00170227, 0xff9cfe11, 0xffa15393,
+	0xffff72ec, 0x004403b5, 0x003400f4, 0xfff812df,
+	0x29de6b20, 0x1979984f, 0x04cf9cdc, 0xf80f8725,
+	0xf7c6f628, 0xfeebf866, 0x04ba9684, 0x046aec92,
+	0xfffd53fc, 0xfca9ee2c, 0xfd58054f, 0x00764fc9,
+	0x0275d371, 0x019fe8a6, 0xff5c1bed, 0xfe2f19be,
+	0xff098b86, 0x00ab8b7e, 0x014fdc47, 0x00875446,
+	0xff62c947, 0xff165c0a, 0xffbfc5c6, 0x0082dd55,
+	0x0099fd2a, 0x0015cafd, 0xff9c7cad, 0xffa1d8b5,
+	0x0000385c, 0x00443867, 0x00339bf9, 0xfff7a4a4,
+	0x29ca6cc9, 0x19504587, 0x04ab528f, 0xf802f4d2,
+	0xf7d0acfb, 0xfefb7787, 0x04c064a3, 0x04649a75,
+	0xfff3fd5b, 0xfca726b5, 0xfd5ceef2, 0x007c75a4,
+	0x0276f64b, 0x019bf768, 0xff57ff75, 0xfe2ee750,
+	0xff0cabe0, 0x00ae3d36, 0x014f8ba0, 0x0084ed7f,
+	0xff611a20, 0xff16e809, 0xffc188af, 0x0083d6be,
+	0x00996529, 0x00149415, 0xff9bfd78, 0xffa25f52,
+	0x0000fd4d, 0x00446ba4, 0x0033364a, 0xfff736eb,
+	0x29b62f8d, 0x1926e1e8, 0x04872a99, 0xf7f6971d,
+	0xf7da8217, 0xff0aef91, 0x04c61813, 0x045e3724,
+	0xffeaac2d, 0xfca470be, 0xfd61e2c9, 0x0082963b,
+	0x02780ccb, 0x0198003a, 0xff53e7fb, 0xfe2ebdb4,
+	0xff0fcf69, 0x00b0ea74, 0x014f34ce, 0x00828551,
+	0xff5f6ec1, 0xff17782a, 0xffc34be8, 0x0084cd2a,
+	0x0098ca91, 0x00135d73, 0xff9b8073, 0xffa2e766,
+	0x0001c1ba, 0x00449d6e, 0x0032cfe8, 0xfff6c9b7,
+	0x29a1b3a6, 0x18fd6de0, 0x04632547, 0xf7ea6dfe,
+	0xf7e47535, 0xff1a6042, 0x04cbb0cc, 0x0457c2c6,
+	0xffe16099, 0xfca1cc4a, 0xfd66e0ba, 0x0088b175,
+	0x027916f0, 0x01940330, 0xff4fd58f, 0xfe2e9ce5,
+	0xff12f610, 0x00b3932d, 0x014ed7d5, 0x00801bc9,
+	0xff5dc72f, 0xff180c69, 0xffc50f68, 0x0085c096,
+	0x00982d66, 0x0012271e, 0xff9b05a0, 0xffa370ed,
+	0x000285a0, 0x0044cdc5, 0x003268d6, 0xfff65d08,
+	0x298cf94f, 0x18d3e9df, 0x043f42e7, 0xf7de796a,
+	0xf7ee860c, 0xff29c95a, 0x04d12ec5, 0x04513d85,
+	0xffd81ac8, 0xfc9f395e, 0xfd6be8a6, 0x008ec736,
+	0x027a14bd, 0x01900061, 0xff4bc843, 0xfe2e84e2,
+	0xff161fc4, 0x00b63757, 0x014e74bb, 0x007db0f2,
+	0xff5c2372, 0xff18a4c1, 0xffc6d327, 0x0086b0ff,
+	0x00978dad, 0x0010f11b, 0xff9a8cfe, 0xffa3fbe6,
+	0x000348fc, 0x0044fca7, 0x00320118, 0xfff5f0e2,
+	0x297800c4, 0x18aa5655, 0x041b83c4, 0xf7d2b958,
+	0xf7f8b457, 0xff392a98, 0x04d691f8, 0x044aa789,
+	0xffcedae4, 0xfc9cb7fb, 0xfd70fa72, 0x0094d765,
+	0x027b0631, 0x018bf7e3, 0xff47c028, 0xfe2e75a5,
+	0xff194c76, 0x00b8d6e6, 0x014e0b83, 0x007b44d9,
+	0xff5a838f, 0xff19412c, 0xffc8971b, 0x00879e62,
+	0x0096eb69, 0x000fbb71, 0xff9a1690, 0xffa4884b,
+	0x00040bca, 0x00452a16, 0x003198ae, 0xfff58545,
+	0x2962ca41, 0x1880b3b1, 0x03f7e82c, 0xf7c72dbf,
+	0xf802ffcb, 0xff4883bd, 0x04dbda5e, 0x044400fa,
+	0xffc5a113, 0xfc9a4826, 0xfd761600, 0x009ae1e6,
+	0x027beb4e, 0x0187e9cb, 0xff43bd50, 0xfe2e6f2d,
+	0xff1c7c13, 0x00bb71d0, 0x014d9c33, 0x0078d78a,
+	0xff58e78c, 0xff19e1a6, 0xffca5b3d, 0x008888bc,
+	0x0096469f, 0x000e8625, 0xff99a256, 0xffa51619,
+	0x0004ce07, 0x00455611, 0x00312f9d, 0xfff51a33,
+	0x294d5604, 0x18570264, 0x03d47068, 0xf7bbd693,
+	0xf80d6821, 0xff57d489, 0x04e107ef, 0x043d4a03,
+	0xffbc6d7f, 0xfc97e9df, 0xfd7b3b32, 0x00a0e6a0,
+	0x027cc415, 0x0183d62f, 0xff3fbfca, 0xfe2e7175,
+	0xff1fae8d, 0x00be080a, 0x014d26ce, 0x00766912,
+	0xff574f6f, 0xff1a862a, 0xffcc1f84, 0x0089700a,
+	0x00959f55, 0x000d513c, 0xff993051, 0xffa5a54d,
+	0x00058faf, 0x00458098, 0x0030c5e5, 0xfff4afae,
+	0x2937a449, 0x182d42dd, 0x03b11cc5, 0xf7b0b3c8,
+	0xf817ed11, 0xff671cbb, 0x04e61aa7, 0x043682cc,
+	0xffb34050, 0xfc959d2a, 0xfd8069ed, 0x00a6e579,
+	0x027d9088, 0x017fbd25, 0xff3bc7a7, 0xfe2e7c78,
+	0xff22e3d2, 0x00c0998b, 0x014cab5b, 0x0073f97d,
+	0xff55bb3e, 0xff1b2eb3, 0xffcde3e7, 0x008a5449,
+	0x0094f58d, 0x000c1cbd, 0xff98c083, 0xffa635e2,
+	0x000650bf, 0x0045a9ad, 0x00305b8b, 0xfff445b8,
+	0x2921b54e, 0x1803758c, 0x038ded8c, 0xf7a5c553,
+	0xf8228e52, 0xff765c15, 0x04eb127f, 0x042fab80,
+	0xffaa19ac, 0xfc936208, 0xfd85a213, 0x00acde57,
+	0x027e50a9, 0x017b9ec4, 0xff37d4f9, 0xfe2e9034,
+	0xff261bd1, 0x00c32648, 0x014c29de, 0x007188d6,
+	0xff542aff, 0xff1bdb3b, 0xffcfa85c, 0x008b3577,
+	0x0094494d, 0x000ae8ad, 0xff9852eb, 0xffa6c7d7,
+	0x00071133, 0x0045d14e, 0x002ff090, 0xfff3dc52,
+	0x290b8954, 0x17d99ae1, 0x036ae307, 0xf79b0b25,
+	0xf82d4b9c, 0xff859259, 0x04efef72, 0x0428c447,
+	0xffa0f9bb, 0xfc91387a, 0xfd8ae385, 0x00b2d121,
+	0x027f047a, 0x01777b22, 0xff33e7d0, 0xfe2eaca3,
+	0xff29567a, 0x00c5ae36, 0x014ba25d, 0x006f172b,
+	0xff529eb8, 0xff1c8bbe, 0xffd16cdd, 0x008c1391,
+	0x00939a99, 0x0009b511, 0xff97e78c, 0xffa75b26,
+	0x0007d109, 0x0045f77c, 0x002f84f8, 0xfff3737f,
+	0x28f5209a, 0x17afb34c, 0x0347fd7f, 0xf7908532,
+	0xf83824a4, 0xff94bf47, 0x04f4b17d, 0x0421cd4b,
+	0xff97e0a5, 0xfc8f2082, 0xfd902e27, 0x00b8bdbd,
+	0x027fabfd, 0x01735253, 0xff30003c, 0xfe2ed1c2,
+	0xff2c93bc, 0x00c8314d, 0x014b14dc, 0x006ca487,
+	0xff51166f, 0xff1d4037, 0xffd3315f, 0x008cee93,
+	0x0092e976, 0x000881f0, 0xff977e65, 0xffa7efcc,
+	0x0008903d, 0x00461c37, 0x002f18c4, 0xfff30b3f,
+	0x28de7b60, 0x1785bf3d, 0x03253d3d, 0xf786336c,
+	0xf8431922, 0xffa3e2a1, 0x04f9589b, 0x041ac6b8,
+	0xff8ece90, 0xfc8d1a20, 0xfd9581db, 0x00bea411,
+	0x02804736, 0x016f2470, 0xff2c1e4d, 0xfe2eff8c,
+	0xff2fd386, 0x00caaf81, 0x014a8161, 0x006a30f7,
+	0xff4f9228, 0xff1df8a0, 0xffd4f5db, 0x008dc67c,
+	0x009235e9, 0x00074f4f, 0xff971778, 0xffa885c5,
+	0x00094ecb, 0x00463f80, 0x002eabf7, 0xfff2a394,
+	0x28c799e6, 0x175bbf24, 0x0302a287, 0xf77c15c2,
+	0xf84e28cc, 0xffb2fc2a, 0x04fde4c8, 0x0413b0b6,
+	0xff85c3a4, 0xfc8b2554, 0xfd9ade82, 0x00c48405,
+	0x0280d625, 0x016af18e, 0xff284214, 0xfe2f35fc,
+	0xff3315c8, 0x00cd28c9, 0x0149e7f2, 0x0067bc88,
+	0xff4e11e9, 0xff1eb4f3, 0xffd6ba48, 0x008e9b49,
+	0x00917ff6, 0x00061d34, 0xff96b2c5, 0xffa91d0f,
+	0x000a0cb1, 0x00466157, 0x002e3e94, 0xfff23c80,
+	0x28b07c70, 0x1731b371, 0x02e02da7, 0xf7722c26,
+	0xf8595359, 0xffc20ba4, 0x05025601, 0x040c8b71,
+	0xff7cc007, 0xfc894220, 0xfda04401, 0x00ca5d80,
+	0x028158d0, 0x0166b9c4, 0xff246ba0, 0xfe2f750d,
+	0xff365a71, 0x00cf9d1b, 0x01494894, 0x00654744,
+	0xff4c95b9, 0xff1f752b, 0xffd87e9d, 0x008f6cf7,
+	0x0090c7a1, 0x0004eba4, 0xff96504d, 0xffa9b5a4,
+	0x000ac9eb, 0x004681bc, 0x002dd09d, 0xfff1d604,
+	0x2899233e, 0x17079c93, 0x02bddee2, 0xf7687688,
+	0xf864987f, 0xffd110d3, 0x0506ac45, 0x04055714,
+	0xff73c3e0, 0xfc877082, 0xfda5b237, 0x00d03069,
+	0x0281cf38, 0x01627d27, 0xff209b02, 0xfe2fbcbb,
+	0xff39a170, 0x00d20c6d, 0x0148a34c, 0x0062d139,
+	0xff4b1d9b, 0xff203943, 0xffda42d2, 0x00903b84,
+	0x00900cf1, 0x0003baa5, 0xff95f010, 0xffaa4f81,
+	0x000b8675, 0x0046a0af, 0x002d6216, 0xfff17023,
+	0x28818e95, 0x16dd7afd, 0x029bb67e, 0xf75ef4d6,
+	0xf86ff7f3, 0xffe00b78, 0x050ae790, 0x03fe13c8,
+	0xff6acf54, 0xfc85b07a, 0xfdab2907, 0x00d5fca7,
+	0x02823961, 0x015e3bcf, 0xff1cd048, 0xfe300d00,
+	0xff3ceab4, 0x00d476b7, 0x0147f821, 0x00605a74,
+	0xff49a996, 0xff210136, 0xffdc06de, 0x009106ee,
+	0x008f4fe9, 0x00028a3b, 0xff95920f, 0xffaaeaa4,
+	0x000c424d, 0x0046be32, 0x002cf300, 0xfff10ade,
+	0x2869beb7, 0x16b34f1c, 0x0279b4c2, 0xf755a6fe,
+	0xf87b716c, 0xffeefb58, 0x050f07e1, 0x03f6c1b9,
+	0xff61e28a, 0xfc840207, 0xfdb0a853, 0x00dbc222,
+	0x0282974f, 0x0159f5d2, 0xff190b83, 0xfe3065d6,
+	0xff40362c, 0x00d6dbef, 0x01474719, 0x005de2ff,
+	0xff4839ae, 0xff21ccfd, 0xffddcab8, 0x0091cf32,
+	0x008e908f, 0x00015a6e, 0xff95364b, 0xffab8707,
+	0x000cfd6f, 0x0046da43, 0x002c835e, 0xfff0a635,
+	0x2851b3e9, 0x16891961, 0x0257d9f2, 0xf74c8cf0,
+	0xf887049f, 0xfffde037, 0x05130d37, 0x03ef6113,
+	0xff58fda8, 0xfc826529, 0xfdb62ffd, 0x00e180c1,
+	0x0282e906, 0x0155ab46, 0xff154cc2, 0xfe30c739,
+	0xff4383c8, 0x00d93c0b, 0x01469039, 0x005b6ae8,
+	0xff46cde8, 0xff229c92, 0xffdf8e59, 0x0092944e,
+	0x008dcee7, 0x00002b42, 0xff94dcc4, 0xffac24a6,
+	0x000db7d9, 0x0046f4e4, 0x002c1333, 0xfff0422b,
+	0x28396e6f, 0x165eda3d, 0x02362652, 0xf743a697,
+	0xf892b142, 0x000cb9d9, 0x0516f791, 0x03e7f200,
+	0xff5020d3, 0xfc80d9dd, 0xfdbbbfe5, 0x00e7386d,
+	0x02832e8a, 0x01515c42, 0xff119414, 0xfe313123,
+	0xff46d377, 0x00db9702, 0x0145d387, 0x0058f23a,
+	0xff45664a, 0xff236ff1, 0xffe151b8, 0x00935640,
+	0x008d0af6, 0xfffefcbd, 0xff94857a, 0xffacc380,
+	0x000e7186, 0x00470e16, 0x002ba282, 0xffefdec2,
+	0x2820ee90, 0x1634921f, 0x02149a26, 0xf73af3e1,
+	0xf89e770a, 0x001b8803, 0x051ac6ef, 0x03e074ab,
+	0xff474c30, 0xfc7f6021, 0xfdc157ef, 0x00ece90d,
+	0x028367df, 0x014d08dd, 0xff0de188, 0xfe31a38e,
+	0xff4a2528, 0x00ddeccb, 0x01451109, 0x00567902,
+	0xff4402d9, 0xff244713, 0xffe314cc, 0x00941506,
+	0x008c44c1, 0xfffdcee3, 0xff94306f, 0xffad638e,
+	0x000f2a75, 0x004725d8, 0x002b314d, 0xffef7bfa,
+	0x28083491, 0x160a4177, 0x01f335b2, 0xf73274b9,
+	0xf8aa55ac, 0x002a4a79, 0x051e7b51, 0x03d8e942,
+	0xff3e7fe4, 0xfc7df7f5, 0xfdc6f7fa, 0x00f29289,
+	0x0283950a, 0x0148b12d, 0xff0a352e, 0xfe321e74,
+	0xff4d78ca, 0x00e03d5e, 0x014448c7, 0x0053ff4c,
+	0xff42a398, 0xff2521f3, 0xffe4d78d, 0x0094d09e,
+	0x008b7c4d, 0xfffca1bc, 0xff93dda1, 0xffae04ce,
+	0x000fe2a1, 0x00473c2b, 0x002abf96, 0xffef19d6,
+	0x27ef40ba, 0x15dfe8b5, 0x01d1f938, 0xf72a290a,
+	0xf8b64cdd, 0x00390101, 0x052214b9, 0x03d14fee,
+	0xff35bc15, 0xfc7ca155, 0xfdcc9fe9, 0x00f834cb,
+	0x0283b60f, 0x01445549, 0xff068f14, 0xfe32a1cf,
+	0xff50ce4c, 0x00e288b1, 0x01437ac6, 0x00518524,
+	0xff41488d, 0xff260089, 0xffe699f2, 0x00958906,
+	0x008ab1a0, 0xfffb754b, 0xff938d12, 0xffaea73c,
+	0x00109a08, 0x00475110, 0x002a4d61, 0xffeeb856,
+	0x27d61351, 0x15b5884a, 0x01b0e4f9, 0xf72210bf,
+	0xf8c25c52, 0x0047ab61, 0x05259326, 0x03c9a8dd,
+	0xff2d00e6, 0xfc7b5c3e, 0xfdd24f9d, 0x00fdcfba,
+	0x0283caf4, 0x013ff548, 0xff02ef49, 0xfe332d99,
+	0xff54259d, 0x00e4cebb, 0x0142a70d, 0x004f0a97,
+	0xff3ff1bc, 0xff26e2d2, 0xffe85bf4, 0x00963e3c,
+	0x0089e4be, 0xfffa4997, 0xff933ec2, 0xffaf4ad4,
+	0x001150a6, 0x00476488, 0x0029daaf, 0xffee577c,
+	0x27bcac9e, 0x158b20a5, 0x018ff938, 0xf71a2bc2,
+	0xf8ce83c0, 0x0056495f, 0x0528f69b, 0x03c1f43a,
+	0xff244e7d, 0xfc7a28ae, 0xfdd806f6, 0x01036340,
+	0x0283d3be, 0x013b9141, 0xfeff55db, 0xfe33c1cb,
+	0xff577ead, 0x00e70f75, 0x0141cda2, 0x004c8fb0,
+	0xff3e9f2a, 0xff27c8c6, 0xffea1d89, 0x0096f03e,
+	0x008915ab, 0xfff91ea4, 0xff92f2b1, 0xffafef91,
+	0x00120679, 0x00477692, 0x00296784, 0xffedf74a,
+	0x27a30ceb, 0x1560b236, 0x016f3634, 0xf71279fd,
+	0xf8dac2da, 0x0064dac1, 0x052c3f1a, 0x03ba3232,
+	0xff1ba4fe, 0xfc7906a1, 0xfdddc5d6, 0x0108ef45,
+	0x0283d071, 0x0137294a, 0xfefbc2da, 0xfe345e5f,
+	0xff5ad96a, 0x00e94ad5, 0x0140ee8c, 0x004a147c,
+	0xff3d50dc, 0xff28b25f, 0xffebdeaa, 0x00979f0b,
+	0x0088446f, 0xfff7f479, 0xff92a8df, 0xffb09571,
+	0x0012bb7d, 0x00478730, 0x0028f3e3, 0xffed97c0,
+	0x27893481, 0x15363d6c, 0x014e9c2e, 0xf70afb57,
+	0xf8e71956, 0x00735f4e, 0x052f6ca6, 0x03b262f1,
+	0xff13048c, 0xfc77f613, 0xfde38c1e, 0x010e73b2,
+	0x0283c114, 0x0132bd7b, 0xfef83652, 0xfe35034f,
+	0xff5e35c4, 0x00eb80d4, 0x014009d1, 0x00479907,
+	0xff3c06d5, 0xff299f97, 0xffed9f4d, 0x00984aa0,
+	0x0087710c, 0xfff6cb19, 0xff92614c, 0xffb13c6f,
+	0x00136fb0, 0x00479661, 0x00287fcd, 0xffed38e2,
+	0x276f23a9, 0x150bc2b8, 0x012e2b66, 0xf703afba,
+	0xf8f386e8, 0x0081d6cd, 0x05327f41, 0x03aa86a3,
+	0xff0a6d4b, 0xfc76f700, 0xfde959af, 0x0113f071,
+	0x0283a5ad, 0x012e4de9, 0xfef4b053, 0xfe35b093,
+	0xff6193aa, 0x00edb169, 0x013f1f7a, 0x00451d5c,
+	0xff3ac119, 0xff2a9068, 0xffef5f6c, 0x0098f2fd,
+	0x00869b8a, 0xfff5a28c, 0xff921bf9, 0xffb1e488,
+	0x0014230e, 0x0047a428, 0x00280b45, 0xffecdaae,
+	0x2754daae, 0x14e14289, 0x010de419, 0xf6fc970c,
+	0xf9000b44, 0x00904106, 0x053576ef, 0x03a29d74,
+	0xff01df5e, 0xfc760965, 0xfdef2e69, 0x0119656b,
+	0x02837e41, 0x0129daad, 0xfef130ea, 0xfe366624,
+	0xff64f30b, 0x00efdc8b, 0x013e2f8b, 0x0042a189,
+	0xff397fae, 0xff2b84cc, 0xfff11efd, 0x0099981f,
+	0x0085c3ec, 0xfff47ad4, 0xff91d8e5, 0xffb28db7,
+	0x0014d595, 0x0047b084, 0x0027964f, 0xffec7d28,
+	0x273a59db, 0x14b6bd4f, 0x00edc687, 0xf6f5b134,
+	0xf90ca61e, 0x009e9dc1, 0x053853b4, 0x039aa793,
+	0xfef95aea, 0xfc752d3c, 0xfdf50a2e, 0x011ed28a,
+	0x02834ad7, 0x012563dd, 0xfeedb825, 0xfe3723fc,
+	0xff6853d6, 0x00f20233, 0x013d3a0e, 0x00402599,
+	0xff384297, 0xff2c7cbc, 0xfff2ddf9, 0x009a3a05,
+	0x0084ea38, 0xfff353f9, 0xff919810, 0xffb337f8,
+	0x00158742, 0x0047bb77, 0x002720ec, 0xffec2051,
+	0x271fa17c, 0x148c337a, 0x00cdd2ed, 0xf6eefe19,
+	0xf919572a, 0x00acecc6, 0x053b1595, 0x0392a52b,
+	0xfef0e010, 0xfc746281, 0xfdfaecde, 0x012437b8,
+	0x02830b75, 0x0120e990, 0xfeea4612, 0xfe37ea14,
+	0xff6bb5fa, 0x00f42259, 0x013c3f08, 0x003da998,
+	0xff3709d8, 0xff2d7831, 0xfff49c56, 0x009ad8ae,
+	0x00840e73, 0xfff22dff, 0xff91597b, 0xffb3e348,
+	0x00163811, 0x0047c500, 0x0026ab20, 0xffebc429,
+	0x2704b1dd, 0x1461a578, 0x00ae0988, 0xf6e87da0,
+	0xf9261e1c, 0x00bb2dde, 0x053dbc96, 0x038a966a,
+	0xfee86ef3, 0xfc73a92e, 0xfe00d659, 0x012994de,
+	0x0282c022, 0x011c6bdd, 0xfee6dabf, 0xfe38b863,
+	0xff6f1966, 0x00f63cf6, 0x013b3e81, 0x003b2d92,
+	0xff35d575, 0xff2e7727, 0xfff65a0e, 0x009b7418,
+	0x008330a4, 0xfff108ec, 0xff911d25, 0xffb48fa2,
+	0x0016e800, 0x0047cd21, 0x002634ec, 0xffeb68b2,
+	0x26e98b4a, 0x143713b9, 0x008e6a94, 0xf6e22faf,
+	0xf932faa7, 0x00c960d2, 0x054048bd, 0x03827b7c,
+	0xfee007b6, 0xfc73013d, 0xfe06c681, 0x012ee9e7,
+	0x028268e5, 0x0117eadb, 0xfee37638, 0xfe398ee3,
+	0xff727e0a, 0x00f85200, 0x013a3880, 0x0038b193,
+	0xff34a572, 0xff2f7995, 0xfff81717, 0x009c0c41,
+	0x008250ce, 0xffefe4c3, 0xff90e30e, 0xffb53d03,
+	0x0017970c, 0x0047d3db, 0x0025be55, 0xffeb0ded,
+	0x26ce2e12, 0x140c7ead, 0x006ef64c, 0xf6dc1428,
+	0xf93fec7f, 0x00d7856c, 0x0542ba10, 0x037a548f,
+	0xfed7aa7c, 0xfc726aaa, 0xfe0cbd35, 0x013436be,
+	0x028205c5, 0x011366a2, 0xfee0188b, 0xfe3a6d8b,
+	0xff75e3d4, 0x00fa6172, 0x01392d0d, 0x003635a8,
+	0xff3379d2, 0xff307f75, 0xfff9d36b, 0x009ca12a,
+	0x00816ef7, 0xffeec18c, 0xff90ab37, 0xffb5eb67,
+	0x00184532, 0x0047d92e, 0x0025475b, 0xffeab3dc,
+	0x26b29a83, 0x13e1e6c3, 0x004faced, 0xf6d62af1,
+	0xf94cf357, 0x00e59b75, 0x05451094, 0x037221d0,
+	0xfecf5765, 0xfc71e56d, 0xfe12ba57, 0x01397b4c,
+	0x028196c9, 0x010edf47, 0xfedcc1c6, 0xfe3b5455,
+	0xff794ab4, 0x00fc6b43, 0x01381c2f, 0x0033b9dc,
+	0xff325299, 0xff3188c2, 0xfffb8eff, 0x009d32d0,
+	0x00808b25, 0xffed9f49, 0xff90759e, 0xffb69aca,
+	0x0018f270, 0x0047dd1c, 0x0024d003, 0xffea5a7f,
+	0x2696d0ea, 0x13b74c6a, 0x00308eb0, 0xf6d073ed,
+	0xf95a0ee3, 0x00f3a2b8, 0x05474c51, 0x0369e36d,
+	0xfec70e94, 0xfc717180, 0xfe18bdc6, 0x013eb77e,
+	0x02811bf9, 0x010a54e3, 0xfed971f4, 0xfe3c4337,
+	0xff7cb299, 0x00fe6f6c, 0x013705ed, 0x00313e3b,
+	0xff312fcb, 0xff329573, 0xfffd49ce, 0x009dc132,
+	0x007fa55d, 0xffec7e02, 0xff904243, 0xffb74b27,
+	0x00199ec2, 0x0047dfa5, 0x0024584e, 0xffea01d9,
+	0x267ad197, 0x138cb011, 0x00119bce, 0xf6caeefd,
+	0xf9673ed7, 0x01019b00, 0x05496d4e, 0x03619994,
+	0xfebed02a, 0xfc710edd, 0xfe1ec763, 0x0143eb3d,
+	0x0280955d, 0x0105c78d, 0xfed62923, 0xfe3d3a2b,
+	0xff801b71, 0x01006de7, 0x0135ea51, 0x002ec2d1,
+	0xff30116a, 0xff33a583, 0xffff03ce, 0x009e4c50,
+	0x007ebda5, 0xffeb5dba, 0xff901127, 0xffb7fc7b,
+	0x001a4a26, 0x0047e0c9, 0x0023e03f, 0xffe9a9ea,
+	0x265e9cdb, 0x13621226, 0xfff2d482, 0xf6c59c04,
+	0xf97482e5, 0x010f8417, 0x054b7392, 0x03594471,
+	0xfeb69c49, 0xfc70bd7d, 0xfe24d70f, 0x01491674,
+	0x028002fc, 0x0101375a, 0xfed2e760, 0xfe3e3927,
+	0xff83852d, 0x010266ab, 0x0134c960, 0x002c47aa,
+	0xff2ef77c, 0xff34b8ea, 0x0000bcf7, 0x009ed428,
+	0x007dd402, 0xffea3e76, 0xff8fe248, 0xffb8aec1,
+	0x001af499, 0x0047e08b, 0x002367d9, 0xffe952b4,
+	0x26423305, 0x13377319, 0xffd43904, 0xf6c07ae3,
+	0xf981dac1, 0x011d5dc9, 0x054d5f26, 0x0350e432,
+	0xfeae7310, 0xfc707d57, 0xfe2aeca8, 0x014e3911,
+	0x027f64de, 0x00fca464, 0xfecfacb7, 0xfe3f4024,
+	0xff86efbc, 0x010459b2, 0x0133a323, 0x0029ccd2,
+	0xff2de201, 0xff35cfa2, 0x00027542, 0x009f58ba,
+	0x007ce878, 0xffe9203c, 0xff8fb5a7, 0xffb961f6,
+	0x001b9e18, 0x0047deeb, 0x0022ef1e, 0xffe8fc37,
+	0x26259466, 0x130cd358, 0xffb5c98a, 0xf6bb8b7c,
+	0xf98f461d, 0x012b27e3, 0x054f3012, 0x03487906,
+	0xfea654a2, 0xfc704e65, 0xfe310810, 0x015352fd,
+	0x027ebb0c, 0x00f80ec0, 0xfecc7934, 0xfe404f18,
+	0xff8a5b0c, 0x010646f5, 0x013277a3, 0x00275255,
+	0xff2cd0ff, 0xff36e9a4, 0x00042ca6, 0x009fda04,
+	0x007bfb0f, 0xffe80311, 0xff8f8b43, 0xffba1616,
+	0x001c46a1, 0x0047dbea, 0x00227611, 0xffe8a675,
+	0x2608c14f, 0x12e23352, 0xff97864e, 0xf6b6cdad,
+	0xf99cc4ac, 0x0138e230, 0x0550e65f, 0x0340031b,
+	0xfe9e411e, 0xfc70309f, 0xfe372927, 0x01586424,
+	0x027e058f, 0x00f37687, 0xfec94ce4, 0xfe4165fc,
+	0xff8dc70c, 0x01082e6d, 0x013146e6, 0x0024d83e,
+	0xff2bc477, 0xff3806e9, 0x0005e31d, 0x00a05806,
+	0x007b0bcc, 0xffe6e6f9, 0xff8f631b, 0xffbacb1c,
+	0x001cee31, 0x0047d788, 0x0021fcb6, 0xffe8516e,
+	0x25ebba13, 0x12b79375, 0xff796f84, 0xf6b24158,
+	0xf9aa5623, 0x01468c7e, 0x05528216, 0x0337829e,
+	0xfe9638a4, 0xfc7023fb, 0xfe3d4fcd, 0x015d6c74,
+	0x027d446f, 0x00eedbce, 0xfec627d2, 0xfe4284c7,
+	0xff9133ad, 0x010a1015, 0x013010f5, 0x00225e99,
+	0xff2abc6d, 0xff392769, 0x0007989d, 0x00a0d2bf,
+	0x007a1ab3, 0xffe5cbf9, 0xff8f3d2f, 0xffbb8105,
+	0x001d94c6, 0x0047d1c8, 0x0021830d, 0xffe7fd25,
+	0x25ce7f04, 0x128cf430, 0xff5b8563, 0xf6ade659,
+	0xf9b7fa33, 0x01542698, 0x05540342, 0x032ef7bd,
+	0xfe8e3b55, 0xfc702872, 0xfe437be1, 0x01626bd7,
+	0x027c77b5, 0x00ea3eae, 0xfec30a0a, 0xfe43ab6f,
+	0xff94a0dd, 0x010bebe4, 0x012ed5d9, 0x001fe573,
+	0xff29b8e4, 0xff3a4b1f, 0x00094d1f, 0x00a14a2e,
+	0x007927cb, 0xffe4b216, 0xff8f197f, 0xffbc37cc,
+	0x001e3a5c, 0x0047caaa, 0x0021091b, 0xffe7a99a,
+	0x25b11076, 0x126255f0, 0xff3dc820, 0xf6a9bc91,
+	0xf9c5b08f, 0x0161b04e, 0x055569ec, 0x032662a7,
+	0xfe864950, 0xfc703dfb, 0xfe49ad44, 0x0167623a,
+	0x027b9f6a, 0x00e59f3e, 0xfebff399, 0xfe44d9ec,
+	0xff980e8b, 0x010dc1d6, 0x012d9599, 0x001d6cd6,
+	0xff28b9df, 0xff3b7203, 0x000b009b, 0x00a1be54,
+	0x00783319, 0xffe39955, 0xff8ef80a, 0xffbcef6e,
+	0x001edef1, 0x0047c22e, 0x00208ee1, 0xffe756ce,
+	0x25936ebb, 0x1237b924, 0xff2037f0, 0xf6a5c3dd,
+	0xf9d378ea, 0x016f296d, 0x0556b61f, 0x031dc38a,
+	0xfe7e62b4, 0xfc70648c, 0xfe4fe3d6, 0x016c4f8a,
+	0x027abb98, 0x00e0fd94, 0xfebce489, 0xfe461034,
+	0xff9b7ca8, 0x010f91e3, 0x012c503f, 0x001af4cf,
+	0xff27bf5f, 0xff3c9c0d, 0x000cb30a, 0x00a22f2e,
+	0x00773ca3, 0xffe281ba, 0xff8ed8cf, 0xffbda7e5,
+	0x001f8283, 0x0047b858, 0x00201462, 0xffe704c3,
+	0x25759a28, 0x120d1e39, 0xff02d506, 0xf6a1fc1a,
+	0xf9e152f6, 0x017c91c3, 0x0557e7e7, 0x03151a95,
+	0xfe7687a0, 0xfc709c1d, 0xfe561f77, 0x017133b4,
+	0x0279cc48, 0x00dc59c8, 0xfeb9dce6, 0xfe474e3f,
+	0xff9eeb21, 0x01115c06, 0x012b05d1, 0x00187d6a,
+	0xff26c969, 0xff3dc937, 0x000e6463, 0x00a29cbd,
+	0x0076446e, 0xffe16b4a, 0xff8ebbcd, 0xffbe6130,
+	0x0020250f, 0x0047ad26, 0x001f99a2, 0xffe6b378,
+	0x25579312, 0x11e2859c, 0xfee59f96, 0xf69e6525,
+	0xf9ef3e67, 0x0189e91f, 0x0558ff50, 0x030c67f5,
+	0xfe6eb833, 0xfc70e4a2, 0xfe5c6006, 0x01760ea4,
+	0x0278d183, 0x00d7b3f1, 0xfeb6dcbb, 0xfe489402,
+	0xffa259e7, 0x01132039, 0x0129b65a, 0x001606b1,
+	0xff25d7fe, 0xff3ef97a, 0x001014a0, 0x00a30701,
+	0x00754a80, 0xffe0560b, 0xff8ea104, 0xffbf1b48,
+	0x0020c693, 0x0047a09b, 0x001f1ea1, 0xffe662f0,
+	0x253959ce, 0x11b7efbd, 0xfec897d2, 0xf69afeda,
+	0xf9fd3aef, 0x01972f51, 0x0559fc64, 0x0303abd9,
+	0xfe66f48c, 0xfc713e14, 0xfe62a564, 0x017ae048,
+	0x0277cb55, 0x00d30c26, 0xfeb3e414, 0xfe49e175,
+	0xffa5c8e8, 0x0114de75, 0x012861e0, 0x001390b0,
+	0xff24eb21, 0xff402ccd, 0x0011c3b8, 0x00a36df9,
+	0x00744edf, 0xffdf4200, 0xff8e8873, 0xffbfd62a,
+	0x0021670c, 0x004792b8, 0x001ea364, 0xffe6132b,
+	0x251aeeb2, 0x118d5d07, 0xfeabbdec, 0xf697c914,
+	0xfa0b4841, 0x01a46428, 0x055adf31, 0x02fae670,
+	0xfe5f3cc8, 0xfc71a866, 0xfe68ef6f, 0x017fa88d,
+	0x0276b9c6, 0x00ce627e, 0xfeb0f2fb, 0xfe4b368e,
+	0xffa93815, 0x011696b6, 0x0127086f, 0x00111b73,
+	0xff2402d4, 0xff41632b, 0x001371a3, 0x00a3d1a5,
+	0x00735191, 0xffde2f2e, 0xff8e7219, 0xffc091d2,
+	0x00220677, 0x0047837d, 0x001e27ed, 0xffe5c42b,
+	0x24fc5213, 0x1162cde7, 0xfe8f1215, 0xf694c3ae,
+	0xfa19660f, 0x01b18774, 0x055ba7c4, 0x02f217e9,
+	0xfe579106, 0xfc72238e, 0xfe6f3e09, 0x01846761,
+	0x02759ce1, 0x00c9b711, 0xfeae097a, 0xfe4c9342,
+	0xffaca75c, 0x011848f5, 0x0125aa0d, 0x000ea706,
+	0xff231f19, 0xff429c8b, 0x00151e5b, 0x00a43204,
+	0x0072529b, 0xffdd1d9a, 0xff8e5df5, 0xffc14e3c,
+	0x0022a4d3, 0x004772ed, 0x001dac3e, 0xffe575f0,
+	0x24dd8449, 0x113842cc, 0xfe72947e, 0xf691ee83,
+	0xfa27940b, 0x01be9906, 0x055c562a, 0x02e94071,
+	0xfe4ff164, 0xfc72af83, 0xfe759111, 0x01891cb1,
+	0x027474b2, 0x00c509f6, 0xfeab279e, 0xfe4df789,
+	0xffb016ae, 0x0119f52c, 0x012446c3, 0x000c3374,
+	0xff223ff3, 0xff43d8e6, 0x0016c9d7, 0x00a48f17,
+	0x00715203, 0xffdc0d49, 0xff8e4c07, 0xffc20b64,
+	0x0023421d, 0x00476108, 0x001d305a, 0xffe5287b,
+	0x24be85ac, 0x110dbc21, 0xfe564557, 0xf68f496d,
+	0xfa35d1e9, 0x01cb98af, 0x055cea71, 0x02e06039,
+	0xfe485dfe, 0xfc734c37, 0xfe7be866, 0x018dc86c,
+	0x02734141, 0x00c05b43, 0xfea84d6f, 0xfe4f6357,
+	0xffb385f8, 0x011b9b58, 0x0122de9c, 0x0009c0c9,
+	0xff216564, 0xff451834, 0x00187410, 0x00a4e8dd,
+	0x00704fce, 0xffdafe3e, 0xff8e3c4d, 0xffc2c946,
+	0x0023de52, 0x00474dd0, 0x001cb444, 0xffe4dbce,
+	0x249f5692, 0x10e33a54, 0xfe3a24ce, 0xf68cd445,
+	0xfa441f5a, 0x01d88640, 0x055d64a6, 0x02d7776e,
+	0xfe40d6f2, 0xfc73f9a0, 0xfe8243e9, 0x01926a80,
+	0x0272029b, 0x00bbab10, 0xfea57af9, 0xfe50d6a3,
+	0xffb6f52c, 0x011d3b71, 0x0121719f, 0x00074f0f,
+	0xff208f6e, 0xff465a6f, 0x001a1cff, 0x00a53f56,
+	0x006f4c03, 0xffd9f07f, 0xff8e2ec7, 0xffc387dd,
+	0x00247970, 0x00473946, 0x001c37fe, 0xffe48fe8,
+	0x247ff754, 0x10b8bdd0, 0xfe1e3313, 0xf68a8ee3,
+	0xfa527c12, 0x01e5618b, 0x055dc4d9, 0x02ce863f,
+	0xfe395c5d, 0xfc74b7b3, 0xfe88a379, 0x019702da,
+	0x0270b8ca, 0x00b6f975, 0xfea2b045, 0xfe525163,
+	0xffba6438, 0x011ed574, 0x011fffd6, 0x0004de53,
+	0xff1fbe12, 0xff479f8f, 0x001bc49c, 0x00a59283,
+	0x006e46a8, 0xffd8e410, 0xff8e2373, 0xffc44725,
+	0x00251375, 0x0047236b, 0x001bbb8b, 0xffe444cb,
+	0x2460684b, 0x108e4702, 0xfe027053, 0xf688791f,
+	0xfa60e7c2, 0x01f22a62, 0x055e0b19, 0x02c58cdb,
+	0xfe31ee5b, 0xfc758662, 0xfe8f06f5, 0x019b916b,
+	0x026f63da, 0x00b24688, 0xfe9fed5d, 0xfe53d38c,
+	0xffbdd30c, 0x0120695b, 0x011e894a, 0x00026ea0,
+	0xff1ef152, 0xff48e78c, 0x001d6ae0, 0x00a5e263,
+	0x006d3fc2, 0xffd7d8f4, 0xff8e1a51, 0xffc5071b,
+	0x0025ac5f, 0x00470c41, 0x001b3eed, 0xffe3fa79
+};
+
+#endif
diff --git a/sound/soc/amlogic/auge/sm1,clocks.c b/sound/soc/amlogic/auge/sm1,clocks.c
index 48cfc263b7d6..7a2321df8bfe 100644
--- a/sound/soc/amlogic/auge/sm1,clocks.c
+++ b/sound/soc/amlogic/auge/sm1,clocks.c
@@ -22,8 +22,6 @@
 #include "audio_clks.h"
 #include "regs.h"
 
-static spinlock_t aclk_lock;
-
 static const char *const mclk_parent_names[] = {
 	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
 	"fclk_div3", "fclk_div4", "fclk_div5"};
diff --git a/sound/soc/amlogic/auge/spdif.c b/sound/soc/amlogic/auge/spdif.c
index 944e00332576..c30c9943b268 100644
--- a/sound/soc/amlogic/auge/spdif.c
+++ b/sound/soc/amlogic/auge/spdif.c
@@ -40,6 +40,10 @@
 #include "resample_hw.h"
 #include "spdif.h"
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#include <linux/platform_data/board_odroid.h>
+#endif
+
 #define DRV_NAME "snd_spdif"
 
 /* Debug by PTM when bringup */
@@ -277,6 +281,62 @@ static int aml_audio_set_spdif_mute(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int aml_spdif_platform_suspend(
+	struct platform_device *pdev, pm_message_t state)
+{
+	struct aml_spdif *p_spdif = dev_get_drvdata(&pdev->dev);
+	struct pinctrl_state *pstate = NULL;
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+
+	if (!IS_ERR_OR_NULL(p_spdif->pin_ctl)) {
+		pstate = pinctrl_lookup_state
+		(p_spdif->pin_ctl, "spdif_pins_mute");
+		if (!IS_ERR_OR_NULL(pstate))
+			pinctrl_select_state(p_spdif->pin_ctl, pstate);
+	}
+	aml_spdif_enable(p_spdif->actrl,
+			    stream, p_spdif->id, false);
+	pr_info("%s is mute\n", __func__);
+	return 0;
+}
+
+static int aml_spdif_platform_resume(struct platform_device *pdev)
+{
+	struct aml_spdif *p_spdif = dev_get_drvdata(&pdev->dev);
+	struct pinctrl_state *state = NULL;
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+
+	if (!IS_ERR_OR_NULL(p_spdif->pin_ctl)) {
+		state = pinctrl_lookup_state
+		(p_spdif->pin_ctl, "spdif_pins");
+		if (!IS_ERR_OR_NULL(state))
+			pinctrl_select_state(p_spdif->pin_ctl, state);
+	}
+	aml_spdif_enable(p_spdif->actrl,
+			stream, p_spdif->id, true);
+	pr_info("%s is unmute\n", __func__);
+
+	return 0;
+}
+
+static void aml_spdif_platform_shutdown(struct platform_device *pdev)
+{
+	struct aml_spdif *p_spdif = dev_get_drvdata(&pdev->dev);
+	struct pinctrl_state *pstate = NULL;
+	int stream = SNDRV_PCM_STREAM_PLAYBACK;
+
+	if (!IS_ERR_OR_NULL(p_spdif->pin_ctl)) {
+		pstate = pinctrl_lookup_state
+		(p_spdif->pin_ctl, "spdif_pins_mute");
+		if (!IS_ERR_OR_NULL(pstate))
+			pinctrl_select_state(p_spdif->pin_ctl, pstate);
+	}
+	aml_spdif_enable(p_spdif->actrl,
+			    stream, p_spdif->id, false);
+	pr_info("%s is mute\n", __func__);
+
+}
+
 static int aml_audio_get_spdif_mute(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_value *ucontrol)
 {
@@ -485,10 +545,10 @@ static void spdifin_audio_type_work_func(struct work_struct *work)
 
 	if (val & 0x2)
 		/* nonpcm, resample disable */
-		resample_set(p_spdif->asrc_id, RATE_OFF, false);
+		resample_set(p_spdif->asrc_id, RATE_OFF);
 	else
 		/* pcm, resample which rate ? */
-		resample_set(p_spdif->asrc_id, p_spdif->auto_asrc, false);
+		resample_set(p_spdif->asrc_id, p_spdif->auto_asrc);
 }
 
 static void spdifin_audio_type_detect_init(struct aml_spdif *p_spdif)
@@ -674,7 +734,7 @@ static void spdifin_status_event(struct aml_spdif *p_spdif)
 				/* resample enable, by hw */
 				if (!spdifin_check_audiotype_by_sw(p_spdif))
 					resample_set(p_spdif->asrc_id,
-						p_spdif->auto_asrc, false);
+						p_spdif->auto_asrc);
 #endif
 				extcon_set_state(p_spdif->edev,
 					EXTCON_SPDIFIN_SAMPLERATE, 1);
@@ -687,7 +747,7 @@ static void spdifin_status_event(struct aml_spdif *p_spdif)
 	if (p_spdif->chipinfo
 		&& p_spdif->chipinfo->pcpd_separated) {
 		if (intrpt_status & 0x8) {
-			pr_info("Pc changed, try to read spdifin audio type\n");
+			pr_debug("Pc changed, try to read spdifin audio type\n");
 
 			extcon_set_state(p_spdif->edev,
 				EXTCON_SPDIFIN_AUDIOTYPE, 1);
@@ -696,12 +756,12 @@ static void spdifin_status_event(struct aml_spdif *p_spdif)
 #ifdef __SPDIFIN_AUDIO_TYPE_HW__
 			/* resample disable, by hw */
 			if (!spdifin_check_audiotype_by_sw(p_spdif))
-				resample_set(p_spdif->asrc_id, RATE_OFF, false);
+				resample_set(p_spdif->asrc_id, RATE_OFF);
 #endif
 #endif
 		}
 		if (intrpt_status & 0x10)
-			pr_info("Pd changed\n");
+			pr_debug("Pd changed\n");
 	} else {
 		if (intrpt_status & 0x8)
 			pr_debug("CH status changed\n");
@@ -731,7 +791,7 @@ static void spdifin_status_event(struct aml_spdif *p_spdif)
 		/* resample to 48k, by hw */
 		if (!spdifin_check_audiotype_by_sw(p_spdif))
 			resample_set(p_spdif->asrc_id,
-				p_spdif->auto_asrc, false);
+				p_spdif->auto_asrc);
 #endif
 	}
 	if (intrpt_status & 0x40)
@@ -1026,6 +1086,9 @@ static int aml_dai_spdif_probe(struct snd_soc_dai *cpu_dai)
 				__func__);
 	}
 
+	/* config ddr arb */
+	aml_spdif_arb_config(p_spdif->actrl);
+
 	return 0;
 }
 
@@ -1101,7 +1164,7 @@ static int aml_dai_spdif_startup(
 		/* resample to 48k in default, by hw */
 		if (!spdifin_check_audiotype_by_sw(p_spdif))
 			resample_set(p_spdif->asrc_id,
-				p_spdif->auto_asrc, false);
+				p_spdif->auto_asrc);
 #endif
 	}
 
@@ -1132,7 +1195,7 @@ static void aml_dai_spdif_shutdown(
 #ifdef __SPDIFIN_AUDIO_TYPE_HW__
 		/* resample disabled, by hw */
 		if (!spdifin_check_audiotype_by_sw(p_spdif))
-			resample_set(p_spdif->asrc_id, RATE_OFF, false);
+			resample_set(p_spdif->asrc_id, RATE_OFF);
 #endif
 		clk_disable_unprepare(p_spdif->clk_spdifin);
 		clk_disable_unprepare(p_spdif->fixed_clk);
@@ -1181,9 +1244,6 @@ static int aml_dai_spdif_prepare(
 		spdif_get_channel_status_info(&chsts, runtime->rate);
 		spdif_set_channel_status_info(&chsts, p_spdif->id);
 
-		/* TOHDMITX_CTRL0
-		 * Both spdif_a/spdif_b would notify to hdmitx
-		 */
 		spdifout_to_hdmitx_ctrl(p_spdif->id);
 		/* notify to hdmitx */
 		spdif_notify_to_hdmitx(substream);
@@ -1446,7 +1506,7 @@ static struct snd_soc_dai_driver aml_spdif_dai[] = {
 		.remove = aml_dai_spdif_remove,
 		.playback = {
 			  .channels_min = 1,
-			  .channels_max = 8,
+			  .channels_max = 2,
 			  .rates = AML_DAI_SPDIF_RATES,
 			  .formats = AML_DAI_SPDIF_FORMATS,
 		},
@@ -1651,6 +1711,9 @@ struct platform_driver aml_spdif_driver = {
 		.of_match_table = aml_spdif_device_id,
 	},
 	.probe = aml_spdif_platform_probe,
+	.suspend = aml_spdif_platform_suspend,
+	.resume  = aml_spdif_platform_resume,
+	.shutdown = aml_spdif_platform_shutdown,
 };
 module_platform_driver(aml_spdif_driver);
 
diff --git a/sound/soc/amlogic/auge/spdif_hw.c b/sound/soc/amlogic/auge/spdif_hw.c
index d7f1c2e0b701..31c0a750fdae 100644
--- a/sound/soc/amlogic/auge/spdif_hw.c
+++ b/sound/soc/amlogic/auge/spdif_hw.c
@@ -23,6 +23,12 @@
 
 #include <linux/amlogic/media/sound/aout_notify.h>
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+#include <linux/platform_data/board_odroid.h>
+#else
+#define board_is_odroidn2()	(0)
+#endif
+
 /*#define G12A_PTM*/
 /*#define __PTM_SPDIF_INTERNAL_LB__*/
 
@@ -663,8 +669,15 @@ void spdifout_play_with_zerodata(unsigned int spdif_id, bool reenable)
 
 		/* spdif clk */
 		//spdifout_clk_ctrl(spdif_id, true);
-		/* spdif to hdmitx */
-		spdifout_to_hdmitx_ctrl(spdif_id);
+
+		if (!board_is_odroidn2()) {
+			/* spdif to hdmitx */
+			spdifout_to_hdmitx_ctrl(spdif_id);
+		} else {
+			/* ODROID-N2 spdif_b only to hdmitx */
+			if (spdif_id == 1)
+				spdifout_to_hdmitx_ctrl(spdif_id);
+		}
 
 		/* spdif ctrl */
 		spdifout_fifo_ctrl(spdif_id,
diff --git a/sound/soc/amlogic/auge/tdm.c b/sound/soc/amlogic/auge/tdm.c
index 3e3c051c70b0..00c825d60da1 100644
--- a/sound/soc/amlogic/auge/tdm.c
+++ b/sound/soc/amlogic/auge/tdm.c
@@ -35,6 +35,7 @@
 #include <linux/amlogic/cpu_version.h>
 
 #include <linux/amlogic/media/sound/aout_notify.h>
+#include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_ext.h>
 
 #include "ddr_mngr.h"
 #include "tdm_hw.h"
@@ -130,13 +131,13 @@ static const struct snd_pcm_hardware aml_tdm_hardware = {
 	    SNDRV_PCM_FMTBIT_S32_LE,
 
 	.period_bytes_min = 64,
-	.period_bytes_max = 256 * 1024,
+	.period_bytes_max = 256 * 1024 * 2,
 	.periods_min = 2,
 	.periods_max = 1024,
 	.buffer_bytes_max = 1024 * 1024,
 
 	.rate_min = 8000,
-	.rate_max = 192000,
+	.rate_max = 384000,
 	.channels_min = 1,
 	.channels_max = 32,
 };
@@ -505,6 +506,7 @@ static int aml_dai_tdm_prepare(struct snd_pcm_substream *substream,
 
 		/* i2s source to hdmix */
 		if (p_tdm->i2s2hdmitx) {
+			hdmitx_ext_set_i2s_mask(2, 0x1);
 			i2s_to_hdmitx_ctrl(p_tdm->id);
 			aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,
 				substream);
@@ -764,7 +766,10 @@ static int pcm_setting_init(struct pcm_setting *setting, unsigned int rate,
 		/* for some TDM codec, mclk limites */
 		ratio = 2;
 	} else {
-		ratio = 4;
+		if (rate > 192000)
+			ratio = 2;
+		else
+			ratio = 4;
 	}
 	setting->sysclk_bclk_ratio = ratio;
 	setting->sysclk = ratio * setting->bclk;
@@ -918,10 +923,17 @@ static int aml_tdm_set_clk_pad(struct aml_tdm *p_tdm)
 					p_tdm->clk_sel);
 	}
 
+#ifdef CONFIG_ARCH_MESON64_ODROID_COMMON
+	aml_tdm_sclk_pad_select(p_tdm->actrl,
+				mpad_offset,
+				p_tdm->id,
+				p_tdm->clk_sel);
+#else
 	aml_tdm_sclk_pad_select(p_tdm->actrl,
 				mpad_offset,
 				p_tdm->id,
 				p_tdm->id);
+#endif
 
 	return 0;
 }
@@ -958,12 +970,6 @@ static int aml_dai_tdm_hw_params(struct snd_pcm_substream *substream,
 	if (ret)
 		return ret;
 
-	if (p_tdm->chipinfo && (!p_tdm->chipinfo->no_mclkpad_ctrl)) {
-		ret = aml_tdm_set_clk_pad(p_tdm);
-		if (ret)
-			return ret;
-	}
-
 	/* Must enabe channel number for VAD */
 	if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 		&& (vad_tdm_is_running(p_tdm->id)))
@@ -1407,7 +1413,7 @@ static struct snd_soc_dai_ops aml_dai_tdm_ops = {
 	.mute_stream = aml_dai_tdm_mute_stream,
 };
 
-#define AML_DAI_TDM_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_TDM_RATES		(SNDRV_PCM_RATE_8000_384000)
 #define AML_DAI_TDM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
 		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
@@ -1730,6 +1736,12 @@ static int aml_tdm_platform_probe(struct platform_device *pdev)
 		}
 	}
 
+	if (p_tdm->chipinfo && (!p_tdm->chipinfo->no_mclkpad_ctrl)) {
+		ret = aml_tdm_set_clk_pad(p_tdm);
+		if (ret)
+			dev_warn_once(&pdev->dev, "clk_pad set failed\n");
+	}
+
 	/* complete mclk for tdm */
 	if (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xa)
 		meson_clk_measure((1<<16) | 0x67);
@@ -1786,11 +1798,11 @@ static int aml_tdm_platform_suspend(struct platform_device *pdev,
 
 	/*mute default clk */
 	if (p_tdm->start_clk_enable == 1 && p_tdm->pin_ctl) {
-		struct pinctrl_state *state = NULL;
+		struct pinctrl_state *ps = NULL;
 
-		state = pinctrl_lookup_state(p_tdm->pin_ctl, "tdmout_a_gpio");
-		if (!IS_ERR_OR_NULL(state)) {
-			pinctrl_select_state(p_tdm->pin_ctl, state);
+		ps = pinctrl_lookup_state(p_tdm->pin_ctl, "tdmout_a_gpio");
+		if (!IS_ERR_OR_NULL(ps)) {
+			pinctrl_select_state(p_tdm->pin_ctl, ps);
 			pr_info("%s tdm pins disable!\n", __func__);
 		}
 	}
diff --git a/sound/soc/amlogic/auge/tdm_hw.c b/sound/soc/amlogic/auge/tdm_hw.c
index 3c557cc8456f..8f124e785b54 100644
--- a/sound/soc/amlogic/auge/tdm_hw.c
+++ b/sound/soc/amlogic/auge/tdm_hw.c
@@ -463,14 +463,11 @@ void aml_tdm_set_oe_v1(
 	struct aml_audio_controller *actrl,
 	int index, int force_oe, int oe_val)
 {
-	unsigned int reg, offset;
-
-	offset = EE_AUDIO_TDMOUT_B_CTRL0 - EE_AUDIO_TDMOUT_A_CTRL0;
-	reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
-
 	if (force_oe) {
-		offset = EE_AUDIO_TDMOUT_B_CTRL2 - EE_AUDIO_TDMOUT_A_CTRL2;
-		reg = EE_AUDIO_TDMOUT_A_CTRL2 + offset * index;
+		unsigned int reg, offset;
+
+		offset = EE_AUDIO_TDMOUT_B_CTRL0 - EE_AUDIO_TDMOUT_A_CTRL0;
+		reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
 
 		aml_audiobus_update_bits(actrl, reg, 0xf << 24, force_oe << 24);
 
@@ -484,9 +481,9 @@ void aml_tdm_set_oe_v2(
 	struct aml_audio_controller *actrl,
 	int index, int force_oe, int oe_val)
 {
-	unsigned int reg, offset;
-
 	if (force_oe) {
+		unsigned int reg, offset;
+
 		offset = EE_AUDIO_TDMOUT_B_CTRL2 - EE_AUDIO_TDMOUT_A_CTRL2;
 		reg = EE_AUDIO_TDMOUT_A_CTRL2 + offset * index;
 
diff --git a/sound/soc/amlogic/auge/tl1,clocks.c b/sound/soc/amlogic/auge/tl1,clocks.c
index 7f18e89ae3c3..db2a110f6e75 100644
--- a/sound/soc/amlogic/auge/tl1,clocks.c
+++ b/sound/soc/amlogic/auge/tl1,clocks.c
@@ -22,8 +22,6 @@
 #include "audio_clks.h"
 #include "regs.h"
 
-static spinlock_t aclk_lock;
-
 static const char *const mclk_parent_names[] = {
 	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
 	"fclk_div3", "fclk_div4", "fclk_div5"};
diff --git a/sound/soc/amlogic/auge/tm2,clocks.c b/sound/soc/amlogic/auge/tm2,clocks.c
index bb23cf22709b..a188d2ae6255 100644
--- a/sound/soc/amlogic/auge/tm2,clocks.c
+++ b/sound/soc/amlogic/auge/tm2,clocks.c
@@ -22,8 +22,6 @@
 #include "audio_clks.h"
 #include "regs.h"
 
-static spinlock_t aclk_lock;
-
 static const char *const mclk_parent_names[] = {
 	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
 	"fclk_div3", "fclk_div4", "fclk_div5"};
diff --git a/sound/soc/amlogic/auge/vad.c b/sound/soc/amlogic/auge/vad.c
index 5f09029069d6..85c0338be771 100644
--- a/sound/soc/amlogic/auge/vad.c
+++ b/sound/soc/amlogic/auge/vad.c
@@ -43,7 +43,7 @@
 #include <linux/input.h>
 #include <linux/amlogic/vad_api.h>
 
-#include "vad_hw_coeff.c"
+#include "vad_hw_coeff.h"
 #include "vad_hw.h"
 #include "vad.h"
 
@@ -207,6 +207,21 @@ bool vad_pdm_is_running(void)
 	return false;
 }
 
+bool vad_lb_is_running(int lb_id)
+{
+	int vad_src = (lb_id == 0) ? VAD_SRC_LOOPBACK_A : VAD_SRC_LOOPBACK_B;
+
+	if (vad_is_enable() && vad_src_check(vad_src))
+		return true;
+
+	return false;
+}
+
+void vad_lb_force_two_channel(bool en)
+{
+	vad_set_two_channel_en(en);
+}
+
 static void vad_notify_user_space(struct vad *p_vad)
 {
 	pr_info("Notify to wake up user space\n");
@@ -252,9 +267,9 @@ static int vad_transfer_data_to_algorithm(
 	int rate, int channels, int bitdepth)
 {
 	int ret = 0;
+
 	/* TODO: for test */
 	if (vad_in_kernel_test) {
-
 		if (vad_wakeup_count < 50)
 			return 0;
 
@@ -308,7 +323,7 @@ static int vad_engine_check(struct vad *p_vad)
 
 	read_bytes = frame_count * chnum * bytes_per_sample;
 	if (bytes < read_bytes) {
-		pr_debug("%s line:%d, %d bytes, need more data\n",
+		pr_warn("%s line:%d, %d bytes, need more data\n",
 			__func__, __LINE__, bytes);
 		return 0;
 	}
@@ -350,6 +365,7 @@ static int vad_engine_check(struct vad *p_vad)
 	}
 
 #ifdef __VAD_DUMP_DATA__
+	set_fs(KERNEL_DS);
 	vfs_write(p_vad->fp, p_vad->buf, read_bytes, &p_vad->pos);
 #endif
 
@@ -417,6 +433,7 @@ static int vad_set_clks(struct vad *p_vad, bool enable)
 		/* enable clock gate */
 		ret = clk_prepare_enable(p_vad->gate);
 
+		clk_set_rate(p_vad->pll, 25000000);
 		/* enable clock */
 		ret = clk_prepare_enable(p_vad->pll);
 		if (ret) {
@@ -483,7 +500,6 @@ static int vad_init(struct vad *p_vad)
 	}
 	p_vad->fs = get_fs();
 	p_vad->pos = 0;
-	set_fs(KERNEL_DS);
 #endif
 
 	} else if (p_vad->level == LEVEL_USER)
diff --git a/sound/soc/amlogic/auge/vad.h b/sound/soc/amlogic/auge/vad.h
index f3964a386034..610179ae7b5e 100644
--- a/sound/soc/amlogic/auge/vad.h
+++ b/sound/soc/amlogic/auge/vad.h
@@ -36,6 +36,8 @@ extern int vad_transfer_chunk_data(unsigned long data, int frames);
 
 extern bool vad_tdm_is_running(int tdm_idx);
 extern bool vad_pdm_is_running(void);
+bool vad_lb_is_running(int lb_id);
+void vad_lb_force_two_channel(bool en);
 
 extern void vad_enable(bool enable);
 extern void vad_set_toddr_info(struct toddr *to);
diff --git a/sound/soc/amlogic/auge/vad_hw.c b/sound/soc/amlogic/auge/vad_hw.c
index ba9b2d5b26f4..c9b7259ed7c9 100644
--- a/sound/soc/amlogic/auge/vad_hw.c
+++ b/sound/soc/amlogic/auge/vad_hw.c
@@ -112,3 +112,9 @@ void vad_force_clk_to_oscin(bool force)
 {
 	audiobus_update_bits(EE_AUDIO_CLK_VAD_CTRL, 0x1 << 30, force << 30);
 }
+
+void vad_set_two_channel_en(bool en)
+{
+	/* two_channel_en */
+	vad_update_bits(VAD_TOP_CTRL0, 0x1 << 20, en << 20);
+}
diff --git a/sound/soc/amlogic/auge/vad_hw.h b/sound/soc/amlogic/auge/vad_hw.h
index af0659c256bc..2e22168e780d 100644
--- a/sound/soc/amlogic/auge/vad_hw.h
+++ b/sound/soc/amlogic/auge/vad_hw.h
@@ -37,4 +37,7 @@ extern void vad_set_in(void);
 extern void vad_set_enable(bool enable);
 
 extern void vad_force_clk_to_oscin(bool force);
+
+void vad_set_two_channel_en(bool en);
+
 #endif
diff --git a/sound/soc/amlogic/auge/vad_hw_coeff.c b/sound/soc/amlogic/auge/vad_hw_coeff.h
similarity index 96%
rename from sound/soc/amlogic/auge/vad_hw_coeff.c
rename to sound/soc/amlogic/auge/vad_hw_coeff.h
index e521b9883375..4a04d5b91e2f 100644
--- a/sound/soc/amlogic/auge/vad_hw_coeff.c
+++ b/sound/soc/amlogic/auge/vad_hw_coeff.h
@@ -1,5 +1,5 @@
 /*
- * sound/soc/amlogic/auge/vad_hw_coeff.c
+ * sound/soc/amlogic/auge/vad_hw_coeff.h
  *
  * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
  *
@@ -15,6 +15,9 @@
  *
  */
 
+#ifndef __VAD_HW_COEFF_H__
+#define __VAD_HW_COEFF_H__
+
 /* parameters for downsample and emphasis filter */
 static int vad_de_coeff[] = {
 	0x31007f05,
@@ -165,3 +168,4 @@ static int vad_ram_coeff[] = {
 	0x00000FFF
 };
 
+#endif
diff --git a/sound/soc/amlogic/common/Makefile b/sound/soc/amlogic/common/Makefile
index 41087df65185..cc8b7a9d6291 100644
--- a/sound/soc/amlogic/common/Makefile
+++ b/sound/soc/amlogic/common/Makefile
@@ -1,3 +1,4 @@
 obj-y += notify.o \
 	spdif_info.o \
-	misc.o
+	misc.o \
+	iomapres.o
diff --git a/sound/soc/amlogic/common/iomapres.c b/sound/soc/amlogic/common/iomapres.c
new file mode 100644
index 000000000000..5d2d80e5ee9a
--- /dev/null
+++ b/sound/soc/amlogic/common/iomapres.c
@@ -0,0 +1,75 @@
+/*
+ * sound/soc/amlogic/common/iomapres.c
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/device.h>
+
+#include <linux/amlogic/media/sound/iomapres.h>
+
+struct regmap *regmap_resource(struct device *dev, char *name)
+{
+	struct resource res;
+	void __iomem *base;
+	struct device_node *node = dev->of_node;
+	static struct regmap_config aud_regmap_config = {
+		.reg_bits = 32,
+		.val_bits = 32,
+		.reg_stride = 4,
+	};
+	int i;
+
+	i = of_property_match_string(node, "reg-names", name);
+	if (of_address_to_resource(node, i, &res))
+		return ERR_PTR(-ENOENT);
+
+	base = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(base))
+		return ERR_CAST(base);
+
+	pr_info("%s, %s, start:%#x, size:%#x\n",
+		__func__, name, (u32)res.start, (u32)resource_size(&res));
+
+	aud_regmap_config.max_register = resource_size(&res) - 4;
+	aud_regmap_config.name =
+		devm_kasprintf(dev, GFP_KERNEL, "%s-%s", node->name, name);
+	if (!aud_regmap_config.name)
+		return ERR_PTR(-ENOMEM);
+
+	return devm_regmap_init_mmio(dev, base, &aud_regmap_config);
+}
+
+unsigned int mmio_read(struct regmap *map, unsigned int reg_ofs)
+{
+	unsigned int val;
+
+	regmap_read(map, (reg_ofs << 2), &val);
+
+	return val;
+}
+
+int mmio_write(struct regmap *map, unsigned int reg_ofs, unsigned int value)
+{
+	return regmap_write(map, (reg_ofs << 2), value);
+}
+
+int mmio_update_bits(struct regmap *map,
+		     unsigned int reg_ofs,
+		     unsigned int mask,
+		     unsigned int value)
+{
+	return regmap_update_bits(map, (reg_ofs << 2), mask, value);
+}
diff --git a/sound/soc/amlogic/common/misc.c b/sound/soc/amlogic/common/misc.c
index 1b4670564d6e..10c10a9e9b87 100644
--- a/sound/soc/amlogic/common/misc.c
+++ b/sound/soc/amlogic/common/misc.c
@@ -199,15 +199,21 @@ const struct soc_enum hdmi_in_status_enum[] = {
 			hdmi_in_audio_packet)
 };
 
-int aml_get_hdmiin_audio_stable(
-	struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+int get_hdmiin_audio_stable(void)
 {
 	struct rx_audio_stat_s aud_sts;
 
 	rx_get_audio_status(&aud_sts);
+
+	return (aud_sts.aud_rcv_packet == 0) ? 0 : 1;
+}
+
+int aml_get_hdmiin_audio_stable(
+	struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
 	ucontrol->value.integer.value[0] =
-		(aud_sts.aud_rcv_packet == 0) ? 0 : 1;
+		get_hdmiin_audio_stable();
 
 	return 0;
 }
diff --git a/sound/soc/amlogic/common/spdif_info.c b/sound/soc/amlogic/common/spdif_info.c
index 5caeee5768c2..5b87891668b2 100644
--- a/sound/soc/amlogic/common/spdif_info.c
+++ b/sound/soc/amlogic/common/spdif_info.c
@@ -34,11 +34,17 @@
 unsigned int IEC958_mode_codec;
 EXPORT_SYMBOL(IEC958_mode_codec);
 
+bool spdifout_is_raw(void)
+{
+	return (IEC958_mode_codec && IEC958_mode_codec != 9);
+}
+
 bool spdif_is_4x_clk(void)
 {
 	bool is_4x = false;
 
-	if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+	if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5 ||
+		IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
 		is_4x = true;
 	}
 
@@ -55,6 +61,7 @@ void spdif_get_channel_status_info(
 		pr_err("Unsupport sample rate\n");
 		return;
 	}
+
 	if (IEC958_mode_codec && IEC958_mode_codec != 9) {
 		if (IEC958_mode_codec == 1) {
 			/* dts, use raw sync-word mode */
@@ -77,10 +84,6 @@ void spdif_get_channel_status_info(
 				chsts->chstat1_l = 0Xe00;
 				chsts->chstat1_r = 0Xe00;
 			}
-		} else if (IEC958_mode_codec == 8 || IEC958_mode_codec == 7) {
-			/* DTS-HD MA, TrueHD */
-				chsts->chstat1_l = 0x900;
-				chsts->chstat1_r = 0x900;
 		} else {
 			/* DTS,DD */
 			if (rate_bit == SNDRV_PCM_RATE_32000) {
diff --git a/sound/soc/amlogic/meson/audio_hw.c b/sound/soc/amlogic/meson/audio_hw.c
index 5c4361d692e8..4a3848e82a75 100644
--- a/sound/soc/amlogic/meson/audio_hw.c
+++ b/sound/soc/amlogic/meson/audio_hw.c
@@ -434,8 +434,10 @@ static void i2sin_fifo2_set_buf(u32 addr, u32 size, u32 src, u32 ch)
 	);
 
 	if (audio_in_source == 1) {
-		/* ATV from adec */
-		aml_audin_write(AUDIN_ATV_DEMOD_CTRL, 7);
+		/* commented it, selected by atv demod,
+		 * select 0 for non standard signal.
+		 */
+		/*aml_audin_write(AUDIN_ATV_DEMOD_CTRL, 7);*/
 		aml_audin_update_bits(AUDIN_FIFO2_CTRL,
 				 (0x7 << AUDIN_FIFO_DIN_SEL),
 				 (ATV_ADEC << AUDIN_FIFO_DIN_SEL));
@@ -459,6 +461,22 @@ static void i2sin_fifo2_set_buf(u32 addr, u32 size, u32 src, u32 ch)
 
 }
 
+/* source select
+ * 0: select from ATV;
+ * 1: select from ADEC;
+ */
+void atv_src_select(bool src)
+{
+	aml_audin_update_bits(AUDIN_ATV_DEMOD_CTRL,
+			0x3, (src ? 0x3 : 0x0));
+}
+
+void atv_LR_swap(bool swap)
+{
+	aml_audin_update_bits(AUDIN_ATV_DEMOD_CTRL,
+			0x1 << 2, swap << 2);
+}
+
 static void spdifin_reg_set(void)
 {
 	/* get clk81 clk_rate */
diff --git a/sound/soc/amlogic/meson/audio_hw.h b/sound/soc/amlogic/meson/audio_hw.h
index b4d38b85ee6e..e69fca7eae45 100644
--- a/sound/soc/amlogic/meson/audio_hw.h
+++ b/sound/soc/amlogic/meson/audio_hw.h
@@ -198,6 +198,9 @@ extern bool is_audin_lr_invert_check(void);
 extern bool is_audbuf_gate_rm(void);
 extern void chipset_set_spdif_pao(void);
 
+extern void atv_src_select(bool src);
+extern void atv_LR_swap(bool swap);
+
 extern unsigned int IEC958_mode_codec;
 extern unsigned int clk81;
 
diff --git a/sound/soc/amlogic/meson/i2s_dai.c b/sound/soc/amlogic/meson/i2s_dai.c
index 381f3898a25b..ea55b3753698 100644
--- a/sound/soc/amlogic/meson/i2s_dai.c
+++ b/sound/soc/amlogic/meson/i2s_dai.c
@@ -48,6 +48,9 @@
 #include <linux/amlogic/media/sound/aout_notify.h>
 #include "spdif_dai.h"
 #include "dmic.h"
+#ifdef CONFIG_AMLOGIC_SND_USB_CAPTURE_DATA
+#include <linux/amlogic/media/sound/usb_karaoke.h>
+#endif
 
 static int i2s_clk_get(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_value *ucontrol)
@@ -279,12 +282,34 @@ static int aml_dai_i2s_prepare(struct snd_pcm_substream *substream,
 			/* use the hw same sync for i2s/958 */
 			pr_debug("i2s/958 same source\n");
 		}
+#ifdef CONFIG_AMLOGIC_SND_USB_CAPTURE_DATA
+		aml_i2s_set_ch_r_info(runtime->channels, runtime->rate);
+		i2s_out_mix_init();
+#endif
 		if (runtime->channels == 8) {
-			pr_debug("8ch PCM output->notify HDMI\n");
-			aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,
-				substream);
+			dev_info(substream->pcm->card->dev, "8ch PCM output->notify HDMI\n");
+			aout_notifier_call_chain(
+					AOUT_EVENT_IEC_60958_PCM,
+					substream);
 		}
 	}
+
+	return 0;
+}
+
+static int aml_dai_i2s_hw_free(
+		struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+#ifdef CONFIG_AMLOGIC_SND_USB_CAPTURE_DATA
+	struct aml_runtime_data *prtd = substream->runtime->private_data;
+	struct audio_stream *s = &prtd->s;
+
+	if (s && s->device_type == AML_AUDIO_I2SOUT) {
+		i2s_out_mix_deinit();
+		aml_i2s_set_ch_r_info(0, 0);
+	}
+#endif
 	return 0;
 }
 
@@ -431,6 +456,7 @@ static struct snd_soc_dai_ops aml_dai_i2s_ops = {
 	.prepare    = aml_dai_i2s_prepare,
 	.trigger    = aml_dai_i2s_trigger,
 	.hw_params  = aml_dai_i2s_hw_params,
+	.hw_free    = aml_dai_i2s_hw_free,
 	.set_fmt    = aml_dai_set_i2s_fmt,
 	.set_sysclk = aml_dai_set_i2s_sysclk,
 };
diff --git a/sound/soc/amlogic/meson/i2s_dai.h b/sound/soc/amlogic/meson/i2s_dai.h
index 202b6f5975bb..88dea68aeb95 100644
--- a/sound/soc/amlogic/meson/i2s_dai.h
+++ b/sound/soc/amlogic/meson/i2s_dai.h
@@ -28,4 +28,5 @@ struct aml_i2s {
 	int clk_data_pos;
 	unsigned long mclk;
 };
+
 #endif
diff --git a/sound/soc/amlogic/meson/pcm.c b/sound/soc/amlogic/meson/pcm.c
index 89df53d12706..489f082f33d7 100644
--- a/sound/soc/amlogic/meson/pcm.c
+++ b/sound/soc/amlogic/meson/pcm.c
@@ -242,7 +242,9 @@ static int aml_pcm_timer_create(struct snd_pcm_substream *substream)
 	prtd->timer_period = 1;
 	prtd->timer.data = (unsigned long)substream;
 	prtd->timer.function = aml_pcm_timer_callback;
+	spin_lock(&prtd->lock);
 	prtd->running = 0;
+	spin_unlock(&prtd->lock);
 
 	return 0;
 }
diff --git a/sound/soc/amlogic/meson/pcm_dai.c b/sound/soc/amlogic/meson/pcm_dai.c
index 9f09273c5904..248a720f4202 100644
--- a/sound/soc/amlogic/meson/pcm_dai.c
+++ b/sound/soc/amlogic/meson/pcm_dai.c
@@ -145,12 +145,17 @@ static int aml_pcm_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	struct aml_pcm *pcm_p = dev_get_drvdata(dai->dev);
 
+	if (!pcm_p) {
+		pr_err("%s(), null ptr\n", __func__);
+		return -EINVAL;
+	}
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/* TODO */
-		if (pcm_p && pcm_p->pcm_mode) {
+		if (pcm_p->pcm_mode) {
 			pr_info("aiu pcm master stream %d enable\n\n",
 				substream->stream);
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
@@ -169,7 +174,7 @@ static int aml_pcm_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (pcm_p && pcm_p->pcm_mode) {
+		if (pcm_p->pcm_mode) {
 			pr_info("aiu master pcm stream %d disable\n\n",
 				substream->stream);
 			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-- 
2.25.1

